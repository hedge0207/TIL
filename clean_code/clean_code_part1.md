> 아키텍처도, 깨끗한 코드도, 완벽을 주장하지는 않는다. 단지 최선을 다해 정직하라 요구할 뿐이다. 오류는 인간의 본성이고 용서는 신의 본성이다. 스크럼에서 우리는 모든 것을 드러낸다. 더러운 빨래를 기꺼이 공개한다. 코드는 결코 완벽하지 않으므로 자신의 코드 상태를 정직하게 말한다. 좀 더 인간적이 되고, 좀 더 신의 용서를 받을 자격을 갖추며, 좀 더 세세함에 깃든 위대함에 가까워진다.
>
> -추천사에서 제임스 O. 코플리엔



# 깨끗한 코드

> 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다.
>
> ...
>
> 나중은 결코 오지 않는다.

- 나쁜 코드는 생산성 저하의 원인이다.
  - 개발 일정 등을 핑계로 급하게 짠 나쁜 코드는 언젠가는 개발 속도를 늦추는 원인이 된다.
  - 장기적인 관점에서 볼 때, 개발 일정을 맞추는 유일한 방법은 코드를 깨끗한 상태로 유지하는 일이다.



- 무엇이 깨끗한 코드인가

  - 비야네 스트롭스트룹(C++ 창시자)
    - 우아하고(누구에게나 쉽게 읽히며) 효율적인(속도가 빠르고 자원 낭비가 적은) 코드
    - 논리가 간단해야 버그가 숨어들지 못한다.
    - 의존성을 줄여야 유지보수가 쉬워진다.
    - 오류는 명백한 전력에 의거해 철저히 처리한다.
    - 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.
    - **깨끗한 코드는 한 가지를 제대로 한다.**
  - 그래디 부치
    - 깨끗한 코드는 단순하고 직접적이다.
    - 잘 쓴 문장처럼 읽힌다.
    - 결코 설계자의 의도를 숨기지 않는다.
    - 명쾌한 추상화와 단순한 제어문으로 가득하다.

  - 데이브 토마스
    - 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
    - 단위 테스트 케이스와 인수 테스트 케이스가 존재한다.
    - 깨끗한 코드에는 의미 있는 이름이 붙는다.
    - 특정 목적을 달성하는 방법은 여러 가지가 아닌 하나만 제공한다.
    - 의존성을 최소화하며 각 의존성을 명확히 정의한다.
    - API는 명확하며 최소화한다.
    - 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.
  - 마이클 페더스
    - 깨끗한 코드는 누군가 주의 깊게 짰다는 느낌을 준다.
    - 고치려고 살펴봐도 딱히 손 댈 곳이 없다.
  - 론 제프리스
    - 모든 테스트를 통과한다.
    - 중복이 없다.
    - 시스템 내 모든 설계 아이디어를 표현한다.
    - 클래스, 메서드, 함수 등을 최대한 줄인다.

  - 워드 커닝햄
    - 코드를 읽으면서 짐작했던 기능들을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
    - 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.
    - 즉 읽으면서 짐작한 대로 동작하는 코드가 깨끗한 코드다.



# 의미있는 이름

- 소프트웨어에서 이름은 어디나 쓰인다.
  - 변수, 함수, 인수, 클래스, 패키지, 소스파일, 파일이 담긴 디렉터리 등 모든 것에 이름을 붙인다.
  - 좋은 이름을 붙이는 데는 시간이 걸리지만 좋은 이름으로 절약하는 시간은 훨씬 더 많다.
  - 이름을 잘 지으면 여러모로 편리하므로 아래에서는 이름을 잘 짓는 몇 가지 원칙을 소개한다.



## 의도를 분명히 밝혀라

- 이름에는 의도가 담겨야한다.
  - 이름은 다음과 같은 질문에 모두 답해야 한다.
    - 변수의 존재 이유
    - 수행하는 기능
    - 사용 방법
  - 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.



- 나쁜 코드

  ```python
  def get_them(the_list):
      list1 = []
      for x in range(the_list):
          if the_list[0]==4:
              list1.append(the_list[x])
  	return list1
  ```

  - 단순한 코드임에도 알아보기 어렵다.
  - 문제는 코드의 단순성이 아니라 함축성이다.
  - 위 코드엔 아래와 같은 정보가 드러나지 않는다.
    - `the_list`에 무엇이 들어있는가
    - `the_list`에서 0번째 값이 왜 중요한가
    - 4는 어떤 의미인가?
    - 함수가 반환하는 `list1`을 어떻게 사용하는가?



- 좋은 코드

  ```python
  def get_flagged_cells(game_board):
      flagged_cells = []
      for cell in game_board:
          if cell[STATUS_VALUE]==FLAGGED:
              flagged_cells.append(cell)
      return flagged_cells
  ```

  - 코드만 보고도 아래의 사실이 유추가 가능하다.
    - game_board 안에는 게임 판의 cell 들이 들어 있다.
    - 각 cell의 STATUS_VALUE번째 값은 칸의 상태를 뜻한다.
    - FLAGGED는 깃발이 꽂힌 상태를 뜻한다.
    - 반환값인 `flagged_cells`는 깃발이 꽂힌 칸이 담긴다.
  - 위 코드만 보고도 지뢰 찾기 게임 코드의 일부라는 사실을 알 수 있다.



## 그릇된 정보를 피하라

- 코드에 그릇된 단서를 남겨서는 안된다.
  - 그릇된 단서는 코드의 의미를 흐린다.



- 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안된다.
  - 예를 들어 직각 삼각형의 빗변(hypotenuse)을 hp로 줄이는 것은 읽는 사람들에게 그릇된 정보를 제공한다.



- 그룹으로 묶을 때, 실제로 list에 의해 묶여 있는 것이 아니라면 list라 명명하지 않는다.
  - 예를 들어 계정 정보를 묶을 때 실제 list로 묶은 것이 아니라 set 등에 저장했다면 account_list와 같은 이름은 사용하지 않는다.
  - 대신 account_group, bunch_of_account, accounts라 명명한다.



- 서로 흡사한 이름을 사용하지 않도록 주의한다.
  - 흡사한 이름은 보는 사람으로 하여금 혼동을 일으킨다.
  - 예를 들어 한 모듈에서 controller_for_efficient_handling_of_strings라는 이름을 사용하고, 다른 모듈에서 controller_for_efficient_storage_of_strings라고 사용한다면 보는 사람이 혼동일 일으킬 수 있다.



- 유사한 개념은 유사한 표기법을 사용한다.
  - 일관성이 떨어지는 표기법은 그릇된 정보다.



## 의미 있게 구분하라

- 동일한 범위 내에서 다른 두 개념에는 동일한 이름을 사용하지 못한다.
  - 따라서 이 둘의 이름은 개념의 특색에 따라 구분되어야 한다.



- 연속된 숫자를 덧붙이는 방식은 적절하지 못하다.

  ```python
  def some_func(a1, a2):
      pass
  ```



- 불용어를 추가하는 것은 적절치 못하다.

  - 예를 들어 product라는 이름이 이미 존재한다고 해서 아래와 같이 아무런 의미도 없는 불용어를 추가해서 사용하는 것은 문제가 될 수 있다.
  - 이름을 가지고 정확히 무슨 역할을 하는 변수인지 구분이 가지 않는다.

  ```python
  a_product = None
  products = []
  the_product = "product"
  ```

  - 물론 특정한 규칙을 가지고 불용어를 사용하는 것은 문제가 되지 않는다.
    - 예를 들어 모든 지역 변수에는 `a`를 붙이고 모든 함수 인수는 `the`를 붙이는 것과 같이 변수명을 통해 해당 변수의 역할을 유추할 수 있으면 된다.
  - data, info 같은 경우도 마찬가지로 의미가 불분명한 불용어이다.
    - 아래 변수명들이 각기 어떤 데이터를 담고 있는지를 이름만 보고는 파악하기 힘들다.
    - active_account, active_accounts, active_account_info, active_account_data



- 중복을 피해라
  - 코드 이름을 역전앞과 같이 중복되게 지어서는 안된다.
  - 변수명에 variable 같은 단어는 금물이다.
    - name과 구분하기 위해 변수명을 name_variable이라고 짓는다고 해서 name_variable이 name에 비해 추가적인 정보를 제공하는 것은 아무 것도 없다.
  - name_string과 같은 변수명도 마찬가지다.
    - name은 string 이외의 타입을 담고 있다고 생각하기는 힘들기에 사실상 중복된 이름이라고 할 수 있다.





## 맥락



- 의미 있는 맥락을 추가하라

  - 스스로 의미가 분명한 이름이 없지 않다.
    - 하지만 대다수 이름은 그렇지 못하다.
    - 따라서 이름을 클래스, 혹은 함수 내의 맥락에서 해석되도록 할 수 있다.
  - 나쁜 예시
    - 아래 변수명은 끝까지 읽어보면 학생에 대한 정보들을 저장한 변수라는 것을 알 수 있다.
    - 그러나 만일 `get_address` 라는 함수에서 address라는 변수 하나만 사용한다면 해당 address가 어떤 address인지 알 수 없을 것이다.

  ```python
  first_name
  last_name
  age
  address
  grade
  student_number
  ```

  - 좋은 예시
    - 클래스라는 맥락을 부여하여 학생에 관한 정보라는 것을 분명히 해준다.

  ```python
  class Student:
      def __init__(self, first_name, last_name, age, 
                   address, grade, student_number):
          self.first_name=first_name
          self.last_name=last_name
          self.age=age
          self.address=address
          self.grade=grade
          self.student_number=student_number
  ```



- 불필요한 맥락을 없애라
  - 일반적으로 짧은 이름이 긴 이름보다 좋다.
    - 단, 의미가 분명한 경우에 한해서다
    - 이름에 불필요한 맥락을 추가하지 않도록 주의한다.
  - 예를 들어 postal_address와 mac_address, web_address는 인스턴스 이름으로는 적합하지만 클래스 이름으로는 적합하지 못하다.
    - 셋을 구분해야 한다면 PostalAddress, MAC, URI라는 이름이 클래스명으로 더 적합하다.



## 단어

- 한 개념에 한 단어를 사용해라.
  - 추상적인 개념 하나에 단어 하나를 선택해 이를 유지한다.
  - 예를 들어 무언가를 무언가를 조회하는 메서드를 작성할 때 조회라는 동일한 기능을 하면서 아래와 같이 각기 다른 단어를 사용해선 안된다.
    - fetch, retrieve, get



- 힌 단어를 두 가지 목적으로 사용하지 마라

  - "한 개념에 한 단어를 사용해라"라는 규칙을 지키고자 같은 개념이 아닌데도 한 단어를 사용하게 될 수 있다.

  - 예를 들어 기존에 add라는 단어를 두 값을 더해서 새로운 값을 만드는 개념을 표현하기 위해 사용했다고 가정하자.
    - 새로운 메서드는 list에 값 하나를 추가하는 메서드인데, 이 메서드에 add라는 단어를 사용해도 될까?
    - 두 개의 값을 더하는 것과 list에 값을 추가하는 것은 다른 개념이다.
    - 따라서 add가 아닌 insert, append 같이 다른 단어를 사용하는 것이 맞다.



- 코드를 읽을 사람도 프로그래머라는 것을 명심해라
  - 전산 용어, 알고리즘 이름, 자료구조 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다.
  - 프로그래머에게 익숙한 기술 개념은 아주 많다.
    - 기술 개념에는 기술 이름이 가장 적합한 선택이다.
    - 예를 들어 순차적으로 저장하여 순차적으로 처리하는 이름이 필요하다면 queue라는 단어를 활용하여 이름을 붙이는 것이 가장 적합한 선택이다.



## 기타

- 발음하기 쉬운 이름을 사용해라
  - 기본적으로 누구나 동일한 발음으로 발음할 수 있는 이름을 사용해야 한다.
  - 만일 같은 이름을 각기 다르게 발음한다면 협업이 힘들어진다.



- 검색하기 쉬운 이름을 사용하라
  - 문자 하나를 사용하는 이름 및 상수는 코드상에서 쉽게 눈에 띄지 않을 뿐더라 검색도 어렵다.
  - 따라서 지나치게 짧은 이름 보다는 긴 이름이 좋다.



- 자신의 기억력을 자랑하지 마라
  - 문자 하나만 사용하는 변수 이름은 문제가 있다.
    - 루프에서 반복 횟수를 세는 i, j, k는 괜찮다.
    - 그 외에는 대부분 적절치 못하다.
  - 독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수명은 적절하지 못하다.
    - 즉 자신이 기억하기 쉬운 코드가 아니라 다른 사람이 읽었을 때에도 기억하기 쉬운 이름을 사용해야 한다.
  - 또한 기발한 이름을 피하는 것이 좋다.
    - 기발한 이름은 자신과 유머 감각이 비슷한 사람만 알아들을 수 있다.



- 클래스명과 메서드명

  - 클래스명은 명사나 명사구가 적합하다.

    - 동사는 사용하지 않는다.

    - Customer, WikiPage, Account 등이 좋은 예이다.
    - Manager, Processor, Data, Info 등과 같은 단어는 피해야한다.

  - 메서드명은 동사나 동사구가 적합하다.

    - post_payment, delete_page, save 등이 좋은 예이다.
    - 접근자, 변경자, 조건자 등은 get, set, is 를 붙인다.



# 함수

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

## 작게 만들어라

- 함수를 만드는 첫째 규칙은 '작게!'다.
  - 함수를 만드는 두 번째 규칙은 '더 작게!'다.



- 조건문, 반복문 등에 들어가는 불록은 한 줄이어야 한다.
  - 과장된 표현일 수 있지만, 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.
  - 들여쓰기마다 함수를 새로생성하여 처리한다.
    - 이렇게 하면 바깥은 감싸는 함수(원래 함수)가 더 작아진다.
    - 또한 블록 안에서 호출하는 함수 이름을 적절히 짓는다면 코드를 이해하기도 쉬워진다.



## 한가지만 해라

- 함수가 한 가지만 하는지 판단하는 방법은  추상화 수준이 하나인지 확인하는 것이다.

  - 여기서 추상화란 실제 구현과 얼마나 멀리 떨어져 있는가를 말한다. 
    - 복잡한 실제 구현은 숨기고 목적을 분명히하여 핵심만 드러내는 것이다.
    - 실제 구현과 멀리 떨어져 있을 수록 추상화 수준이 높다고 볼 수있다.
  - 아래 코드는 추상화 수준이 매우 낮은 함수이다(보다 적절한 예시를 찾을 경우 변경).
    - 함수 내에 실제 구현이 모두 들어가 있기 때문이다.
    - 함수가 구체적으로 어떤 과정을 거쳐 id를 통해 user 이름을 가져오는지 딱 봐서는 알 수가 없다.

  ```python
  def get_user_name_by_id(user_id):
      user_name_id_pair = []
      for user in users:
          user_name_id_pair.append({user['id']:user['name']})
      
      for id, name in user_name_id_pair.items():
          if id==user_id:
              return name 
  ```

  - 위 코드를 추상화하여 아래와 같이 변경할 수 있다.
    - 아래 코드도 `user_name_id_pair = make_name_id_pair()` 부분은 아직 추상화 수준이 높다고 볼 수 는 없다.

  ```python
  def get_user_name_by_id(user_id):
      user_name_id_pair = make_name_id_pair()
      return find_name(user_name_id_pair)
  ```

  - 클래스를 활용하면 추가적인 추상화가 가능하다.
    - 맨 처음 작성했던 코드보다 짧아졌을 뿐 아니라 읽기도 편한 코드가 됐다.
    - 함수 안에서 사용된 함수의 이름들을 통해 name과 id의 쌍을 만들고, 해당 쌍을 순회하면서 name을 찾아낸다는 것을 바로 알 수 있게 된다.

  ```python
  class User:
      def __init__(self):
          self.name_id_pair = []
  
      def get_user_name_by_id(user_id):
          make_name_id_pair()
          return find_name(self.name_id_pair)
  ```



- 

