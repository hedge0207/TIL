> 아키텍처도, 깨끗한 코드도, 완벽을 주장하지는 않는다. 단지 최선을 다해 정직하라 요구할 뿐이다. 오류는 인간의 본성이고 용서는 신의 본성이다. 스크럼에서 우리는 모든 것을 드러낸다. 더러운 빨래를 기꺼이 공개한다. 코드는 결코 완벽하지 않으므로 자신의 코드 상태를 정직하게 말한다. 좀 더 인간적이 되고, 좀 더 신의 용서를 받을 자격을 갖추며, 좀 더 세세함에 깃든 위대함에 가까워진다.
>
> -추천사에서 제임스 O. 코플리엔



# 깨끗한 코드

> 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다.
>
> ...
>
> 나중은 결코 오지 않는다.

- 나쁜 코드는 생산성 저하의 원인이다.
  - 개발 일정 등을 핑계로 급하게 짠 나쁜 코드는 언젠가는 개발 속도를 늦추는 원인이 된다.
  - 장기적인 관점에서 볼 때, 개발 일정을 맞추는 유일한 방법은 코드를 깨끗한 상태로 유지하는 일이다.



- 무엇이 깨끗한 코드인가

  - 비야네 스트롭스트룹(C++ 창시자)
    - 우아하고(누구에게나 쉽게 읽히며) 효율적인(속도가 빠르고 자원 낭비가 적은) 코드
    - 논리가 간단해야 버그가 숨어들지 못한다.
    - 의존성을 줄여야 유지보수가 쉬워진다.
    - 오류는 명백한 전력에 의거해 철저히 처리한다.
    - 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.
    - **깨끗한 코드는 한 가지를 제대로 한다.**
  - 그래디 부치
    - 깨끗한 코드는 단순하고 직접적이다.
    - 잘 쓴 문장처럼 읽힌다.
    - 결코 설계자의 의도를 숨기지 않는다.
    - 명쾌한 추상화와 단순한 제어문으로 가득하다.

  - 데이브 토마스
    - 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
    - 단위 테스트 케이스와 인수 테스트 케이스가 존재한다.
    - 깨끗한 코드에는 의미 있는 이름이 붙는다.
    - 특정 목적을 달성하는 방법은 여러 가지가 아닌 하나만 제공한다.
    - 의존성을 최소화하며 각 의존성을 명확히 정의한다.
    - API는 명확하며 최소화한다.
    - 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.
  - 마이클 페더스
    - 깨끗한 코드는 누군가 주의 깊게 짰다는 느낌을 준다.
    - 고치려고 살펴봐도 딱히 손 댈 곳이 없다.
  - 론 제프리스
    - 모든 테스트를 통과한다.
    - 중복이 없다.
    - 시스템 내 모든 설계 아이디어를 표현한다.
    - 클래스, 메서드, 함수 등을 최대한 줄인다.

  - 워드 커닝햄
    - 코드를 읽으면서 짐작했던 기능들을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
    - 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.
    - 즉 읽으면서 짐작한 대로 동작하는 코드가 깨끗한 코드다.



# 의미있는 이름

- 소프트웨어에서 이름은 어디나 쓰인다.
  - 변수, 함수, 인수, 클래스, 패키지, 소스파일, 파일이 담긴 디렉터리 등 모든 것에 이름을 붙인다.
  - 좋은 이름을 붙이는 데는 시간이 걸리지만 좋은 이름으로 절약하는 시간은 훨씬 더 많다.
  - 이름을 잘 지으면 여러모로 편리하므로 아래에서는 이름을 잘 짓는 몇 가지 원칙을 소개한다.



## 의도를 분명히 밝혀라

- 이름에는 의도가 담겨야한다.
  - 이름은 다음과 같은 질문에 모두 답해야 한다.
    - 변수의 존재 이유
    - 수행하는 기능
    - 사용 방법
  - 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.



- 나쁜 코드

  ```python
  def get_them(the_list):
      list1 = []
      for x in range(the_list):
          if the_list[0]==4:
              list1.append(the_list[x])
  	return list1
  ```

  - 단순한 코드임에도 알아보기 어렵다.
  - 문제는 코드의 단순성이 아니라 함축성이다.
  - 위 코드엔 아래와 같은 정보가 드러나지 않는다.
    - `the_list`에 무엇이 들어있는가
    - `the_list`에서 0번째 값이 왜 중요한가
    - 4는 어떤 의미인가?
    - 함수가 반환하는 `list1`을 어떻게 사용하는가?



- 좋은 코드

  ```python
  def get_flagged_cells(game_board):
      flagged_cells = []
      for cell in game_board:
          if cell[STATUS_VALUE]==FLAGGED:
              flagged_cells.append(cell)
      return flagged_cells
  ```

  - 코드만 보고도 아래의 사실이 유추가 가능하다.
    - game_board 안에는 게임 판의 cell 들이 들어 있다.
    - 각 cell의 STATUS_VALUE번째 값은 칸의 상태를 뜻한다.
    - FLAGGED는 깃발이 꽂힌 상태를 뜻한다.
    - 반환값인 `flagged_cells`는 깃발이 꽂힌 칸이 담긴다.
  - 위 코드만 보고도 지뢰 찾기 게임 코드의 일부라는 사실을 알 수 있다.



## 그릇된 정보를 피하라

- 코드에 그릇된 단서를 남겨서는 안된다.
  - 그릇된 단서는 코드의 의미를 흐린다.



- 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안된다.
  - 예를 들어 직각 삼각형의 빗변(hypotenuse)을 hp로 줄이는 것은 읽는 사람들에게 그릇된 정보를 제공한다.



- 그룹으로 묶을 때, 실제로 list에 의해 묶여 있는 것이 아니라면 list라 명명하지 않는다.
  - 예를 들어 계정 정보를 묶을 때 실제 list로 묶은 것이 아니라 set 등에 저장했다면 account_list와 같은 이름은 사용하지 않는다.
  - 대신 account_group, bunch_of_account, accounts라 명명한다.



- 서로 흡사한 이름을 사용하지 않도록 주의한다.
  - 흡사한 이름은 보는 사람으로 하여금 혼동을 일으킨다.
  - 예를 들어 한 모듈에서 controller_for_efficient_handling_of_strings라는 이름을 사용하고, 다른 모듈에서 controller_for_efficient_storage_of_strings라고 사용한다면 보는 사람이 혼동일 일으킬 수 있다.



- 유사한 개념은 유사한 표기법을 사용한다.
  - 일관성이 떨어지는 표기법은 그릇된 정보다.



## 의미 있게 구분하라

- 동일한 범위 내에서 다른 두 개념에는 동일한 이름을 사용하지 못한다.
  - 따라서 이 둘의 이름은 개념의 특색에 따라 구분되어야 한다.



- 연속된 숫자를 덧붙이는 방식은 적절하지 못하다.

  ```python
  def some_func(a1, a2):
      pass
  ```



- 불용어를 추가하는 것은 적절치 못하다.

  - 예를 들어 product라는 이름이 이미 존재한다고 해서 아래와 같이 아무런 의미도 없는 불용어를 추가해서 사용하는 것은 문제가 될 수 있다.
  - 이름을 가지고 정확히 무슨 역할을 하는 변수인지 구분이 가지 않는다.

  ```python
  a_product = None
  products = []
  the_product = "product"
  ```

  - 물론 특정한 규칙을 가지고 불용어를 사용하는 것은 문제가 되지 않는다.
    - 예를 들어 모든 지역 변수에는 `a`를 붙이고 모든 함수 인수는 `the`를 붙이는 것과 같이 변수명을 통해 해당 변수의 역할을 유추할 수 있으면 된다.
  - data, info 같은 경우도 마찬가지로 의미가 불분명한 불용어이다.
    - 아래 변수명들이 각기 어떤 데이터를 담고 있는지를 이름만 보고는 파악하기 힘들다.
    - active_account, active_accounts, active_account_info, active_account_data



- 중복을 피해라
  - 코드 이름을 역전앞과 같이 중복되게 지어서는 안된다.
  - 변수명에 variable 같은 단어는 금물이다.
    - name과 구분하기 위해 변수명을 name_variable이라고 짓는다고 해서 name_variable이 name에 비해 추가적인 정보를 제공하는 것은 아무 것도 없다.
  - name_string과 같은 변수명도 마찬가지다.
    - name은 string 이외의 타입을 담고 있다고 생각하기는 힘들기에 사실상 중복된 이름이라고 할 수 있다.





## 맥락



- 의미 있는 맥락을 추가하라

  - 스스로 의미가 분명한 이름이 없지 않다.
    - 하지만 대다수 이름은 그렇지 못하다.
    - 따라서 이름을 클래스, 혹은 함수 내의 맥락에서 해석되도록 할 수 있다.
  - 나쁜 예시
    - 아래 변수명은 끝까지 읽어보면 학생에 대한 정보들을 저장한 변수라는 것을 알 수 있다.
    - 그러나 만일 `get_address` 라는 함수에서 address라는 변수 하나만 사용한다면 해당 address가 어떤 address인지 알 수 없을 것이다.

  ```python
  first_name
  last_name
  age
  address
  grade
  student_number
  ```

  - 좋은 예시
    - 클래스라는 맥락을 부여하여 학생에 관한 정보라는 것을 분명히 해준다.

  ```python
  class Student:
      def __init__(self, first_name, last_name, age, 
                   address, grade, student_number):
          self.first_name=first_name
          self.last_name=last_name
          self.age=age
          self.address=address
          self.grade=grade
          self.student_number=student_number
  ```



- 불필요한 맥락을 없애라
  - 일반적으로 짧은 이름이 긴 이름보다 좋다.
    - 단, 의미가 분명한 경우에 한해서다
    - 이름에 불필요한 맥락을 추가하지 않도록 주의한다.
  - 예를 들어 postal_address와 mac_address, web_address는 인스턴스 이름으로는 적합하지만 클래스 이름으로는 적합하지 못하다.
    - 셋을 구분해야 한다면 PostalAddress, MAC, URI라는 이름이 클래스명으로 더 적합하다.



## 단어

- 한 개념에 한 단어를 사용해라.
  - 추상적인 개념 하나에 단어 하나를 선택해 이를 유지한다.
  - 예를 들어 무언가를 무언가를 조회하는 메서드를 작성할 때 조회라는 동일한 기능을 하면서 아래와 같이 각기 다른 단어를 사용해선 안된다.
    - fetch, retrieve, get



- 힌 단어를 두 가지 목적으로 사용하지 마라

  - "한 개념에 한 단어를 사용해라"라는 규칙을 지키고자 같은 개념이 아닌데도 한 단어를 사용하게 될 수 있다.

  - 예를 들어 기존에 add라는 단어를 두 값을 더해서 새로운 값을 만드는 개념을 표현하기 위해 사용했다고 가정하자.
    - 새로운 메서드는 list에 값 하나를 추가하는 메서드인데, 이 메서드에 add라는 단어를 사용해도 될까?
    - 두 개의 값을 더하는 것과 list에 값을 추가하는 것은 다른 개념이다.
    - 따라서 add가 아닌 insert, append 같이 다른 단어를 사용하는 것이 맞다.



- 코드를 읽을 사람도 프로그래머라는 것을 명심해라
  - 전산 용어, 알고리즘 이름, 자료구조 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다.
  - 프로그래머에게 익숙한 기술 개념은 아주 많다.
    - 기술 개념에는 기술 이름이 가장 적합한 선택이다.
    - 예를 들어 순차적으로 저장하여 순차적으로 처리하는 이름이 필요하다면 queue라는 단어를 활용하여 이름을 붙이는 것이 가장 적합한 선택이다.



## 기타

- 발음하기 쉬운 이름을 사용해라
  - 기본적으로 누구나 동일한 발음으로 발음할 수 있는 이름을 사용해야 한다.
  - 만일 같은 이름을 각기 다르게 발음한다면 협업이 힘들어진다.



- 검색하기 쉬운 이름을 사용하라
  - 문자 하나를 사용하는 이름 및 상수는 코드상에서 쉽게 눈에 띄지 않을 뿐더라 검색도 어렵다.
  - 따라서 지나치게 짧은 이름 보다는 긴 이름이 좋다.



- 자신의 기억력을 자랑하지 마라
  - 문자 하나만 사용하는 변수 이름은 문제가 있다.
    - 루프에서 반복 횟수를 세는 i, j, k는 괜찮다.
    - 그 외에는 대부분 적절치 못하다.
  - 독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수명은 적절하지 못하다.
    - 즉 자신이 기억하기 쉬운 코드가 아니라 다른 사람이 읽었을 때에도 기억하기 쉬운 이름을 사용해야 한다.
  - 또한 기발한 이름을 피하는 것이 좋다.
    - 기발한 이름은 자신과 유머 감각이 비슷한 사람만 알아들을 수 있다.



- 클래스명과 메서드명

  - 클래스명은 명사나 명사구가 적합하다.

    - 동사는 사용하지 않는다.

    - Customer, WikiPage, Account 등이 좋은 예이다.
    - Manager, Processor, Data, Info 등과 같은 단어는 피해야한다.

  - 메서드명은 동사나 동사구가 적합하다.

    - post_payment, delete_page, save 등이 좋은 예이다.
    - 접근자, 변경자, 조건자 등은 get, set, is 를 붙인다.



# 함수

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

## 작게 만들어라

- 함수를 만드는 첫째 규칙은 '작게!'다.
  - 함수를 만드는 두 번째 규칙은 '더 작게!'다.



- 조건문, 반복문 등에 들어가는 불록은 한 줄이어야 한다.
  - 과장된 표현일 수 있지만, 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.
  - 들여쓰기마다 함수를 새로생성하여 처리한다.
    - 이렇게 하면 바깥은 감싸는 함수(원래 함수)가 더 작아진다.
    - 또한 블록 안에서 호출하는 함수 이름을 적절히 짓는다면 코드를 이해하기도 쉬워진다.



## 한가지만 해라

- 함수가 한 가지만 하는지 판단하는 방법은  추상화 수준이 하나인지 확인하는 것이다.

  - 여기서 추상화란 실제 구현과 얼마나 멀리 떨어져 있는가를 말한다. 
    - 복잡한 실제 구현은 숨기고 목적을 분명히하여 핵심만 드러내는 것이다.
    - 실제 구현과 멀리 떨어져 있을 수록 추상화 수준이 높다고 볼 수있다.
  - 아래 코드는 추상화 수준이 매우 낮은 함수이다(보다 적절한 예시를 찾을 경우 변경).
  
  ```python
  def get_user_name_by_id(user_id):
      user_name_id_pair = []
      for user in users:
          user_name_id_pair.append({user['id']:user['name']})
      
      for id, name in user_name_id_pair.items():
          if id==user_id:
              return name 
  ```
  
  - 위 코드를 추상화하여 아래와 같이 변경할 수 있다.
    - 아래 코드도 `user_name_id_pair = make_name_id_pair()` 부분은 아직 추상화 수준이 높다고 볼 수 는 없다.
    - 추상화 수준이 중간인 `user_name_id_pair = make_name_id_pair()` 부분과 추상화 수준이 높은 `return find_name(user_name_id_pair)`가 혼재되어 있으므로 추상화 수준이 둘이다.
  
  ```python
  def get_user_name_by_id(user_id):
      user_name_id_pair = make_name_id_pair()
      return find_name(user_name_id_pair)
  ```
  
  - 클래스를 활용하면 추가적인 추상화가 가능하다.
    - 맨 처음 작성했던 코드보다 짧아졌을 뿐 아니라 읽기도 편한 코드가 됐다.
    - 함수 안에서 사용된 함수의 이름들을 통해 name과 id의 쌍을 만들고, 해당 쌍을 순회하면서 name을 찾아낸다는 것을 바로 알 수 있게 된다.
  
  ```python
  class User:
      def __init__(self):
          self.name_id_pair = []
  
      def get_user_name_by_id(user_id):
          make_name_id_pair()
          return find_name(self.name_id_pair)
  ```



- 함수가 한 가지만 하는지 확인하는 보다 쉬운 방법
  - 단순히 다른 표현이 아니라 의미 있는 다른 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 것이다.
  - 즉 똑같은 내용을 형식만 바꾸는 것이 아니라 함수로 따로 뺐을 때 의미 있는 이름을 붙이는 것이 가능하다면 그 함수는 여러 작업을 하고 있다는 것이다.
  - 또한 한 가지 작업만 하는 함수는 여러 섹션으로 나누기 어렵지만, 여러 가지 작업을 하는 함수는 자연스럽게 여러 섹션으로 나누는 것이 가능하다.



## 함수당 추상화 수준은 하나로

- 한 함수 내에  추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
  - 특정 표현이 근본 개념인지 아니면 세부사항인제 구분하기 어려운 탓이다.
  - 근본 개념과 세부 사항을 뒤섞기 시작하면, 깨어진 창문 처럼 사람들이 함수에 세부사항을 점점 더 추가한다.



- 내려가기 규칙
  - 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
  - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
    - 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.
    - 이것을 내려가기 규칙이라 부른다.





## Switch문

- switch문은 작게 만들기 어렵다.
  - case가 증가할 수록 길이는 점점 길어진다.
  - 또한 기본적으로 N가지 일을 처리하기 위한 문이기 때문에 한 가지 작업만 하기도 힘들다.
  - 불행하게도 switch문을 완전히 피할 방법은 없다.
    - 그러나 다형성을 활용하여 그나마 잘 사용하는 방법은 존재한다.



- 다형성을 활용하기

  - 원본
    - 직원 유형에 따라 봉급을 계산해서 반환하는 함수다.

  ```java
  public Money calculatePay(Employee e) throws InvalidEmployeeType{
      switch (e.type){
          case COMMISIONED:
              return calcualteCommissionedPay(e);
          case HOURLY:
              return calculateHourlyPay(e);
          case SALARIED:
              return calculateSalariedPay(e);
          default:
              throw new InvalidEmployeeType(e.type);
      }
  }
  ```

  - 위 함수에는 몇 가지 문제가 있다.
    - 첫째로 함수가 길다. 새로운 직원 유형을 추가할 때마다 switch문이 계속 길어진다.
    - 둘쨰로 한 가지 작업만을 수행하지 않는다.
    - 셋째로 SPR(Single Responseibility Principle)을 위반한다(코드를 변경할 이유가 여럿이기 때문이다).
    - 넷째로 OCP(Open Closed Principle)을 위반한다(새 직원 유형을 추가할 때마다 코드를 변경해야 하기 때문이다).
    - 마지막으로 `calculatePay` 함수와 같이 직원 유형에 기반하여 처리를 해줘야 하는 다른 함수들(`isPayDay`, `deliverPay`) 등이 있을 경우 모두 저런 switch문이 들어가야 한다.
  - 해결
    - switch문을 추상 팩토리에 숨긴다.
    - 팩토리는 switch문을 사용해 적절한 Employee 파생 클래스의 인스턴스를 생성한다.
    - `calculatePay` 등의 함수는 Employee 인터페이스를 거쳐 호출되는데, 다형성으로 인해 실제 파생 클래스의 함수가 실행된다.

  ```java
  public abstract class Employee {
      public abstract boolean isPayDay();
      public abstract Money calculatePay();
      public abstract void deliverPay(Money pay);
  }
  
  public interface EmployeeFactory {
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
  }
  
  public class EmployeeFactoryImpl implements EmployeeFactory {
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;{
          switch (e.type){
              case COMMISIONED:
                  return new CommisionedEmployee(r);
              case HOURLY:
                  return new HourlyEmployee(r);
              case SALARIED:
                  return SalariedEmployee(r);
              default:
                  throw new InvalidEmployeeType(r.type);
          }
      }
  }
  ```



## 서술적인 이름을 사용해라

- 이름이 길어도 괜찮다.
  - 길고 서술적인 이름이 짧고 어려운 이름보다 낫다.
  - 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
  - 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.



- 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.
  - 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.



- 이름을 붙일 때는 일관성이 있어야 한다.
  - 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.



## 함수 인수

- 함수에서 이상적인 인수 개수는 0개다.
  - 다음은 1개(단항)고, 다음은 2개(이항)다.
  - 3개는 가능한 피하는 편이 좋고, 4개 이상은 특별한 이유가 필요하다.
    - 4개 이상은 특별한 이유가 있어도 사용하면 안 된다.



- 인수가 적어야 하는 이유
  - 인수가 많을 수록 코드를 읽고 직관적으로 이해하기 어렵게 만든다.
  - 테스트도 어렵게 만든다.
    - 갖가지 인수를 가진 함수를 검증하는 테스트 케이스를 작성하는 것은 매우 귀찮은 일이다.
    - 반면에 아예 인수가 없는 함수를 검증하는 것은 매우 간단하다.
    - 인수가 3개를 넘어가면 인수마다 유효한 값으로 모든 조함을 구성해 테스트하기가 상당히 부담스러워진다.



- 많이 쓰는 단항 형식
  - 함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다.
    - 하나는 인수에 질문을 던지는 경우다(e.g.`file_exists("my/file/path")`).
    - 다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다.
  - 다소 드물게 사용하지만 아주 유용한 단항 함수 형식이 이벤트다.
    - 단, 이벤트 함수는 조심해서 사용해야 한다.
    - 이벤트라는 사실이 코드에 명확히 드러나야 한다.
  - 위의 경우들이 아니라면 단항 함수는 가급적 피한다.



- 플래그 인수
  - 플래그 인수는 추하다.
    - 함수에 부울 값을 넘기는 관례는 정말로 끔찍하다.
    - 플레그가 참이면 이걸 하고, 거짓이면 저걸 한다는, 즉 함수가 한 번에 여러 가지를 처리한다는 뜻이기 때문이다.
  - 따라서 플래그 인수를 받는 함수는 되도록 두 개의 함수로 나누는 것이 바람직하다.



- 이항 함수
  - 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
  - 이항 함수가 적절한 경우도 있다.
    - 예를 들어 직선 상의 좌표(x, y)는 일반적으로 인수 2개를 취해야 한다.
    - 위 처럼 한 값(좌표)를 표현하는 데 두 개의 요소가 필요할 경우 또는 두 개의 인수 사이에 자연스러운 순서가 존재할 경우(x좌표는 y좌표보다 항상 앞에 있다) 이항 함수를 쓰는 것이 적절하다.
  - 이항 이상의 함수의 가장 큰 문제 중 하나는 인수의 순서를 헷갈릴 수 있다는 것이다.
    - 예를 들어 x좌표와 y 좌표 사이에는 자연스러운 순서가 존재해서, 인수를 넘길 때 헷갈릴 일이 많지 않다.
    - 그러나 expected와 actual이라는 두 개의 인수를 넘길 때, 두 인수 사이에는 자연스러운 순서가 존재하지 않으므로(혹은 사람마다 자연스러운 순서가 다를 수 있으므로) 첫 번째 인수가 expected인지, 두 번째 인수가 actual인지 헷갈릴 수 있다.
  - 이항 함수가 무조건 나쁘다는 것은 아니다.
    - 프로그래밍을 하다보면 불가피한 경우도 있다.
    - 그러나, 위험이 따른다는 사실을 인지하고 가능하면 단항 함수로 바꾸도록 노력해야 한다.
    - 예를 들어 두 개의 인자를 받아야 하는 경우 하나의 인자를 클래스의 attribute로 만들어 하나만 받도록 할 수 있다.



- 삼항 함수
  - 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
  - 따라서 삼항 함수를 만들 때는 신중히 고려해야한다.



- 인수 객체

  - 인수가 2-3개 필요하다면 인수의 일부를 독자적인 클래스 변수로 선언할 수 있는지 살펴본다.
  - 예시

  ```python
  # 아래와 같이 3개의 인수를 넘겨야 하는 경우에
  def make_circle(x:int, y:int, redius:float):
      pass
  
  # x, y를 Point라는 클래스의 클래스 변수로 묶어 넘기는 것을 고려해볼법하다.
  def make_circle(center:Point, radius:float):
      pass
  ```



- 가변 인수

  - 때로는 인수 개수가 가변적인 함수도 필요하다.
    - 가변적인 인수 전부를 동등하게 취급하면 list 혹은 dict 형 인수 하나로 취급할 수 있다.
    - 즉 가변인수는 전부 묶어 하나의 인수로 취급한다.
  - 예시
    - 아래 두 함수는 각기 고정된 인수 name과 가변인수로 list와 dict를 받는 이항 함수이다. 

  ```python
  def insert_user(name, *args):
      pass
  
  def insert_user(name, **kwargs):
      pass
  ```



- 동사와 키워드
  - 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
  - 단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 한다.
    - 예를 들어 `write(name)`은 누구나 이름을 쓰는 역할을 한다는 것을 알 수 있다.
    - 좀 더 나은 이름은 `write_field(name)`으로, name이 필드명 중 하나라는 것이 보다 분명히 드러나기 때문이다.
  - 함수 이름에 인수의 순서를 기억할 수 있도록 키워드를 추가하는 것도 좋은 방법이다.
    - `assert_expected_equals_actual`이라는 함수 명은 expected가 먼저 오고, actual이 뒤에 온다는 사실을 함수 이름만 보고도 알 수 있게 해준다.



## 부수효과를 일으키지 마라

- 부수효과

  - 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하는 것이다.
  - 예시
    - 아래 함수가 일으키는 부수 효과는 `Session.initialze()`를 통해 세션을 초기화한다는 것이다.
    - `check_password`만 봐서는 이 함수가 세션을 초기화시킬수도 있다는 사실을 짐작도 할 수 없다.

  ```python
  def check_password(user_name, password):
      user=UserGateWay.find_by_name(user_name)
      if user != None:
          coded_phrase = user.get_phrase_encoded_by_password()
          phrase = crytographer.decrypt(codedPhrase, password)
          if "Valid Password"==phrase:
              Session.initialze()
              return True
      return False
  ```



- 위와 같은 부수 효과는 시간적인 결합을 초래한다.

  -  위 예시에서 `check_password`라는 함수는 세션을 초기화해도 될 때에만 호출이 가능해진다.
    - 즉 세션을 초기화해도 될 때라는 시간에 종속되어 버린다.
  - 이러한 시간적인 결합은 혼란을 일으킨다.

  - 만약 불가피하다면 반드시 함수명에 부수효과를 명시해야 한다(`check_password_and_initalize_session`)
    - 물론 이 경우에도 함수는 한 가지만 해야 한다는 원칙을 위반하기는 하지만 명시하고 위반하는 것이 낫다.



## 명령과 조회를 분리해라

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.
  - 즉 객체 상태를 변경하거나, 객체 정보를 반환하거나 둘 중 하나만 해야 한다.
  - 둘 다 하면 혼란을 초래한다.



- 예시

  - `set` 함수는 이름이 attr인 attribute를 찾아, 그 값을 value로 설정한 후 성공하면 true, 실패하면 false를 반환한다.
  - 수행과 응답을 둘 다 하므로 `if set(attr, value)`와 같은 괴상한 코드가 나오게 되는 것이다.

  ```python
  def set(attr, value):
      pass
  
  if set(attr, value):
      pass
  ```



- 올바른 코드

  - set이라는 혼라스러운 함수를 2개의 함수로 분리한다.

  ```python
  if attr_exists("username"):
      set_attr("username", "theo")





## Try/Catch

- try/catch 블록은 코드 구조에 혼란을 일으키며 정상 동작과 오류 처리 동작을 뒤섞는다.

  - 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.
  - 예시
    - 아래 코드에서 실제 삭제는 `delete_page_and_all_references` 함수가 담당하지만 `delete_page_and_all_references` 함수 내부에 try/catch문을 넣을 경우 정상 동작과 오류 처리 동작이 뒤섞이게 된다.
    - 따라서 예외 처리를 위한 `delete`함수를 따로 생성하고 호출은 `delete`를 하되, 실제 삭제는 `delete_page_and_all_references`에서 하도록 한다.

  ```python
  def delete_page_and_all_references(page):
      delete_page(page)
      registry.delete_reference(page.name)
  
  
  def delete(page):
      try:
          delete_page_and_all_references(page)
      except Exception as e:
          print(e)
  ```



- 오류 처리도 하나의 작업이다.
  - 오류를 처리하는 함수는 오류만 처리해야 한다.
    - 함수는 한 가지 작업만 해야 한다.
    - 오류처리도 한 가지 작업이다.
  - 예외처리를 하는 함수는 try로 시작해 catch, finally로 끝나야 한다는 말이다.



## 구조적 프로그래밍

- 구조적 프로그래밍
  - 다익스트라가 go to문의 해로움을 주장하면서 대두된 방법론이다.
  - 다익스트라는 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다고 말했다.
    - 즉 함수의 return문은 하나여야 한다.
    - 반복문 안에서 break이나 continue를 사용해선 안된다.
    - go to는 절대로 안된다.



- 구조적 프로그래밍은 함수가 작을 경우 별 이익을 제공하지 못한다.
  - 함수가 아주 클 때에만 상당한 이익을 제공한다.
  - 따라서 함수를 작게 만든다면 간혹 return, continue, break 등을 여러 번 사용해도 괜찮다.
  - 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.
  - 다만 go to문은 큰 함수에서만 의미가 있으므로, 작은 함수에서는 피해야 한다.



## 함수를 어떻게 짜는가

- 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다.
  - 먼저 생각을 기록한 후 읽기 좋게 다듬는다.
  - 초안은 대개 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다.



- 함수를 짤 때도 마찬가지다.

  - 처음에는 길고 복잡하며, 들여쓰기 단계도 많고, 중복된 루프도 많으며, 인수도 아주 많다. 이름은 즉흥적이고 코드는 중복된다.

  - 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트도 만든다.
  - 그런 다음 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
  - 이 와중에도 코드는 항상 단위 테스트를 통과한다.
  - 최종적으로는 이 장에서 설명한 규칙을 따르는 함수가 얻어진다.
