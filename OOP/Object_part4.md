# 메시지와 인터페이스

- 객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고 받는 메시지다.
  - 클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환해야한다.
  - 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다.



- 협력과 메시지

  - 클라이언트-서버 모델
    - 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.
    - 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.
    - 객체는 자신의 희망을 메시지라는 형태로 전송하고 메시지를 수신한 객체는 요청을 적절히 처리한 후 응답한다.
    - 두 객체 사이의 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버 모델이다.
    - 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라 부르며, 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.
    - 협력의 관점에서 객체는 객체가 수신하는 메시지의 집합과 외부의 객체에게 전송하는 메시지의 집합이라는 두 종류의 메시지 집합으로 구성된다.
    - 대부분의 사람들은 객체가 수신하는 메시지의 집합에만 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.
  - 메시지와 메시지 전송
    - 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송 또는 메시지 패싱이라 부른다.
    - 이 때 메시지를 전송하는 객체를 메시지 전송자라고 부르고, 메시지를 수신하는 객체를 메시지 수신자라고 부른다.
    - 메시지는 오퍼레이션명과 인자로 구성되며 메시지 전송은 여기에 미시지 수신자를 추가한 것이다.
    - 예를 들어 `is_satisfied_by(screening)`은 오퍼레이션명(`is_satisfied_by`)과 인자(`screening`)으로 구성된 메시지이며, `condition.is_satisfied_by(screening)`는 메시지 수신자(`condition`)가 추가된 메시지 전송이다.
  - 메시지와 메서드
    - 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.
    - 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다.
    - 기술적인 관점에서 객체 사이의 메시지 전송은 전통적인 방식의 함수 호출이나 프로시저 호출과는 다르다.
    - 전통적인 방식의 개발자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 구문을 작성한다.
    - 즉 코드의 의미가 컴파일 시점과 실행 시점에 동일하다.
    - 반면에 객체는 메시지와 메서드라는 서로 다른 개념을 실행 시점에 연결해야 하기에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
    - 메시지와 메서드의 구분은 메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다.
    - 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 되며 수신자에 대해 몰라도 된다.
    - 메시지 수신자 역시 전송자에 대해 알 필요가 없으며, 단지 메시지가 도착했다는 사실만 알면 된다.
    - 메시지 수신자는 메시지를 처리하기 위해 필요한 메서드를 결정할 수 있는 자율권을 누린다.
    - 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.
  - 퍼블릭 인터페이스와 오퍼레이션
    - 객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다.
    - 외부에서 볼 때 객체의 안쪽은 미지의 영역이며, 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.
    - 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 부른다.
    - 프로그래밍 언어적 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라 부른다.
    - 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화이며, 흔히 오퍼레이션이라 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.
    - 그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.
    - 예를 들어 `DiscountDondition` interface에 정의 된 `is_satisfied_by`는 오퍼레이션에 해당하고, `SequenceCondition`과 `PeriodCondition`의 `is_satisfied_by`는 실제 구현을 포함하기에 메서드라고 부른다.
    - 객체가 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고, 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.
    - 따라서 퍼블릭 인터페이스와 메시지의 관점에서 보면 '메서드 호출' 보다는 '오퍼레이션 호출'이라는 용어를 사용하는 것이 더 적절하다.

  - 시그니처
    - 오퍼레이션(또는 메서드)의 이름과 파라미터 항목을 합쳐서 시그니처라고 부른다(일부 언어에서는 반환 타입까지 시그니처에 포함되기도 한다).
    - 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다.
    - 메서드는 시그니처에 구현을 더한 것이다.
    - 일반적으로 메시지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행된다.
    - 하나의 오퍼레이션에 오직 하나의 메서드만 존재하는 경우 굳이 둘을 구분할 필요가 없다.
    - 그러나 다형성을 위해서는 하나의 오퍼레이션에 대해 다양한 메서드를 구현해야한다.
    - 따라서 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.



- 인터페이스와 설계 품질
  - 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.
    - 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.
    - 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.
  - 위 조건을 만족시키는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다.
    - 책임 주도 설계는 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지하여 인터페이스는 최소한의 오퍼레이션만 포함하게 된다.
    - 또한 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있게 하여 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다.
  - 퍼블릭 인터페이스의 품질에 영향을 미치는 대표적인 원칙과 기법들은 아래와 같은 것들이 있다.
    - 디미터 법칙
    - 묻지 말고 시켜라
    - 의도를 드러내는 인터페이스
    - 명령-쿼리 분리



- 디미터 법칙(Law of Demeter)

  - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 법칙이다.
    - 낯선 자에게 말하지 말라
    - 오직 인접한 이웃하고만 말하라.
  - 디미터 법칙을 따르게 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍해야 한다.
    - 모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수 있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다(이때 M에 의해 생성된 객체나 M이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M의 인자로 간주한다).
    - M의 인자로 전달된 클래스(C 자체를 포함) 또는 C의 인스턴스 변수의 클래스
  - 결국 쉽게 말해 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야 한다.
    - this 객체
    - 메서드의 매개 변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체
  - 부끄럼타는 코드(shy code)
    - 디미터 법칙을 따르면 부끄럼타는 코드를 작성할 수 있다.
    - 부끄럼 타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 의미한다.
    - 디미터 법칙을 따르는 코드는 메시지 수진자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.
    - 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.
  - 디미터 법칙과 캡슐화
    - 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다.
    - 디미터 법칙이 가치 있는 이유는 캡슐화를 위해 따라야 하는 구체적인 지침을 제공하기 때문이다.
    - 캡슐화가 클래스 내부 구현을 감춰야한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
  - 기차 충돌(train wreck)
    - 아래 코드는 디미터 법칙을 위반하는 코드의 전형적인 모습을 표현한 것이다.
    - 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다.
    - 이러한 코드를 기차 충돌이라 부르는데 여러 대의 기차가 한 줄로 늘어서 충돌한 것 처럼 보이기 때문이다.
    - 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.
    - 따라서 수신자의 캡슐화는 무너지고, 전송자가 수신자의 내부 구현에 강하게 결합된다.

  ```python
  screening.get_movie().caclulate_fee()
  ```

  - 무비판적으로 디미터 법칙을 수용하면 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다.



- 묻지 말고 시켜라(Tell, Don't Ask)

  - 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.
    - 묻지 말고 시켜라는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.
    - 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.
    - 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.

  - 묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.
    - 객체지향의 기본은 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.
    - 묻지 말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.
    - 이 원칙을 따를 경우 자연스럽게 정보 전문가에게 책임을 할당하게 되고 응집도 높은 클래스를 얻을 확률이 높아진다.
  - 묻지 말고 시켜라 원칙과 디미터 법칙은 훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다.
    - 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해야한다.
    - 내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재한다면 객체가 책임져야 하는 행동이 객체 외부로 누수된 것이다.
    - 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하여 인터페이스를 향상시켜야 한다.
    - 하지만 단순하게 객체에게 묻지 않고 시킨다고 해서 모든 문제가 해결되는 것은 아니다.
    - 여기에 더해서 객체가 어떻게 작업을 수행하는지를 노출해서는 안 된다.



- 의도를 드러내는 인터페이스(Intention Revealing Interface)

  - 메서드의 이름을 짓는 방법
    - 켄트 벡은 메서드를 명명하는 두 가지 방법을 설명했다.
    - 첫 번째 방법은 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓는 것이다.
    - 두 번째 방법은 메서드가 무엇을 수행하는지를 나타내도록 이름을 짓는 것이다.
    - 결론부터 말하면, 두 방법 중 후자가 더 나은 방법이다.
    - 전자의 경우 메서드의 내부 구현을 설명하는 이름으로, 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민하게 한다.
    - 반면에 후자의 경우 객체가 협력 안에서 수행하는 책임에 관해 고민하도록 해준다.
  - 메서드가 작업을 어떻게 수행하는지 나타내도록 명명하기
    - 아래와 같이 메서드가 작업을 어떻게 수행하는지 나타내도록 명명하는 것은 좋지 않은 방법이다.
    - 첫 번째 이유는 메서드에 대해 제대로 커뮤니케이션 하지 못한다는 것이다.
    - 클라이언트의 관점에서는 아래 두 메서드 모두 할인 조건을 판단하는 동일한 작업을 수행함에도, 이름이 다르기에 두 메서드의 내부 구현을 정확히 모른다면 두 메서드가 동일한 작업을 수행한다는 사실을 알기 힘들다.
    - 두 번째 이유는 메서드 수준에서 캡슐화를 위반한다는 것이다.
    - 이 메서드들은 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다.
    - 즉, `PeriodCondtion`를 사용하는 코드를 `SequenceCondition`를 사용하는 코드로 변경하려면 단순히 참조하는 객체를 변경하는 것뿐만 아니라 호출하는 메서드를 변경해야한다.
    - 만약 할인 여부를 판단하는 방법이 변경된다면 메서드의 이름 역시 변경해야 하며, 이는 메시지를 전송하는 클라이언트의 코드도 함께 변경해야 한다는 것을 의미한다.

  ```python
  class PeriodCondtion:
      def is_satisfied_by_period(self, screening: Screening):
          ...
          
          
  class SequenceCondition:
      def is_satisfied_by_sequence(self, screening: Screening):
          ...
  ```

  - 메서드가 무엇을 하는지 나타내도록 명명하기
    - 메서드의 구현이 한 가지인 경우에는 무엇을 하는지를 드러내는 이름을 짓는 것이 어려울 수도 있다.
    - 그러나 무엇을 하는지 드러내는 이름은 코드를 이해하기 쉽게 만들뿐만 아니라 유연한 코드를 만들게 해준다.
    - 이 방식은 객체가 협력 안에서 수행하는 책임에 관해 고민하도록 한다.
    - 이를 통해 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.
    - 메서드가 무엇읗 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커 진다.
    - 그 결과 다양한 타입의 객체가 참여할 수 있는 유연한 협력을 얻게 된다.

  ```python
  class DiscountCondition(ABC):
      @abstractmethod
      def is_satisfied_by(self, screening: Screening):
          ... 
  
  
  class PeriodCondtion(DiscountCondition):
      def is_satisfied_by(self, screening: Screening):
          ...
          
          
  class SequenceCondition(DiscountCondition):
      def is_satisfied_by(self, screening: Screening):
          ...
  ```

  - 의도를 드러내는 선택자(Intention Revealing Selector)
    - 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 의도를 드러내는 선택자라고 부른다.
    - 켄트 벡은 메서드에 의도를 드러낼 수 있는 이름을 붙이기 위해 다음과 같이 생각할 것을 조언한다,
    - 매우 다른 두 번째 구현을 상상하고, 해당 메서드에 동일한 메서드를 붙인다고 상상한다.
    - 이렇게 하면 가능한 한 가장 추상적인 이름을 메서드에 붙이게 될 것이다.
  - 의도를 드러내는 인터페이스는 의도를 드러내는 선택자를 인터페이스 레벨로 확장한 것이다.
    - 에릭 에반스가 켄트 벡의 의도를 드러내는 선택자를 확장하여 제시했다.
    - 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다.
    - 타입 이름, 메서드 이름, 인자 이름이 모두 결합되어 의도를 드러내는 인터페이스를 형성한다.
    - 퍼블릭 인터페이스에는 관계와 규칙을 실행하는 방법이 아닌 이벤트와 규칙 그 자체만 명시한다.



- 함께 모으기

  - 디미터 법칙을 위반하는 티켓 판매 도메인
    - 디미터 법칙에 따르면 인자로 전달된 `audience`와 인스턴스 변수인 `ticket_seller`에게 메시지를 전송하는 것은 문제가 없다.
    - 문제는 `Theater`가 `audience`와 `ticket_seller` 내부에 포함된 객체에도 직접 접근하여 디미터 법칙을 위반한다는 것이다.

  ```python
  class Theater:
      def __init__(self, ticket_seller: TicketSeller):
          self.ticket_seller = ticket_seller
      
      def enter(self, audience: Audience):
          if audience.get_bag().has_invitation():
              ticket = self.ticket_seller.get_ticket_office().get_ticket()
              audience.get_bag().set_ticket(ticket)
          else:
              ticket = self.ticket_seller.get_ticket_office().get_ticket()
              audience.get_bag().minus_amount(ticket.get_fee())
              self.ticket_seller.get_ticket_office().plus_amount(ticket.get_fee())
              audience.get_bag().set_ticket(ticket)
  ```

  - 근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현 분리 원칙을 위반한다.
    -  `Audience`가 `Bag`을 포함한다는 사실은 `Audience`의 내부 구현에 속하며 `Audience`는 자신의 내부 구현을 자유롭게 변경할 수 있어야 한다.
    - 그러나 퍼블릭 인터페이스에 `get_bag`을 포함시키는 순간 객체의 구현이 퍼블릭 인터페이스를 통해 외부로 새어나가게 된다.
    - 따라서 디미터 법칙을 위반하는 것은 클라이언트에게 구현을 노출한다는 것을 의미하며, 그 결과 작은 변경에도 쉽게 무너지는 불안정한 코드를 얻게 된다.
  - 디미터 법칙을 위반한 코드는 사용하기도 어렵다.
    - 클라이언트 객체의 개발자는 `Audience`의 퍼블릭 인터페이스뿐만 아니라 `Audience`의 내부 구현까지 알고 있어야 하기 때문이다.
    - `TicketSeller`의 경우 그 정도가 더 심한데, `Theater`는 `TicketSeller`가 `get_ticket_office` 메시지를 수신할 수 있다는 사실뿐만 아니라 내부에 `TicketOffice`를 포함하고 있다는 사실도 알아야 한다. 또한 `Theater`는 반환된 `TicketOffice`가 `get_ticket` 메시지를 수신할 수 있으며, 이 메서드가 반환하는 `Ticket`인스턴스가 `get_fee` 메시지를 이해할 수 있다는 사실도 알고 있어야한다.
  - `Theater`에 묻지 말고 시켜라 적용하기
    - 디미터 법칙을 위반한 코드를 수정하는 일반적인 방법은 내부 구조를 묻는 대신 `Audience`와 `TicketSeller`가 직접 자신의 책임을 수행하도록 시키는 것이다.
    - 즉, `Audience`와 `TicketSeller`는 묻지 말고 시켜라 스타일을 따르는 퍼블릭 인터페이스를 가져야 한다.

  ```python
  class TicketSeller:
      def __init__(self, ticket_office: TicketOffice):
          self.ticket_office = ticket_office
      
      def get_ticket_office(self) -> TicketOffice:
          return self.ticket_office
          
      def set_ticket(self, audience: Audience):
          if audience.get_bag().has_invitation():
              ticket = self.ticket_office.get_ticket()
              audience.get_bag().set_ticket(ticket)
          else:
              ticket = self.ticket_office.get_ticket()
              audience.get_bag().minus_amount(ticket.get_fee())
              self.ticket_office.plus_amount(ticket.get_fee())
              audience.get_bag().set_ticket(ticket)
              
              
  class Theater:
      def __init__(self, ticket_seller: TicketSeller):
          self.ticket_seller = ticket_seller
      
      def enter(self, audience: Audience):
          self.ticket_seller.set_ticket(audience)
  ```

  - `TicketSeller`에 묻지 말고 시켜라 적용하기
    - 마찬가지로 `Audience`가 `Ticket`을 보유하도록 만들어 `TicketSeller`가 묻지 않고 시킬 수 있도록 한다.
  
  ```python
  class Audience:
      def __init__(self, bag: Bag=None):
          self.bag = bag
      
      def get_bag(self) -> Bag:
          return self.bag
      
      def set_ticket(self, ticket: Ticket):
          if self.bag.has_invitation():
              self.bag.set_ticket(ticket)
              return 0
          else:
              self.bag.set_ticket(ticket)
              self.bag.minus_amount(ticket.get_fee())
              return ticket.get_fee()
  
  
  class TicketSeller:
      def __init__(self, ticket_office: TicketOffice):
          self.ticket_office = ticket_office
      
      def get_ticket_office(self) -> TicketOffice:
          return self.ticket_office
          
      def set_ticket(self, audience: Audience):
          self.ticket_office.plus_amount(audience.set_ticket(self.ticket_office.get_ticket()))
  ```
  
  - `Audience`에 묻지 말고 시켜라 적용하기
    - `Audience`는 `Bag`에게 원하는 일을 시키기 전에 `has_invitation` 메서드를 이용하여 초대권이 있는지를 확인하므로 디미터 법칙을 위반한다.
  
  ```python
  class Bag:
      def __init__(self, amount=None, invitation: Invitation=None):
          if not amount and not invitation:
              raise Exception()
          
          self.amount = amount
          self.invitation = invitation
          self.ticket: Ticket = None
          
      def has_invitation(self):
          return self.invitation is not None
      
      def set_ticket(self, ticket: Ticket):
          if self.has_invitation():
              self.ticket = ticket
              return 0
          else:
              self.ticket = ticket
              self.minus_amount(ticket.get_fee())
              return ticket.get_fee()
          
      def minus_amount(self, amount: int):
          self.amount -= amount
          
          
  class Audience:
      def __init__(self, bag: Bag=None):
          self.bag = bag
      
      def set_ticket(self, ticket: Ticket):
          return self.bag.set_ticket(ticket)
  ```
  
  - 디미터 법칙과 묻지 말고 시켜라 원칙에 따라 리팩터링한 후에 `Audience`는 자신의 상태를 스스로 관리하고 결정하는 자율적인 객체가 됐다.
    - 두 원칙을 따르면 자연스럽게 자율적인 객체로 구성된 유연한 협력을 얻게 된다.
    - 구현이 객체의 퍼블릭 인터페이스에 노출되지 않기 때문에 객체 사이의 결합도는 낮아진다.
    - 책임이 잘못된 곳에 할당될 가능성이 낮아지기 때문에 객체의 응집도 역시 높아진다.



- 인터페이스에 의도를 드러내자

  - 현재의 인터페이스는 클라이언트의 의도를 명확하게 드러내지 못 한다.
    - `TicketSeller`의 `set_ticket` 메서드는 클라이언트의 의도를 전달하지 못한다.
    - 이는 `Audience`의 `set_ticket`과 `Bag`의 `set_ticket` 역시 마찬가지다.

  - 따라서 의도를 보다 분명히 드러낼 수 있도록 수정한다.

  ```python
  class TicketSeller:
      def sell_to(self, audience: Audience):
          ...
          
          
  class Audience:
      def buy(self, ticket: Ticket):
          ...
          
          
  class Bag:
      def hold(self, ticket: Ticket):
          ...
  ```

  - 오퍼레이션의 이름은 협력이라는 문맥을 반영해야한다.
    - 오퍼레이션은 클라이언트가 객체에게 무엇을 원하는지를 표현해야한다.
    - 다시 말해 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야한다.



- 원칙의 함정

  - 위에서 살펴본 것들은 절대적인 법칙이 아닌 원칙이다.

    - 설계는 트레이드오프의 산물이므로 원칙을 맹목적으로 추종해선 안 된다.
    - 원칙들이 서로 충돌하는 경우에도 원칙에 정당성을 부여하고 억지로 끼워 맞춰서는 안 된다.

    - 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시해야한다.

  - 디미터 법칙은 하나의 도트(`.`)를 강제하는 규칙이 아니다.
    - 디미터 법칙은 "하나의 도트만을 사용하라"는 말로 요약되기도 한다.
    - 만약 하나의 도트만을 사용해야 한다는 디미터 원칙을 곧이 곧대로 받아들이면 아래와 같은 코드는 디미터 원치글 위반하는 코드가 될 것이다. 
    - `IntStream.of(1,2,3).filter(x -> x >2).distinct().count();`
    - 그러나 이는 디미터 법칙을 잘못 이해한 것으로, 위 코드에서 `of`, `filter`, `distinct` 메서드는 모두 `IntStream`이라는 동일한 클래스의 인스턴스를 반환한다.
    - 즉 이들은 `IntStream`의 인스턴스를 또 다른 `IntStream` 인스턴스로 변환다.
    - 따라서 이 코드는 디미터 법칙을 위반하지 않는다.
    - 디미터 법칙은 결합도와 관련된 것이며, 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.
    - 이런 종류의 코드를 마주쳤을 때 과연 여러 개의 토드를 사용한 코드가 객체의 내부 구조를 노출하는가를 먼저 생각해 봐야 한다.
  - 맹목적인 위임 메서드의 추가는 응집도를 낮출 수 있다.
    - 수정 전의 `Theater.enter`를 보면 `Audience` 내부에 포함된 `Bag`에 대해 질문한 후 반환된 결과를 이용해 `Bag`의 상태를 변경한다.
    - 이 코드는 분명히 `Audience`의 캡슐화를 위반하기 때문에 `Theater`는 `Audience`의 내부 구조에 강하게 결합된다.
    - 이 문제를 해결할 수 있는 방법은 질문하고, 판단하고, 상태를 변경하는 모든 코드를 `Audience` 내부로 옮기는 것이다.
    - 즉 `Audience`에게 위임 메서드를 추가하는 것이다.
    - 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 응집도를 높일 수 잇는 효과적인 방법이다.
    - 그러나 묻지 말고 시켜라와 디미터의 법칙을 준수하는 것이 항상 긍정적인 결과를 가져오는 것은 아니다.
    - 모든 상황에 맹목적으로 위임 메서드를 추가할 경우 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 되어 상관 없는 책임들을 한꺼번에 떠안게 되고, 결과적으로 응집도가 낮아진다.

  - 때로는 묻는 것이 더 좋은 방법일 수 있다.
    - 예를 들어 아래 코드에서 `is_satisfied_by` 메서드는 `Screening`에게 질의한 상영 시작 시간을 이용해 할인 여부를 결정한다.
    - 이 코드는 얼핏 보기에 `Screening`의 내부 상태를 가져와서 사용하기 때문에 캡슐화를 위반한 것으로 보일 수 있다.
    - 따라서 할인 여부를 판단하는 로직을 `Screening`의 `is_discountable` 메서드로 옮기고 `PeriodCondition`이 이 메서드를 호출하도록 변경하여 묻디 말고 시켜라 스타일을 준수하는 퍼블릭 인터페이스를 얻을 수 있다고 생각할 것이다.
    - 그러나 이 경우 `Screening`이 할인 조건을 판단하는 책임을 떠안게 되며, 이는 `Screening`의 본질적인 책임이 아니다.
    - 따라서 `Screening`의 응집도가 낮아지게 된다.
    - 또한 `PeriodCondition`의 인스턴스 변수를 인자로 받기 때문에 `PeriodCondition`의 인스턴스 변수 목록이 변경될 경우에도 영향을 받기 되어 결합도도 높아진다.
    - 따라서 묻지 말고 시켜라 스타일을 준수하여 `Screening`의 캡슐화를 높이는 것 보다 전체적인 관점에서 응집도와 결합도를 높이는 것이 더 좋은 방법이다.

  ```python
  class PeriodCondition(DiscountCondition):
      def is_satisfied_by(self, screening: Screening):
          return screening._when_screened.weekday() == self._day_of_week and \
                 self._start_time <= screening._when_screened() and \
                 self._end_time >= screening._when_screened()
      
      
  # 아래와 같이 변경한다.
  class Screening:
      def is_satisfied_by(self, day_of_week, start_time, end_time):
          return self._when_screened.weekday() == day_of_week and \
                 start_time <= self._when_screened() and \
                 end_time >= self._when_screened()
  ```



- 명령-쿼리 분리 원칙(Command-Query Separation, CQS)
  - 루틴
    - 어떤 절차를 묶어 호출하도록 이름을 부여한 기능 모듈을 루틴이라 부른다.
    - 루틴은 다시 프로시저(procedure)와 함수(function)로 구분할 수 있다.
    - 프로시저와 함수를 같은 의미로 혼용하는 경우가 많지만 사실 둘은 다른 개념이다.
    - 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
    - 함수는 부수효과를 발생시킬 수 없지만 값을 반환할 수 있다.
  - 명령과 쿼리
    - 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.
    - 객체의 상태를 수정하는 오퍼레이션을 명령이라 부르고, 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.
    - 개념적으로 명령은 프로시저와 동일하고 쿼리는 함수와 동일하다.
  - 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.
    - 명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.
    - 명령과 쿼리를 분리하기 위해서는 아래의 두 규칙을 준수해야 한다.
    - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
    - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
  - 명령과 쿼리를 분리해야 하는 이유
    - 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기 어렵다.
    - 겉보기에는 쿼리처럼 보이지만 부수효과를 가지는 메서드는 이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다.
    - 반면에 둘을 분리할 경우 쿼리는 객체의 상태를 변경하지 않기 때문에 결과를 예측하기 쉬워진다.
    - 또한 쿼리들의 순서를 자유롭게 변경할 수도 있다.
  - 버트란드 마이어의 기계 메타포
    - 객체는 블랙박스이며 객체의 인터페이스는 객체의 관찰 가능한 상태를 보기 위한 일련의 디스플레이와 객체의 상태를 변경하기 위해 누를 수 있는 버튼의 집합이라고 가정한다.
    - 인터페이스는 두 가지 형태의 버튼으로 구성된다.
    - 둥근 버튼은 기계의 현재 상태를 출력하지만 상태는 변경하지 않는다.
    - 네모 버튼은 기계의 상태는 변경하지만 변겨오딘 상태에 관한 정보는 제공하지 않는다.
    - 즉 둥근 버튼은 쿼리이고 네모 버튼은 명령이다.



- 명령-쿼리 분리와 참조 투명성(referential transparency)

  - 컴퓨터와 수학 세계를 나누는 가장 큰 특징은 부수효과(side effect)의 존재 유무다.
    - 프로그램에서 부수 효과를 발생시키는 두 가지 대표적인 문법은 대입문과 함수(정확히는 프로시저)다.
    - 수학의 경우 x의 값을 초기화한 후에는 값을 변경하는 것이 불가능하지만 프로그램에서는 대입문을 이용해 다른 값으로 변경하는 것이 가능하다.
    - 수학에서 함수는 입력이 동일하면 결과 역시 항상 동일하지만, 프로그래밍에서는 함수 내부에 부수효과가 포함되어 있을 경우 입력값이 동일하더라도 그 결과값이 매번 달라질 수 있다.
  - 참조 투명성
    - 수학은 참조 투명성을 엄격하게 준수하는 체계다.
    - 어떤 함수 $f(n)$이 존재할 때 $n$의 값으로 1을 대입하면 그 결과가 3이라고 가정했을 때 $f(1)$을 3으로 바꿔도 식의 결과는 바뀌지 않는다.
    - 예를 들어 $f(1)+1=4$에서 $f(1)$을 3으로 바꿔도 결과는 달라지지 않는다($3+1=4$).
    - 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 달라지지 않는 특성을 의미한다.
    - 예시에서 $f(1)$은 표현식이고 $f(1)$의 값은 3이다.
    - $f(1)$를 $f(1)$의 값인 3으로 바꾸더라도 결과는 달라지지 않으므로 참조 투명성을 만족한다.
  - 참조 투명성은 식의 순서를 변경하더라도 결과가 달라지지 않는다는 것이다.
    - 예를 들어 $f(1)+1$과 $1+f(1)$의 결과는 동일하다.
    - 식의 순서를 변경할 수 있는 이유는 식들이 모두 참조 투명성을 만족하기 때문이다.
  - 불변성(immutability)
    - 수학의 함수는 동일한 입력에 대해 항상 동일한 값을 반환하기 때문에 수학의 함수는 참조 투명성을 만족시키는 이상적인 예다.
    - 참조 투명성은 식을 값으로 대체하는 것을 허용하기에 참조 투명성은 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산할 수 있게 해준다.
    - $f(1)$은 어떤 경우에라도 3이며, 이처럼 어떤 값이 변하지 않는 성질을 불변성이라고 부른다.
    - 어떤 값이 불변한다는 말은 부수 효과가 없다는 말과 동일하다.

  - 부수효과, 참조 투명성, 불변성 사이의 관계
    - 수학에서 함수는 어떤 값도 변경하지 않기 때문에 부수효과가 존재하지 않는다.
    - 수학에서 함수는 부수효과가 없으므로 불변성을 가진다.
    - 수학에서 함수는 불변성을 가지므로 모든 로직이 참조 투명성을 만족시킨다.
    - 결국 불변성은 부수효과의 발생을 방지하고 참조 투명성을 만족시킨다.

  - 참조 투명성을 만족하는 식의 장점
    - 모든 함수를 이미 알고 있는 하나의 결과값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
    - 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
  - 객체지향 패러다임은 객체의 상태 변경이라는 부수효과를 기반으로 한다.
    - 따라서 객체지향에서 참조 투명성은 예외에 가깝다.
    - 그러나 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적이나마 누릴 수 있게 된다.
  - 함수형 프로그래밍
    - 명령형 프로그래밍은 부수효과를 기반으로 한다.
    - 상태를 변경시키는 연산들을 적절한 순서대로 나열함으로써 프로그램을 작성한다.
    - 대부분의 객체지향 프로그래밍 언어들은 메시지에 의한 객체의 상태 변경에 집중하기 때문에 명령형 프로그래밍 언어로 분류된다.
    - 반면에 함수형 프로그래밍은 부수효과가 존재하지 않는 수학적인 함수에 기반한다.
    - 따라서 함수형 프로그래밍에서는 참조 투명성의 장점을 극대화할 수 있으며 명령형 프로그래밍에 비해 실행 결과를 이해하고 예측하기가 더 쉽다.
    - 최근에는 다양한 객체지향 언어들이 함수형 프로그래밍 패러다임을 접목시키고 있다.



- 책임에 초점을 맞춰야한다.

  - 객체가 수행할 책임에 초점을 맞추면 위에서 살펴본 것들을 자연스럽게 지킬 수 있다.
    - 메시지를 먼저 선택한 후에 메시지를 처리할 객체를 선택해야한다.
    - 객체 구현 이전에 객체 사이의 협력에 초점을 맞춰 협력 방식을 단순하고 유연하게 만들어야 한다.
    - 정말 중요한 것은 협력에 적합한 객체가 아니라 협력에 적합한 메시지다.
  - 디미터 법칙과 책임
    - 협력이라는 맥락 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 결합도를 낮출 수 있다.
    - 수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체 내부의 구조에 대해 고민할 필요가 없어진다.
    - 따라서 디미터 법칙을 위반할 위험을 최소화할 수 있다.
  - 묻지 말고 시켜라 스타일과 책임
    - 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.
    - 클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.
  - 의도를 드러내는 인터페이스와 책임
    - 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트 관점에서 메시지의 이름을 정한다는 것이다.
    - 당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명히 드러날 수밖에 없다.

  - 명령-쿼리 분리 원칙과 책임
    - 객체의 협력을 고민할 경우 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 대해 고민하게 된다.
    - 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.





# 객체 분해

- 분해
  - 추상화
    - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 의미한다.
    - 본질적인 정보만 남기고 불필요한 세부 사항을 걸러냄으로써 문제를 단순화할 수 있게 해준다.
  - 분해는 큰 문제를 해결 가능한 작은 문제로 나누는 추상화 기법을 의미한다.
  - 객체지향 패러다임에서의 분해
    - 객체지향 패러다임은 역할과 책임을 수행하는 자율적인 객체들의 공동체를 구축하는 것이다.
    - 여기서 역할과 책임을 수행하는 객체가 객체지향 패러다임이 이용하는 추상화다.
    - 기능을 협력하는 공동체를 구성하도록 객체들로 나누는 과정이 객체지향 패러다임에서의 분해를 의미한다.



- 프로시저 추상화와 데이터 분해

  - 프로그래밍 언어와 추상화
    - 프로그래밍 언어의 발전은 좀 더 효과적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력으로 이루어졌다.
    - 어셈블리어는 숫자로 된 기계어에 인간이 이해할 수 있는 상징을 부여하려는 노력의 결과였으며, 고수준 언어는 기계적인 사고를 강요하는 낮은 수준의 명령어들을 탈피하고자 한 시도의 결과였다.
    - 추상화의 발전은 다양한 프로그래밍 패러다임의 탄생으로 이어졌다.
    - 프로그래밍 패러다임은 프로그래밍을 구성하기 위해 사용하는 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해하는 방법의 두 가지 요소로 결정된다.
    - 결국 프로그래밍 패러다임은 적잘한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌지를 결정하는 원칙과 방법의 집합이다.
    - 따라서 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.
  - 프로시저 추상화와 데이터 추상화
    - 현대적인 프로그래밍 언어를 특징 짓는 두 가지 중요한 메커니즘이다.
    - 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.
    - 프로시저 추상화는 소프트웨어가 무엇을 해야 하는지를 추상화한다.
    - 데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화한다.
    - 프로시저 추상화를 중심으로 시스템을 분해하는 것을 기능 분해(functional decomposition) 혹은 알고리즘 분해(algorithm decomposition)이라 부른다.
    - 데이터 중심으로 시스템을 분해하는 것은 두 가지로 나뉘는데 타입을 추상화(type abstraction)과 데이터를 중심으로 프로시저를 추상화(procedure abstracion)하는 것으로, 전자를 추상 데이터 타입(Abstract Data Type)이라 부르고 후자를 객체지향(Object-Oriented)라 부른다.

  - 프로그래밍 언어 관점에서의 객체지향
    - 프로그래밍 언어의 관점에서 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법이다.
    - 그리고 이런 객체를 구현하기 위해 대부분의 객체지향 언어는 클래스라는 도구를 제공한다.
    - 따라서 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것이다.

