# 다형성

- 다형성(Polymorphism)
  - 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력.
    - 간단히 말해서 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법이라고 할 수 있다.
  - 다형성의 분류
    - 다형성은 유니버설(Universal) 다형성과 임시(Ad Hoc) 다형성으로 나눌 수 있다.
    - 유니버설 다형성은 다시 매개 변수(Parametic) 다형성과 포함(Inclusion) 다형성으로 분류할 수 있다.
    - 임시 다형성은 오버로딩(Overloading) 다형성과 강제(Coercion) 다형성으로 분류할 수 있다.
  - 오버로딩 다형성
    - 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우를 가리켜 오버로딩 다형성이라 부른다.
    - 메서드 오버로딩을 사용하면 유사한 작업을 수행하는 메서드의 이름을 통일할 수 있기 때문에 기억해야 하는 이름의 수를 극적으로 줄일 수 있다.
  - 강제 다형성
    - 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킨다.
    - 예를 들어 Python에서 이향 연산자인 `+`는 피연산자가 모두 숫자형일 경우에는 숫자에 대한 덧셈 연산자로 동작하지만, 하나는 숫자형이고 하나는 문자열일 경우에는 연결 연산자로 동작한다.
    - 이 때 숫자형 피연산자는 문자열 타입으로 강제 형변환 된다.
  - 매개 변수 다형성
    - 클래스의 인스턴스나 메서드의 매개 변수 타입을 임의의 타입으로 선안한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식이다.
    - 예를 들어 Java의 List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있으며, 실제 인스턴스를 생성하는 시점에 T를 구체적인 타입으로 지정할 수 있게 하고 있다.
    - 따라서 List 인터페이스는 다양한 타입의 요소를 다루기 위해 동일한 오퍼레이션을 사용할 수 있다.
  - 포함 다형성
    - 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제 수행되는 행동이 달라지는 능력을 의미한다.
    - 포함 다형성은 서브타입 다형성이라고도 부른다.
    - 포함 다형성은 객체지향 프로그래밍에서 가장 널리 알려진 형태의 다형성으로, 특별한 언급 없이 다형성이라고 할 때는 포함 다형성을 의미하는 것이 일반적이다.
  - 포함 다형성과 상속
    - 포함 다형성을 구현하는 가장 일반적인 방법은 상속을 사용하는 것이다.
    - 두 클래스를 상속 관계로 연결하고 자식 클래스에서 부모 클래스의 메서드를 오버라이딩한 후 클라이언트는 부모 클래스만 참조하면 포함 다형성을 구현할 수 있다.
    - 포함 다형성을 서브타입 다형성이라고 부른다는 사실에서 예상할 수 있겠지만 포함 다형성을 위한 전제조건은 자식 클래스가 부모 클래스의 서브타입이어야 한다는 것이다.
    - 그리고 상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다.
    - 포함 다형성을 위해 상속을 사용하는 가장 큰 이유는 상속이 클래스들을 계층으로 쌓아 올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공하기 때문이다.
    - 객체가 메시지를 수신하면 객체지향 시스템은 메시지를 처리할 적절한 메서드를 상속 계층 안에서 탐색한다.





## 상속의 양면성

- 상속의 목적은 코드 재사용이 아니다.

  - 상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 윟나 것이다.
    - 타입 계층에 대한 고민 없이 코드를 재사용하기 위해 상속을 사용하면 이해하기 어렵고 유지보수하기 버거운 코드가 만들어질 확률이 높다.
    - 문제를 피할 수 있는 유일한 방법은 상속이 무엇이고 언제 사용해야 하는지를 정확히 이해하는 것뿐이다.

  - 상속의 메커니즘을 이해하는 데 필요한 개념들
    - 업캐스팅
    - 동적 메서드 탐색
    - 동적 바인딩
    - self 참조
    - super 참조



- 성적 계산 프로그램 만들기

  - `Lecture` 클래스 구현하기

  ```python
  from typing import List
  
  
  class Lecture:
  
      def __init__(self, title: str, pass_: int, scores: List[int]):
          self._title = title
          self._pass = pass_
          self._scores = scores
  
      def average(self):
          return sum(self._scores) / len(self._scores) if self._scores else 0
      
      def evaluate(self):
          return "Pass:{} Faile:{}".format(self._pass_count(), self._fail_count())
      
      def _pass_count(self):
          return len([score for score in self._scores if score >= self._pass])
      
      def _fail_count(self):
          return len([score for score in self._scores if score < self._pass])
  
      @property
      def score(self):
          return self._scores
      
  
  if __name__ == "__main__":
      lecture = Lecture("Psychology", 80, [75, 80, 95, 60, 85])
      print(lecture.evaluate())
  ```

  - 상속을 이용해 `Lecture` 클래스 재사용하기
    - `Lecture`의 출력 결과에 등급별 통계를 추가해달라는 요청이 들어왔다.
    - `Lecture`는 새로운 기능을 구현하는 데 필요한 대부분의 데이터와 메서드를 가지고 있으므로 `Lecture`를 상속하여 구현한다.
    - `GradeLecture.evaluate` 메서드는 `super`를 사용하여 부모 클래스의 `evaluate`를 먼저 실행한다.

  ```python
  class Grade:
  
      def __init__(self, name: str, upper: int, lower: int):
          self._name = name
          self._upper = upper
          self._lower = lower
  
      def is_name(self, name: str):
          return self._name == name
      
      def include(self, score: int):
          return self._lower <= score <= self._upper
  
      @property
      def name(self):
          return self._name
  
  
  class GradeLecture(Lecture):
  
      def __init__(self, name: str, pass_: int, grades: List[Grade], scores: List[int]):
          super().__init__(name, pass_, scores)
          self._grades = grades
  
      def evalutate(self):
          # 부모 클래스의 evaluate 메서드를 호출한다.
          return super().evaluate() + ", " + self._grade_statistics()
  
      def _grade_statistics(self):
          return " ".join(["{}:{}".format(grade.name, self._grade_count(grade)) for grade in self._grades])
      
      def _grade_count(self, grade: Grade):
          return len([score for score in self._scores if grade.include(score)])
  
  
  if __name__ == "__main__":
      lecture = GradeLecture("Psychology", 
                            80, 
                            [
                                Grade("A", 100, 95), 
                                Grade("B", 94, 80), 
                                Grade("C", 79, 70), 
                                Grade("D", 69, 50), 
                                Grade("F", 49, 0)
                            ],
                            [75, 80, 95, 60, 85])
      print(lecture.evalutate())
  ```

  - 메서드 오버라이딩
    - 위 코드에서 `Lecture`와 `GradeLecture`에 구현된 두 `evaluate` 메서드의 시그니처가 완전히 동일하다는 것에 주목해야 한다.
    - 부모 클래스와 자식 클래스가 동일한 시그니처를 가진 메서드가 존재할 경우 자식 클래의 우선순위가 더 높다.
    - 즉 메시지를 수신했을 때 자식 클래스의 메서드가 실행된다.
    - 이처럼 자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스 구현을 새로운 구현으로 대체하는 것을 메서드 오버라이딩이라고 부른다.
  - 메서드 오버로딩
    - 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것을 메서드 오버로딩이라 부른다.
    - 두 메서드의 시그니처가 다르기 때문에 자식 클래스의 메서드는 부모 클래스의 메서드를 대체하지 않으며, 결과적으로 두 메서드 모두 호출 가능하다.



- 데이터 관점의 상속

  - 아래와 같이 `GradleLecture` 인스턴스를 생성했다고 가정하자.

    - `GradleLecture` 클래스의 인스턴스는 직접 정의한 인스턴스 변수뿐만 아니라 부모 클래스인 `Lecture`가 정의한 인스턴스 변수도 함께 포함한다.

    - 상속을 인스턴스 관점에서 바라볼 때는 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 포함되는 것으로 생각하는 것이 유용하다.

  ```python
  lecture = GradeLecture("Psychology", 
                         80, 
                         [
                             Grade("A", 100, 95), 
                             Grade("B", 94, 80), 
                             Grade("C", 79, 70), 
                             Grade("D", 69, 50), 
                             Grade("F", 49, 0)
                         ],
                         [75, 80, 95, 60, 85])
  ```

  - 결국 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다.
    - 따라서 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 되는 것이다.



- 행동 관점의 상속

  - 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다.
    - 부모 클래스에 정의된 어떤 메서드가 자식 클래스에 포함될지는 언어의 종류와 각 언어가 정의하는 접근 제어자의 의미에 따라 다르지만 공통적으로 부모 클래스의 모든 퍼블릭 인터페이스는 자식 클래스의 퍼블릭 인터페이스에 포함된다.
    - 따라서 외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에게도 전송할 수 있다.
    - 행동 관점에서 상속과 다형성의 기본적인 개념을 이해하기 위해서는 상속 관계로 연결된 클래스 사이의 메서드 탐색 과정을 이해해야 한다.
  - 메서드는 동일한 클래스의 인스턴스끼리 공유가 가능하다.
    - 개체의 경우 서로 다른 상태를 저장할 수 있도록 각 인스턴스별로 독립적인 메모리를 할당받아야 한다.
    - 그러나 메서드는 동일한 클래스의 인스턴스끼리 공유가 가능하므로 클래스는 한 번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적이다.
    - 인스턴스의 메서드가 호출되면 인스턴스는 클래스를 가리키는 포인터를 이용해 자신의 클래스 정보에 접근하여 클래스에 정의된 메서드를 실행한다.
    - 각 클래스는 자신의 부모 클래스를 가리키는 포인터를 가진다.

  - 자식 클래스의 인스턴스를 통해 부모 클래스에 정의된 메서드를 실행할 수 있는 이유
    - 메시지를 수신한 객체는 클래스를 가리키는 포인터(class 포인터)로 연결된 자신의 클래스에 적절한 메서드가 존재하는지를 찾는다.
    - 만약 메서드가 존재하지 않으면 클래스의 parent 포인터를 따라 부모 클래스를 차례로 훑어 가면서 적절한 메서드가 존재하는지를 탐색한다.
    - 자식 클래스에서 부모 클래스로의 메서드 탐색이 가능하기 때문에 자식 클래스는 마치 부모 클래스에 구현된 메서드의 복사본을 가지고 있는 것처럼 보이게 된다.
    - 따라서 각 객체에 포함된 class 포인터와 클래스에 포함된 parent 포인터를 조합하면 현재 인스턴스의 클래스에서 최상위 부모 클래스에 이르기까지 모든 부모 클래스에 접근하는 것이 가능하다.





## 업캐스팅과 동적 바인딩

- 같은 메시지, 다른 메서드

  - 각 교수별로 강의에 대한 성적 통계를 계산하는 기능을 추가할 것이다.
    - 이를 통해 실행 시점에 메서드를 탐색하는 과정을 살펴볼 것이다.

  - `Professor` 클래스를 작성한다.

  ```python
  class Professor:
  
      def __init__(self, name, lecture: Lecture):
          self._lecture_name = name
          self._lecture = lecture
      
      def compile_statistics(self):
          return f"[{self._lecture_name}] {self._lecture.evaluate()} - Avg: {self._lecture.average()}"
  ```

  - `Lecture` 클래스의 인스턴스를 인자로 넘겨서 `Professor` 클래스를 생성한다.

  ```python
  propessor = Professor("DFS", Lecture("Algorithm", 
                                       80, 
                                       [75, 80, 95, 60, 85]))
  
  print(propessor.compile_statistics())
  ```

  - 이번에는 `GradeLecture` 클래스의 인스턴스를 인자로 넘겨서 `Professor` 클래스를 생성한다.

  ```python
  propessor = Professor("DFS", GradeLecture("Algorithm", 
                                            80, 
                                            [
                                                Grade("A", 100, 95), 
                                                Grade("B", 94, 80), 
                                                Grade("C", 79, 70), 
                                                Grade("D", 69, 50), 
                                                Grade("F", 49, 0)
                                            ],
                                            [75, 80, 95, 60, 85]))
  print(propessor.compile_statistics())
  ```

  - 어떤 클래스의 인스턴스를 전달하더라도 정상적으로 동작한다.
    - 이를 통해 동일 참조 객체인 `_lecture`에 대해 동일한 `evaluate` 메시지를 전송하는 동일한 코드 안에서 서로 다른 클래스 안에 구현된 메서드를 실행할 수 있다는 사실을 알 수 있다.
    - 이처럼 코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행 되는 메서드가 달라질 수 있는 것(다형성)은 업캐스팅과 동적 바인딩이라는 메커니즘이 작용하기 때문이다.



- 업캐스팅
  - 부모 클래스로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것을 의미한다.
    - 서로 다른 클래스의 인스턴스를 동일한 타입에 할당하는 것을 가능하게 해준다.
    - 따라서 부모 클래스에 대해 작성된 코드를 수정하지 않고도 자식 클래스에 적용할 수 있다.
    - 모든 객체지향 언어는 명시적으로 타입을 변환하지 않고도 부모 클래스 타입의 참조 변수에 자식 클래스의 인스턴스를 대입할 수 있게 허용해준다.
  - 다운캐스팅
    - 업캐스팅과 반대로 부모 클래스의 인스턴스를 자식 클래스로 타입 변환 하는 것을 의미한다.
    - 또한 업캐스팅과는 달리 명시적인 타입 캐스팅이 필요하다.
  - 업캐스팅을 통해 유연하고 확장 가능한 코드를 작성할 수 있다.
    - 모든 자식 클래스는 부모 클래스의 퍼블릭 인터페이스를 상속 받기 때문에, 부모 클래스와 협력하는 객체는 모든 자식 클래스와도 협력이 가능하다.



- 동적 바인딩
  - 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정되는 것을 의미한다.
    - 객체지향 시스템에서 메시지를 처리할 적절한 메서드를 컴파일타임이 아니라 런타임에 결정하기 때문에 가능하다.
    - 부모 클래스의 타입에 대해 메시지를 전송하더라도 실행 시에는 실제 클래스를 기반으로 실행될 메서드가 선택되게 해준다.
    - 따라서 코드르 변경하지 않고도 실행되는 메서드를 변경할 수 있다.
  - 정적 바인딩과 동적 바인딩
    - 전통적인 언어에서 함수를 실행하는 방법은 함수를 호출하는 것인 반면, 객체지향 언어에서 메서드를 실행하는 방법은 메시지를 전송하는 것이다.
    - 함수를 호출하는 전통적인 언어들은 호출될 함수를 컴파일타임에 결정하는데, 이를 정적 바인딩, 초기 바인딩, 컴파일타임 바인딩이라고 부른다.
    - 객체지향 언어에서는 메시지를 수신했을 때 실행될 메서드가 런타임에 결정되는데, 이를 동적 바인딩, 지연 바인딩이라고 부른다.





## 동적 메서드 탐색과 다형성

- 메서드 탐색
  - 객체지향 시스템은 아래 규칙에 따라 실행할 메서드를 선택한다.
    - 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 있는지 검사하고, 있다면 메서드를 실행하고 탐색을 종료한다.
    - 메서드를 찾지 못했다면 부모 클래스에서 메서드를 탐색하는데, 이 과정은 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.
    - 상속 계층의 가장 최상위 클래스에서도 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.
  - self 참조(self reference)
    - 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정한다.
    - 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이루어지며 메서드 탐색이 종료되는 순간 self 참조는 자동으로  소멸된다.
  - 동적 메서드 탐색은 자동적인 메시지 위임과 동적인 문맥이라는 두 가지 원리로 구성된다.
    - 자동적인 메시지 위임은 자식 클래스가 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층에 따라 부모 클래스에게 처리를 위임한다는 것이다.
    - 동적인 문맥은 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다는 것이다.



- 자동적인 메시지 위임	
  - 프로그래머의 개입 없이도 자식 클래스는 자신이 이해할 수 없는 메시지를 상속 계층을 따라 부모 클래스에게 처리를 위임한다는 것이다.
    - 이런 관점에서 상속 계층을 정의하는 것은 메서드 탐색 경로를 정의하는 것과 동일한다.
    - 핵심은 적절한 메서드를 찾을 때까지 상속 계층을 따라 부모 클래스로 처리가 위임된다는 것이다.
    - 상속을 이용할 경우 프로그래머가 메시지 위임과 관련된 코드를 명시적으로 작성할 필요가 없다는 점에도 주목해야 한다.
  - 메서드 오버라이딩
    - 동적 메서드 탐색은 자식 클래스에서 부모 클래스의 순서로 진행된다.
    - 따라서 자식 클래스와 부모 클래스 양쪽 모두에 동일한 시그니처를 가진 메서드가 구현되어 있다면 자식 클래스의 메서드가 먼저 검색된다.
    - 따라서 자식 클래스의 메서드가 부모 클래스의 메서드를 감추는 것 처럼 보이게 된다.
  - 메서드 오버로딩
    - 메서드 오버라이딩은 부모 클래스의 메서드를 감추지만 메서드 오버로딩은 부모 클래스의 메서드와 공존한다.
    - 즉 클라이언트의 관점에서 오버로딩된 모든 메서드를 호출할 수 있다.
    - 대부분의 사람들은 하나의 클래스 안에서 같은 이름을 가진 메서드들을 정의하는 것은 메서드 오버로딩으로 생각하고 상속 계층 사이에서 같은 이름을 가진 메서드를 정의하는 것은 메서드 오버로딩으로 생각하지 않는 경향이 있다.
    - 이는 일부 언어에서 상속 계층 사이의 메서드 오버로딩을 지원하지 않기 때문이다.
    - 지원하지 않는 이유는 상속 계층 안에서 동일한 이름을 가진 메서드가 공존해서 발생하는 혼란을 방지하가 위함으로 이를 이름 숨기기라고 부른다.



- 동적인 문맥

  - 메시지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다.
    - 이 동적인 문맥을 결정하는 것은 메시지를 수신한 객체를 가리키는 self 참조다.
    - self 참조가 `Lecture`의 인스턴스를 가리키고 있다면 메서드를 탐색할 문맥은 `Lecture` 클래스에서 시작해서 `Object` 클래스에서 종료되는 상속 계층이 된다.
    - self 참조가 `GradeLecture`의 인스턴스를 가리키고 있다면 메서드를 탐색할 문맥은 `GradeLecture` 클래스에서 시작해서 `Object` 클래스에서 종료되는 상속 계층이 된다.
    - 동일한 코드라 하더라도 self 참조가 가리키는 객체가 무엇인지에 따라 메서드 탐색을 위한 상속 계층의 범위가 동적으로 변한다.
    - 따라서 self 참조가 가리키는 객체의 타입을 변경함으로써 객체가 실행될 문맥을 동적으로 변경할 수 있다.
  - self 전송(self send)
    - self 참조가 동적 문맥을 결정한다는 사실은 종종 어떤 메서드가 실행될지를 예상하기 어렵게 만든다.
    - 대표적인 경우가 자신에게 다시 메시지를 전송하는 self 전송이다.
    - 예시를 위해 `Lecture`에 `stats`와 `_get_valuation_method` 메서드를 추가했다.
    - `stats`는 자신의 `_get_valuation_method` 메서드를 호출한다.
    - 그러나 사실 자신의 `_get_evaluation_method` 메서드를 호출한다는 말은 정확하지는 않다.
    - `self._get_evauluation_method`는 현재 클래스의 메서드를 호출하는 것이 아니라 현재 객체에게 `_get_evaluation_method` 메시지를 전송하는 것이다.
    - 현재 객체란 self가 가리키는 객체이며, 처음에 `stats` 메시지를 수신했던 객체이다.
    - 이처럼 self 참조가 가리키는 자기 자신에게 메시지를 전송하는 것을 self 전송이라고 부른다.

  ```python
  class Lecture:
      # ...
      
      def stats(self):
          return f"Title: {self._title} Evaluation Method: {self._get_evaluation_method()}"
      
      def _get_evaluation_method(self):
          return "Pass or Fail"
  ```

  - self 전송을 이해하기 위해서는 self 참조가 가리키는 바로 그 객체에서부터 메시지 탐색을 다시 시작한다는 사실을 기억해야 한다.
    - `Lecture`의 인스턴스가 `stats` 메시지를 수신하면 self 참조는 메시지를 수신한 `Lecture`의 인스턴스를 가리키도록 자동으로 할당된다.
    - 시스템은 이 객체의 클래스인 `Lecture`에서 `stats` 메서드를 발견하고 이를 실행시킬 것이다.
    - `stats` 메서드를 실행하던 중에 `_get_evaluation_method` 메서드 호출 구문을 발견하면 시스템은 self 참조가 가리키는 현재 객체에게 메시지를 전송한다.
    - 결과적으로 `stats` 메시지를 수신한 동일한 객체에게 `_get_evaluation_method` 메시지를 전송할 것이다.
    - self 참조가 가리키는 `Lecture` 클래스에서부터 다시 메서드 탐색이 시작되고 `Lecture._get_evaluation_method` 메서드를 실행한 후에 메서드 탐색을 종료한다.
  - 상속이 끼어들면 self 전송은 보다 복잡해진다.
    - `Lecture`를 상속 받는 `GradeLecture` 클래스에 `_get_evaluation_method` 메서드를 오버라이딩한다.
    - `GradeLecture`에 `stats` 메시지를 전송하면 self 참조는 `GradeLecture`의 인스턴스를 가리키도록 설정되고 메서드 탐색은 `GradeLecture` 클래스에서부터 시작된다.
    - `GradeLecture` 클래스에는 `stats` 메시지를 처리할 수 있는 적절한 메서드가 없기 때문에 부모 클래스인 `Lecture`에서 메서드 탐색을 계속하고 `Lecture.stats` 메서드를 실행할 것이다.
    - `Lecture.stats`를 실행하는 중에 self 참조가 가리키는 객체에게 `_get_evaluation_method` 메시지를 전송하라는 구문과 마주치게 된다.
    - 이제 메서드 탐색은 self가 가리키는 객체에서 다시 시작되며, 여기서 self 참조가 가리키는 객체는 `GradeLecture`의 인스턴스다.
    - 따라서 메시지 탐색은 `Lecture`를 벗어나 self 참조가 가리키는 `GradeLecture`에서부터 다시 시작된다.
    - 시스템은 `GradeLecture` 클래스에서 `_get_evaluation_method` 메서드를 발견하고 실행한 후 동적 메서드 탐색을 종료한다.

  ```python
  class GradeLecture(Lecture):
  
      def _get_evaluation_method(self):
          return "Grade"
  ```

  - self 전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경로를 다시 self 참조가 가리키는 원래의 자식 클래스로 이동시킨다.
    - 최악의 경우에는 실제로 실행될 메서드를 이해하기 위해 상속 계층 전체를 훑어가며 코드를 이해해야 하는 상황이 발생할 수도 있다.
    - 결과적으로 self 전송이 깊은 상속 계층과 중간중간 숨겨져 있는 메서드 오버라이딩과 만나면 극단적으로 이해하기 어려운 코드가 만들어진다.



- 이해할 수 없는 메시지
  - 객체가 이해할 수 없는 메시지를 처리하는 방법은 프로그래밍 언어가 정적 타입 언어에 속하는지 동적 타입 언어에 속하는지에 따라 달라진다.
    - 이해할 수 없는 메시지란 메시지를 처리할 메서드가 없는 메시지를 의미한다.

  - 정적 타입 언어의 경우
    - 정적 타입 언어에서는 코드를 컴파일할 때 상속 계층 안의 클래스들이 메시지를 이해할 수 있는지 여부를 판단한다.
    - 따라서 상속 계층 전체를 탐색한 후에도 메시지를 처리할 수 있는 메서드를 발견하지 못했다면 컴파일 에러를 발생시킨다.

  - 동적 타입 언어의 경우

    - 정적 타입 언어와 마찬가지로 메시지를 수신한 객체의 클래스부터 부모 클래스 방향으로 메서드를 탐색한다.
    - 차이점은 동적 타입 언어에는 커파일 단계가 존재하지 않기 때문에 실제로 코드를 실행해보기 전에는 메시지 처리 가능 여부를 판단할 수 없다는 점이다.
    - 코드가 실행된 후에 동적 메서드 탐색이 일어나고, 최상위 클래스에서도 찾을 수 없을 경우 예외가 던져진다.
    - 하지만 동적 타입 언어에서는 이해할 수 없는 메시지에 대해 예외를 던지는 것 외에도 선택할 수 있는 방법이 하나 더 있다.
    - 이 때 Ruby의 경우에는 method_missing 이라는 메시지를 전송하고, SmallTalk에서는 doesNotUnderstand 메시지를 전송한다.
    - 이 메시지에 응답할 수 있는 메서드를 구현하면 객체는 자신의 인터페이스에 정의되지 않은 메시지를 처리하는 것이 가능해진다.

    - 이해할 수 없는 동적 타입 언어는 좀 더 순순한 관점에서 객체지향 패러다임을 구현한다고 볼 수 있다.
    - 협력을 위해 메시지를 전송하는 객체는 단지 메시지를 수신한 객체가 메시지를 처리할 수 있다고 믿고 메시지를 전송할 뿐이다.
    - 객체가 해당하는 메서드를 구현하고 있건, method_missing 메서드를 재정의하건 상관 없이 클라이언트는 단지 전송한 메시지가 성공적으로 처리됐다는 사실만 알 수 있을 뿐이다.

  - 동적 타입 언어는 이해할 수 없는 메시지를 처리할 수 있는 능력을 가짐으로써 메시지가 선언된 인터페이스와 메서드가 정의된 구현을 분리할 수 있다.

    - 메시지 전송자는 자신이 원하는 메시지를 전송하고 메시지 수신자는 스스로의 판단에 따라 메시지를 처리한다.
    - 이는 메시지를 기반으로 협력하는 자율적인 객체라는 순수한 객체지향의 이상에 좀 더 가까운 것이다.
    - 그러나 이러한 동적 타입 언어의 동적인 특성과 유연성은 코드를 이해하고 수정하기 어렵게 만들뿐 아니라 디버깅 과정을 복잡하게 만들기도 한다.

  - 정적 타입 언어는 유연성이 부족하지만 좀 더 안정적이다.

    - 모든 메시지는 컴파일 타임에 확인되고 이해할 수 없는 메시지는 에러로 이어진다.
    - 실행 시점에 오류가 발생할 가능성을 줄임으로써 프로그램이 좀 더 안정적으로 실행될 수 있다.



- self 대 super

  - self 참조의 가장 큰 특징은 동적이라는 점이다.
    - self 참조는 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행 시점에 결정한다.

  - super 참조(super reference)
    - 자식 클래스에서 부모 클래스의 인스턴스 변수나 메서드에 접근하기 위해 사용할 수 있는 내부 변수이다.
    - super에 의해 호출되는 메서드는 부모 클래스의 메서드가 아니라 더 상위에 위치한 조상 클래스의 메서드일 수도 있다.
    - 예를 들어 아래와 같이 `GradeLecture`를 상속 받는 클래스를 추가하고, `super.average`를 통해 조상 클래스에 메시지를 전송하도록 한다.
    - 이 때 `GradeLecture`에는 `average()` 라는 메서드가 없으므로 `Lecture.average()` 메서드가 실행된다.

  ```python
  class FormattedGradeLecture(GradeLecture):
      
      def format_average(self):
          return f"Avg: {super().average()}"
  ```

  - super 참조의 용도는 부모 클래스에 정의된 메서드를 실행하기 위한 것이 아니다.
    - super 참조의 정확한 의도는 "지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작하라"다.
    - 만약 부모 클래스에서 원하는 메서드를 찾지 못하면 더 상위의 부모 클래스로 이동하면서 메서드가 존재하는지 검사한다.
    - 이는 super 참조를 통해 실행하고자 하는 메서드가 반드시 부모 클래스에 위치하지 않아도 되는 유연성을 제공한다.
    - 부모 클래스의 메서드를 호출하는 것과 부모 클래스에서 메서드 탐색을 시작하는 것은 의미가 매우 다르다.
    - 부모 클래스의 메서드를 호출하는 것은 그 메서드가 반드시 부모 클래스 안에 정의되어 있어야 한다는 것을 의미한다.
    - 그에 비해 부모 클래스에서 메서드 탐색을 시작한다는 것은 그 클래스의 조상 어딘가에 그 메서드가 정의되어 있기만 하면 실행할 수 있다는 것을 의미한다.
  - super 전송(super send)
    - super 참조를 통해 메시지를 전송하는 것은 마치 부모 클래스의 인스턴스에게 메시지를 전송하는 것 처럼 보이기 때문에 이를 super 전송이라고 부른다.
    - self 전송이 메시지를 수신하는 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정하는데 비해 super 전송은 항상 메시지를 전송하는 클래스의 부모 클래스에서부터 시작된다.
    - 따라서 self 전송의 경우 메서드 탐색을 시작할 클래스를 반드시 실행 시점에 동적으로 결정해야 하지만 super 전송의 경우에는 컴파일 시점에 미리 결정해 놓을 수 있다.

  - self 참조와 super 참조는 상속을 이용해 다형성을 구현하고 코드를 재사용하기 위한 핵심 개념이다.
    - 동적 바인딩과 self 참조는 동일한 메시지를 수신하더라도 객체의 타입에 따라 적합한 메서드를 동적으로 선택할 수 있게 한다.
    - super 참조는 부모 클래스의 코드에 접근할 수 있게 함으로써 중복 코드를 제거할 수 있게 한다.





## 상속과 위임

- 다형성은 self 참조가 가리키는 현재 객체에게 메시지를 전달하는 특성을 기반으로 한다.
  - 동일한 타입의 객체 참조에게 동일한 메시지를 전송하더라도 self 참조가 가리키는 객체의 클래스가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 달라진다.
  - self 참조가 동적인 문맥을 결정한다는 사실을 이해하면 상속을 바라보는 새로운 시각이 형성된다.
    - 자식 클래스에서 부모 클래스로 self 참조를 전달하는 메커니즘으로 상속을 바라보게 된다.



- 위임과 self 참조

  - self 참조는 항상 메시지를 수신한 객체를 가리킨다.
    - 자식 클래스의 인스턴스를 생성할 경우 개념적으로 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 표현할 수 있다.
    - 이 경우 자식 클래스의 self는 자식 클래스의 인스턴스를 가리킨다.
    - 또한 자식 클래스의 인스턴스 안에 포함된 부모 클래스의 인스턴스 입장에서도 self는 자식 클래스의 인스턴스를 가리킨다.
    - self 참조는 항상 메시지를 수신한 객체를 가리키기 때문이다.
    - 따라서 메서드 탐색 중에는 자식 클래스의 인스턴스와 부모 클래스의 인스턴스가 동일한 self 참조를 공유하는 것으로 봐도 무방하다.

  - 위임(delegation)
    - 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것을 의미한다.
    - 위임은 본질적으로는 자신이 이해할 수 없는 메시지를 다른 객체로 이동시키기 위해 사용한다.
    - 이를 위해 위임은 항상 현재의 실행 문맥을 가리키는 self 참조를 인자로 전달한다.
    - 이것이 self 참조를 전달하지 않는 포워딩과 위임의 차이점이다.
  - 포워딩과 위임
    - 객체가 다른 객체에게 요청을 처리할 때 인자로 self를 전달하지 않을 수도 있다.
    - 이는 요청을 전달 받은 최초의 객체(self 참조가 가리키는 객체)에 다시 메시지를 전송할 필요는 없고 단순히 코드를 재사용하고 싶은 경우하로 할 수 있다.
    - 이처럼 처리를 요청할 때 self 참조를 전달하지 않는 경우를 포워딩이라고 부른다.
    - 이와 달리 self 참조를 전달하는 경우에는 위임이라고 부른다.
    - 위임의 정확한 용도는 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현하는 것이다.



- 위임과 상속의 관계
  - 위임은 객체 사이의 동적인 연결 관계를 이용해 상속을 구현하는 방법이다.
    - 상속이 매력적인 이유는 우리가 직접 구현해야 하는 번잡한 과정(인스턴스들 사이에 메시지를 수신한 최초의 객체를 전달하는 과정)을 자동으로 처리해준다는 점이다.
    - 간단히 자식 클래스를 선언하면 실행 시에 인스턴스들 사이에서 self 참조가 자동으로 전달된다.
    - 이 self 참조의 전달은 결과적으로 자식 클래스의 인스턴스와 부모 클래스의 인스턴스 사이에 동일한 실행 문맥을 공유할 수 있게 해준다.
  - 즉 클래스 기반의 상속과 객체 기반의 위임은 기본 개념과 매커니즘을 공유한다.
    - 즉 객체가 다른 객체에게 자신에 대한 참조를 전달하면서 메시지 처리를 부탁하는 위임의 개념을 클래스에 적용한 것이 상속이다.

