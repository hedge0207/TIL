- 행동
  - 상태 캡슐화
    - 객체는 다른 객체에게 특정한 행동을 해줄 것을 요청하며, 해당 요청을 어떻게 처리할지는 요청을 받은 객체에게 달려있다.
    - 요청을 보낸 객체는 요청을 받은 객체가 자신의 요청대로 행동을 해줄 것이라는 것을 믿고 전달할 뿐이다.
    - 송신자가 수신자의 상태 변경을 기대하더라도, 수신자가 자신의 상태를 변경하지 않는다면 송신자가 간섭할 수 있는 어떤 여지도 없다.
    - 이것이 캡슐화의 의미로, 캡슐화는 이처럼 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다.
    - 객체가 외부에게 노출하는 것은 어떤 행동을 할 수 있는가 뿐이다.



- 식별자
  - 식별자란
    - 객체란 식별 가능한 경계를 가진 모든 사물을 의미한다.
    - 객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다.
    - 식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다.
  - 객체가 아닌 값은 식별자를 가지지 않는다.
    - 모든 객체가 식별자를 가진다는 것은 반대로 객체가 아닌 단순한 값은 식별자를 가지지 않는다는 것을 의미한다.
    - 객체가 가지는 프로퍼티의 타입 중 값과 객체의 가장 큰 차이점은 값은 식별자를 가지지 않는다는 점이다.
    - 그리고 시스템을 설계할 때 단순한 값과 객체의 차이점을 명확하게 구분하고 명시적으로 표현하는 것이 매우 중요하다.
  - 값(value)
    - 값은 숫자, 문자열, 날짜, 시간 등 변하지 않는 양을 모델링한다.
    - 흔히 값의 상태는 변하지 않기 때문에 불변 상태를 가진다고 말한다.
    - 값의 경우 두 인스턴스의 상태가 같다면 두 인스턴스를 같은 것으로 판단한다.
  - 값의 동등성(equality)
    - 값이 같은지 여부는 상태가 같은지를 이용해 판단한다.
    - 예를 들어 1이라는 숫자(값)는 모든 1이 동일한 상태를 가지며, 어떤 1도 다른 1과 다르지 않다.
    - 값의 상태가 같으면 두 인스턴스는 동일한 것으로 판단하고 다르면 두 인스턴스는 다른 것으로 판단한다.
    - 이처럼 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성이라 한다.
    - 값은 오직 상태만을 이용해 동등성을 판단하기 때문에 인스턴스를 구별하기 위한 별도의 식별자를 필요로 하지 않는다.
  - 값의 불변성(immutability)
    - 상태를 이용해 두 값이 같은지를 판단할 수 있는 이유는 값의 상태가 변하지 않기 때문이다.
    - 값의 상태는 결코 변하지 않기 때문에 어떤 시점에 동일한 타입의 두 값이 같다면 언제까지라도 두 값은 동등한 상태를 유지할 것이다.
  - 객체는 가변 상태를 가진다.
    - 객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 다른 상태를 변경한다.
    - 따라서 객체는 가변 상태를 가진다고 말한다.
    - 타입이 같은 두 객체의 상태가 완전히 똑같더라도 두 객체는 독립적인 별개의 객체로 다뤄야 한다.
  - 객체의 동일성(identical)
    - 객체는 상태와 무관하게 두 객체를 동일하거나 다르다고 판단할 수 있는 프로퍼티를 가진다.
    - 두 객체의 상태가 다르더라도 식별자가 같다면 두 객체를 같은 객체로 판단할 수 있다.
    - 이처럼 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 동일성이라고 한다.
  - 식별자가 필요한 이유
    - 객체의 상태는 시간이 흐름에 따라 변화한다.
    - 따라서 가변적인 상태를 가지는 객체를 식별하기 위해서는 상태 변경에 독립적인 별도의 식별자를 이용할 수 밖에 없다.
    - 한 객체는 시간의 흐름에 따라 상태가 변화하더라도 객체의 상태가 변화한 것이지 다른 객체가 된 것은 아니며, 어느 시점에 서로 다른 두 객체의 상태가 동일하더라도 두 객체가 동일한 객체인 것은 아니다.
  - 값과 객체의 차이에 혼동이 생기는 이유
    - 대부분의 객체지향 프로그래밍 언어에서 값과 객체 모두 클래스를 이용해 구현되기 때문이다.
    - 객체 지향 프로그래밍 언어를 사용하면, 숫자는 Int라는 클래스로, 사람은 Person이라는 클래스로 정의할 수 밖에 없다.
    - 따라서 프로그래밍 언어의 관점에서 숫자는 Int 클래스로 부터 생성된 객체이며, 사람은 Person 클래스로부터 생성된 객체이다.
    - 객체지향 언어의 관점에서 값과 객체 모두 클래스로부터 생성된 객체이기 때문에 문맥에 따라 그 의미가 혼란스러워질 수 있다.
  - 값과 객체 사이의 혼동을 줄이기 위해 여기서는 객체와 값을 지칭하는 별도의 용어를 사용할 것이다.
    - 참조 객체(refrerence object) 또는 엔티티(entity)는 식별자를 지닌 전통적인 의미의 객체를 가리키는 용어이다.
    - 값 객체(value object)는 식별자를 가지지 않는 값을 가리키는 용어이다.



- 행동이 상태를 결정한다.
  - 객체 지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이다.
    - 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고 그 상태에 필요한 행동을 결정한다.
    - 그러나 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 미친다.
  - 행동보다 상태를 먼저 결정할 경우의 문제점
    - 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아져 캡슐화를 저해한다.
    - 상태를 먼저 고려할 경우, 객체간의 협력이라는 맥락에서 멀리 벗어난 객체를 설계하게 되어 자연스럽게 협력에 적합하지 못한 객체를 생성하게 된다.
    - 상태의 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵기 때문에 재사용성이 저하된다.
  - 협력에 참여하기 위한 객체를 생성하기 위해서는 상태 보다는 행동에 초점을 맞춰야한다.
    - 객체는 다른 객체와 협력하기 위해 존재하고, 객체의 행동은 객체가 협력에 참여하는 유일한 방법이다.
    - 따라서 객체가 적합한지를 결정하는 것은 그 객체의 행동이 아니라 행동이다.
    - 애플리케이션에 필요한 협력을 생각하고, 협력에 참여하는 데 필요한 상태를 생각한 후 행동에 필요한 상태가 무엇인지를 생각해야한다.
    - 결국 행동이 상태를 결정한다.



## 은유와 객체

- 객체지향이란 현실 세계의 모방인가?

  - 흔히 객체지향을 현실 세계의 모방이라고 표현한다.
    - 이러한 관점에서 객체지향 설계란 현실 세계에 존재하는 다양한 객체를 모방한 후 필요한 부분만 취해 소프트웨어 객체로 구현하는 과정이라고 설명한다.
    - 객체지향을 현실 세계의 추상화라고도 하는데, 그 안에는 현실 세계를 모방에서 단순화한다는 의미가 숨어 있따.
  - 그러나 객체지향 세계는 현실 세계의 단순한 모방이 아니다.
    - 소프트웨어 안에 구현된 상품 객체는 실제 세계의 상품과는 전혀 다른 양상을 띤다.
    - 소프트웨어 세계의 음료수는 스스로의 양을 줄일 수 있다.
    - 이것은 소프트웨어 상품이 실제 세계의 상품을 추상화한 것이 아니라 특성이 전혀 다른 어떤 것임을 의미한다.

  - 의인화(anthropomorphism)
    - 현실 세계의 객체와 달리 객체지향 세계의 모든 객체는 능동적으로 행동할 수 있다.
    - 레베카 워프스브록은 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 의인화라고 부른다.
    - 객체지향 세계의 객체는 현실 속의 객체보다 더 많은 특징과 능력을 보유하고 있다.



- 은유
  - 객체지향의 세계와 현실 세계 사이에 전혀 상관이 없는 것은 아니다.
    - 모방이나 추상화의 수준이 아닌 다른 관점에서 유사성을 지니고 있다.
    - 현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 은유이다.
    - 은유의 본질은 한 종류의 사물을 다른 종류의 사물 관점에서 이해하고 경험하는 데 있다.
  - 현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다.
    - 현실 속의 전화기는 스스로 전화를 걸 수 없다고 하다. 
    - 그러나, 우리가 익히 알고 있는 현실의 전화기라는 개념을 이용해 소프트웨어 객체를 묘사하면 그 객체가 전화를 걸 수 있다는 사실을 쉽게 이해하고 기억할 수 있게 된다.
  - 은유관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있다.
    - 이를 통해 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있따.
    - 이것이 많은 객체지향 지침서들이 현실 세계의 도메인에서 사용되는 이름을 객체에게 부여하라고 가이드하는 이유이다.



## 타입과 추상화

- 추상화를 통한 복잡성 극복
  - 추상화란
    - 어떤 양상, 세부 사항, 구조를 좀 더 명확히 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감추는 방법이다.
    - 추상화의 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화다.
    - 추상화의 두 번째 차원은 불필요한 세부 사항을 제거하는 것이다.
  - 추상화의 목적
    - 현실에 존재하는 다양한 현상 및 사물과 상호작용하기 위해서는 우선 현실을 이해해야한다.
    - 그러나 복잡한 현실 세계를 이해하는 것이 쉽지 않으므로 추상화를 통해 현실 세계를 단순화할 필요가 있다.
  - 훌륭한 추상화의 기준
    - 현실에서 출발하되 불필요한 부분을 도려내어 사물의 본질을 드러나게 해야 한다.
    - 추상화의 목적에 부합해야한다.



- 객체지향과 추상화
  - 그룹으로 나누어 단순화하기
    - 공통적인 특성을 지닌 객체들을 하나의 그룹으로 묶어 단순화할 수 있다.
    - 즉 객체를 여러 그룹으로 분류(classification)할 수 있다.
    - 객체지향 언어에서는 이 분류를 class로 표현한다.
  - 개념
    - 공통점을 기반으로 객체를 묶기 위한 그릇을 개념(concept)이라 한다.
    - 개념이란 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 뜻한다.
    - 각 객체는 특정한 개념을 표현하는 그룹의 일원으로 포함된다.
    - 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 인스턴스라고 한다.
  - 개념의 세 가지 관점
    - 개념은 특정한 객체가 어떤 그룹에 속할 것인지를 결정한다.
    - 즉 어떤 객체에 어떤 개념이 적용됐다고 할 때는 그 개념이 부가하는 의미를 만족시킴으로써 다른 객체와 함께 해당 개념의 일원이 됐다는 것을 의미한다.
    - 일반적으로 객체의 분류장치로서의 개념을 이야기할 때는 아래의 세 가지 관점을 함께 언급한다.
    - 심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭
    - 내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
    - 외연(extension): 개념에 속하는 모든 객체의 집합
  - 분류
    - 분류란 객체에 특정한 개념을 적용하는 작업이다.
    - 따라서 개념은 객체를 분류하기 위한 도구라고 불 수 있다.
    - 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.
    - 분류는 객체지향의 가장 중요한 개념 중 하나이며, 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다.
    - 객체를 적절한 개념에 따라 분류하지 못한 애플리케이션은 유지보수가 어렵고 변화에 쉽게 대응하지 못한다.



- 타입

  - 타입은 개념이다.
    - 위에서 개념은 분류를 위해 사용되는 도구라고 했다.
    - 타입은 개념과 동일하다.
    - 따라서 타입이란 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다.
    - 어떤 객체에 어떤 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다.
    - 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

  - 전통적인 데이터 타입
    - 메모리의 세계에는 타입이 존재하지 않으며, 모든 데이터는 일련의 비트열로 구성된다.
    - 타입이 존재하지 않아 발생할 수 있는 혼동에 대처하기 위해 타입이 만들어졌다.
    - 타입에 따라 수행 가능한 작업과 불가능한 작업을 구분함으로써 데이터가 잘못 사용되는 것을 방지한다.
    - 결과적으로 타입 시스템의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다.
    - 결국 타입은 데이터가 어떻게 사용되느냐에 관한 것이다.
    - 또한 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.
    - 결국 데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터라 할 수 있으며, 이 메타데이터를 통해 암시적으로 어떤 종류의 연산이 해당 데이터에 수행될 수 있는지를 결정한다.
  - 객체와 타입
    - 전통적인 데이터 타입과 객체지향의 타입 사이에는 연관성이 존재한다.
    - 객체지향 프로그램을 작성할 때 객체를 일종의 데이터처럼 사용하게 되므로, 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같다.
    - 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.
    - 따라서 어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.
    - 객체의 타입은 객체의 내부 표현과는 아무런 상관이 없다.
    - 따라서 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다.
  - 행동이 우선이다.
    - 어떤 행동을 하느냐에 따라 객체의 타입이 결정되고, 객체의 타입은 객체 내부의 표현과는 아무런 상관이 없으므로 객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다고 할 수 있다.
    - 결과적으로 동일한 책임을 수행하는 객체는 동일한 타입에 속한다고 할 수 있다.
    - 두 객체가 동일한 상태를 가지고 있다고 하더라도 다른 행동을 한다면 서로 다른 타입에 속한다고 할 수 있다.
    - 따라서 객체의 타입을 결정하는 것은 객체의 행동뿐이다.
    - 결국 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다.
    - 여기서 동일한 행동이란 동일한 책임을 의미하고, 동일한 책임은 동일한 메시지 수신을 의미한다.
    - 따라서 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다.
    - 다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수 밖에 없으며, 이는 다형성에 의미를 부여한다.
    - 결론적으로 다형적인 객체들은 동일한 타입(혹은 타입 계층)에 속하게 된다.
  - 결국 타입은 앞에서 살펴본 추상화의 첫 번째 차원인 공통점은 취하고 차이점은 버리는 일반화의 산물이라고 할 수 있다.



- 타입의 계층
  - 타입에는 계층이 존재한다.
    - 하나의 타입이 다른 타입이 할 수 있는 행동을 모두 할 수 있고, 거기에 추가적인 행동도 할 수 있을 때 두 타입 사이에 계층이 존재한다고 할 수 있다.
    - 집합의 관점에서 본다면, 추가적인 행동을 할 수 있는 타입이 다른 타입의 부분집합이라고 할 수 있다.
  - 일반화와 특수화
    - 타입과 타입 사이에는 일반화/특수화 관계가 존재할 수 있다.
    - 일반적이라는 말은 더 포괄적이라는 의미를 내포하고, 특수하다는 말은 일반적인 개념보다 범위가 더 좁다는 것을 의미한다.
    - 일반적인 타입이란 특수한 타입이 가진 모든 행동들 중에서 일부 행동만을 가지는 타입을 가리킨다.
    - 특수한 타입이란 일반적인 타입이 가진 모든 행동을 포함하지만 거기에 더해 자신만의 행동이 추가된 타입을 가리킨다.
    - 일반화/특수화 관계는 결정하는 것은 객체의 상태가 아닌 객체의 행동이라는 것이 중요하다.
    - 두 타입 간에 일반화/특수화 관계가 성립하려면 한 타입이 다른 타입보다 다른 타입보다 더 특수하게 행동해야하고, 반대로 한 타입은 다른 타입보다 더 일반적으로 행동해야한다.
  - 슈퍼타입과 서브타입
    - 일반화/특수화 관계는 좀 더 일반적인 한 타입과 좀 더 특수한 한 타입 간의 관계다.
    - 이 때 좀 더 일반적인 타입을 슈퍼타입이라 하고, 좀 더 특수한 타입을 서브타입이라고한다.
    - 일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야한다.
  - 결국 타입의 계층은 앞에서 살펴본 추상화의 두 번째 차원인 중요한 부분을 강조하기 위해 불필요한 세부 사항을 단순화한 결과이다.
    - 일반화/특수화 계층은 객체지향에서 추상화의 두 번째 차원을 적절하게 사용하는 대표적인 예이다. 



- 정적 모델
  - 타입의 목적
    - 타입을 사용하는 이유는 시간에 따라 능동적으로 변하는 객체의 복잡성을 극복하기 위함이다.
    - 객체를 추상화하여 공통적인 객체를 묶어 단순화하기 위함이다.
    - 타입은 시간에 따라 동적으로 변하는 객체의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다.
  - 타입은 추상화다.
    - 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다.
    - 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법인 것이다.
  - 동적 모델과 정적 모델
    - 객체가 특정 시점에 구체적으로 가지는 상태를 스냅샷이라 한다.
    - 스냅샷처럼 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 행동하는지를 포착하는 것을 동적 모델이라 한다.
    - 다른 하나는 객체가 가질 수 있는 모든 상태와 행동을 시간에 독립적으로 표현하는 것으로, 이런 모델을 타입 모델이라한다.
    - 타입 모델은 동적으로 변하는 객체의 상태가 아니라 객체가 속한 타입의 정적인 모습을 표현하기 때문에 정적 모델이라고도 한다.
  - 객체지향 애플리케이션을 설계하고 구현하기 위해서는 객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야한다.
    - 동적 모델과 정적 모델의 구분은 실제로 프로그래밍이라는 행위와도 관련이 깊다.
    - 객체지향 프로그래밍 언어에서 클래스를 작성하는 시점에는 시스템을 정적인 관점에서 접근하는 것이다.
    - 그러나 실제로 애플리케이션을 실행해 객체의 상태 변경을 추적하고 디버깅하는 동안에는 객체의 동적인 모델을 탐험하고 있는 것이다.
  - 클래스
    - 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다.
    - 따라서 타입을 구현하는 가정 보편적인 방법은 클래스를 이용하는 것이다.
    - 그러나 클래스는 타입과 동일한 것이 아니다.
    - 타입은 객체를 분류하기 위해 사용하는 개념인 반면, 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐이다.
    - 그럼에도 객체지향 패러다임을 주도하는 대부분의 프로그래밍 언어는 클래스를 기반으로 하기 때문에 대부분의 사람들은 클래스와 타입을 동일한 개념이라고 생각한다.
    - 클래스와 타입을 구분하는 것은 설계를 유연하게 유지하기 위한 바탕이 된다.
    - 클래스는 타입의 구현 외에도 코드를 재사용하는 용도로도 사용되기 때문에 클래스와 타입을 동일시하는 것은 오해와 혼란을 불러일이킨다.