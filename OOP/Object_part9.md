# 계약에 의한 설계

- 계약에 의한 설계가 필요한 이유
  - 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다
    - [메시지와 인터페이스]에서 살펴본 원칙에 따라 의도를 드러내도록 인터페이스를 다듬고 명령과 쿼리를 분리했다고 해도 명령으로 인해 발생하는 부수효과를 명확하게 표현하는 데는 한계가 있다.
    - 메서드의 내부 구현이 단순하다면 내부를 살펴보는 것만으로도 부수효과를 쉽게 이해할 수 있을 것이다.
    - 하지만 구현이 복잡하고 부수효과를 가진 다수의 메서드들을 연이어 호출하는 코드를 분석하는 경우에는 실행 결과를 예츧하기 어려울 수밖에 없다.
    - 물론 주석으로 해결할 수 있겠지만, 주석으로 설명하는 것은 한계가 있을 뿐더러, 주석이 시간이 지남에 따라 코드를 반영하지 못 하게 되는 경우도 많아지기 때문에 이는 좋은 방법이 아니다.
  - 계약에 의한 설계를 사용하면 다양한 제약과 부수효과를 정의하고 문서화할 수 있다.
    - 클라이언트 개발자는 오퍼레이션의 구현을 살펴보지 않더라도 객체의 사용법을 쉽게 이해할 수 있다.
    - 계약은 실행 가능하기 때문에 구현에 동기화돼 있는지 여부를 런타임에 검증할 수 있다.
    - 따라서 주석과 다르게 시간의 흐름에 뒤쳐질 걱정을 할 필요가 없다.
    - 계약에 의한 설계는 클래스의 부수효과를 명시적으로 문서화하고 명시적으로 커뮤니케이션할 수 있을뿐만 아니라 실행 가능한 검증 도구로써 사용할 수 있다.



- C#에는 계약에 의한 설계 라이브러리인 Code Contracts가 있다.
  - 아래 예시에서는 이 라이브러리를 사용할 것이다.



## 협력과 계약

- 부수효과를 명시적으로

  - 객체지향의 핵심은 협력 안에서 객체들이 수행하는 행동이다.
    - 프로그래밍 언어로 작성된 인터페이스는 객체가 수신할 수 있는 메시지는 정의할 수 있지만 객체 사이의 의사소통 방식은 명확하게 정의할 수 없다.
    - 메시지의 이름과 파라미터 목록은 시그니처를 통해 전달할 수 있지만 협력을 위해 필요한 약속과 제약은 인터페이스를 통해 전달할 수 없기 떄문에 협력과 관련된 상당한 내용이 암시적인 상태로 남게 된다.
  - [메시지와 인터페이스] 장에서 명령-쿼리 분리 원칙을 살펴보기 위해 소개했던 일정 관리 프로그램의 C# 버전을 이용해 계약에 의한 설계를 살펴볼 것이다.
    - 명령과 쿼리를 분리했기에 `Event` 클래스의 클라이언트는 먼저 `IsSatisfied` 메서드를 호출해서 `RecurringSchedule`의 조건을 만족시키는지 여부를 확인한 후에 `Reschedule` 메서드를 호출해야 한다.
    - 인터페이스만으로는 메서드의 순서와 관련된 제약을 설명하기 쉽지 않지다.
    - 그러나 계약에 의한 설계 라이브러리인 Code Contracts를 사용하면 `IsSatisfied` 메서드의 실행 결과가 true일 때만 `Reschedule` 메서드를 호출할 수 있다는 사실을 명확하게 표현할 수 있다.

  ```c#
  class Event
  {
      public bool IsSatisfied(RecurringSchedule schedule) {...}
      
      public void Reschedule(RecurringSchedule schedule)
      {
          Contract.Requires(IsSatisfied(schedule));
      }
  }
  ```

  - 계약을 통한 설계의 장점
    - 위 코드가 if문을 사용한 일반적인 파라미터 체크 방식과 크게 다르지 않다고 생각할 수도 있지만 그렇지 않다.
    - 대표적인 차이점으로 문서화를 들 수 있다.
    - 일반적인 정합성 체크 로직은 코드의 구현이 내부에 숨겨져있어 실제로 코드를 분석하지 않는 한 정확하게 파악하기가 쉽지 않다.
    - 게다가 일반 로직과 조건을 기술한 로직을 구분하기도 쉽지 않다.
    - 하지만 계약에 의한 설계를 지원하는 라이브러리나 언어들은 일반 로직과 구분할 수 있도록 계약 조건을 명시적으로 표현하는 것이 가능하다.
    - 위 코드에서 `Contract.Requires`는 메서드를 호출하기 전에 true여야 하는 조건을 표현하기 위해 Code Contracts에서 제공하는 API로 `IsSatified` 메서드의 반환값이 ture일 경우에만 `Reschedule` 메서드를 호출할 수 있다는 사실을 명확하게 표현한다.
    - 이렇게 작성된 계약은 문서화로 끝나는 것이 아니라 제약 조건의 만족 여부를 실행 중에 체크할 수 있다.
    - 또한 이 조건들은 코드로부터 추출해서 문서를 만들어주는 자동화 도구도 제공한다.
    - 따라서 계약에 의한 설계를 사용하면 계약 조건을 명시적으로 표현하고 자동으로 문서화할 수 있을뿐만 아니라 실행을 통해 검증할 수 있다.



- 계약
  - 계약은 한쪽의 의무가 반대쪽의 권리가 된다.
    - 예를 들어 리모델링 계약을 채결하는 상황을 가정해보자.
    - 리모델링을 위탁하는 입장에서는 인테리어 업자에게 대금을 지급할 의무가 있고, 원하는 품질로 집을 리모델링 받을 권리가 있다.
    - 반대로 인테리어 입자 입장에서는 고객이 원하는 품질로 집을 리모델링할 의무가 있고, 대금을 받을 권리가 있다.
  - 두 계약 당사자 중 어느 한쪽이라도 계약의 내용을 위반한다면 계약은 정상적으로 완료되지 않는다.
  - 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어다.
    - 그리고 사람들이 협력을 위해 사용하는 계약이라는 아이디어를 객체들이 협력하는 방식에도 적용하는 것이 계약에 의한 설계이다.





## 계약에 의한 설계

- 버트란드 마이어는 Effiel 언어를 만들면서 사람들 사이의 계약에 착안해 계약에 의한 설계 기법을 고안했다.

  - 버트란드 마이어가 제시한 계약의 개념은 사람들 사이의 계약과 유사하다.
  - 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것이다.
    - 협력에 참여하는 각 객체는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 수행한다.
    - 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스상에 문서화된다.
  - 계약에 의한 설계 개념은 인터페이스에 대해 프로그래밍하라는 원칙을 확장한 것이다.
    - 계약에 의한 설계를 이용하면 오퍼레이션의 시그니처를 구성하는 다양한 요소들을 이용해 협력에 참여하는 객체들이 지켜야 하는 제약 조건을 명시할 수 있다.
    - 이 제약 조건을 인터페이스의 입루로 만듦으로써 코드를 분석하지 않고도 인터페이스의 사용법을 이해할 수 있다.
  - 계약에 의한 설계와 의도를 드러내는 인터페이스
    - 메서드의 이름과 매개변수의 이름을 통해 오퍼레이션이 클라이언트에게 어떤 것을 제공하려고 하는지를 설명할 수 있다.
    - 즉 의도를 드러내는 인터페이스를 만들면 오퍼레이선의 시그니처만으로도 어느 정도까지는 클라이언트와 서버가 협력을 위해 수행해야 하는 제약조건을 명시할 수 있다.
    - 계약은 여기서 한 걸음 더 나아간다.
    - 메서드를 호출할 때 클라이언트 개발자는 매개변수에 전달할 수 있는 값을 가정해야하지만, 그 가정은 틀릴 수 있다.
    - 계약에 의한 설계는 잘못된 가정으로는 다른 객체와 협력할 수 없게 한다.

  - 계약에 의한 설계를 구성하는 세 가지 요소

    - 사전조건(precondition): 메서드가 호출되기 위해 만족돼야 하는 조건으로, 메서드의 요구 사항을 명시한다. 사전조건이 만족되지 않을 경우 메서드가 실행되어서는 안 되며, 사전조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무다.

    - 사후조건(postcondition): 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건으로, 클라이언트가 사전조건을 만족시켰다면 메서드는 사후조건에 명시된 조건을 만족시켜야 한다. 만약 클라이언트가 사전조건을 만족시켰는데도 사후조건을 만족시키지 못한 경우에는 클라이언트에게 예외를 던져야 하며, 사후조건을 만족시키는 것은 서버의 의무다.
    - 불변식(invariant): 항상 참이라고 보장되는 서버의 조건으로, 메서드가 실행되는 도중에는 불변식을 만족시키지 못할 수도 있지만 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이어야 한다.

  - 위 세 가지 요소를 기술할 때는 실행 절차를 기술할 필요 없이 상태 변경만을 명시하기 때문에 코드를 이해하고 분석하기 쉬워진다.

    - 클라이언트 개발자는 사전조건에 명시된 조건을 만족시키지 않으면 메서드가 실행되지 않을 것이라는 사실을 잘 알고 있다.
    - 불변식을 사용하면 클래스의 의미를 쉽게 설명할 수 있고 클라이언트 개발자가 객체를 더욱 쉽게 예측할 수 있다.
    - 사후조건을 믿는다면 객체가 내부적으로 어떤 방식으로 동작하는지 걱정할 필요가 없다.
    - 세 요소에는 클라이언트 개발자가 알아야 하는 모든 것이 포함되어 있을 것이다.



- 사전조건

  - 사전조건이란 메서드가 정상적으로 실행되기 위해 만족해야 하는 조건이다.
    - 사전조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무다.
    - 따라서 사전조건을 만족시키지 못해서 메서드가 실행되지 않을 경우 클라이언트에 버그가 있다는 것을 의미한다.
    - 사전조건이 만족되지 않을 경우 서버는 메서드를 실행할 의무가 없다.
  - 일반적으로 사전조건은 메서드에 전달된 인자의 정합성을 체크하기 위해 사용된다.
    - 예를 들어 특정 인자는 null이어서는 안 되고, 특정 인자는 1 이상의 값이어야 한다는 것 등이 있을 수 있다.
    - 이러한 조건들을 메서드의 사전조건으로 정의함으로써 메서드가 잘못된 값을 기반으로 실행되는 것을 방지할 수 있다.
  - 예시
    - Code Contracts에서 제공하는 대부분의 메서드는 사전조건을 정의하기 위한 `Contract.Requires` 메서드를 제공한다.

  ```c#
  public Reservation Reserve(Customer customer, int audienceCount)
  {
      Contract.Requires(customer != null);
      Contract.Requires(audienceCount >= 1);
      return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
  }
  ```

  - 위 예시에서 사전조건을 만족시킬 책임은 Reserve메서드를 호출하는 클라이언트에게 있다는 것을 기억해야한다.
    - 클라이언트가 사전조건을 만족시키지 못할 경우 `Reserve`