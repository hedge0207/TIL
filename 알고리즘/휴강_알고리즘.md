- 좋은 알고리즘
  - 정확성: 얼마나 정확하게 동작하는가
  - 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  - 메모리 사용량: 얼마나 적은 메모리를 사용하는가
  - 단순성: 얼마나 단순한가
  - 최적성: 더 이상 개선할 여지없이 최적화되었는가

- 파이썬에서 음수의 나눗셈

  ```python
  a,b = -3,2
  print(a//b)
  print(int(a/b))
  if a<0:
  	print(-(abs(a)//b))
  
  #a//b의 경우 결과값이 다르게 나온다. 따라서 파이썬에서 음수의 나눗셈을 할 경우 다른 두 경우와 같이 해주는 것이 좋다.
  out
  -2
  -1
  -1
  ```

  

cf. 이차배열 형성할 때 주의 점

```python
arr = [[0]*3]*3 #이와 같이 생성하면 안되는데 그 이유는
arr[0][0] = 1
arr[0][1] = 2
arr[0][2] = 3
print(arr)

out
[[1,2,3],[1,2,3],[1,2,3]] #이처럼 출력된다.
#즉 원본 을 그대로 복사해서 적용되기에 이처럼 이차배열을 설정해선 안된다.

따라서 아래와 같이 생성해야 한다.
arr = [[0]*3 for _ in range(3)]
```



cf. 배열의 인덱스 설정을 위해 범위를 설정할 때(e.g. 미로 문제에서 범위를 벗어날 경우의 처리) 인덱스를 활용한 조건을 함께 써준다면, 반드시 범위 관련 설정을 먼저 써야 한다.

```python
if nr>=N or nr<0 or nc>=N or nc<0 and visited[nr][nc]==0:

#만일 위와 같은 코드를 아래와 같이 쓰면 인덱스 에러가 날 수 있다.

if visited[nr][nc]==0 and nr>=N or nr<0 or nc>=N or nc<0:
    
and는 앞에서부터 참거짓을 판별하여 앞의 조건이 거짓이면 뒤의 조건은 판별하지 않고 False를 반환한다.
만일 nr이나 nc가 범위를 벗어난 값일 경우 첫 번째 코드처럼 쓰면 뒤의 visited[nr][nc]==0은 처리되지 않고 넘어간다. 그러나 두 번째 코드처럼 쓰면 우선 앞의 if visited[nr][nc]==0를 먼저 판별하는데 만일 nr이나 nc가 범위를 벗어난 값이었다면 인덱스 에러가 발생하게 된다.
```





- 부분집합 관련 배경지식

  - 집합의 원소가 n개일 때, 공집합을 포함하는 부분집합의 수는 2<sup>n</sup>개이다.
  - 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모두 원소에 적용한 경우의 수와 같다.

- 비트 연산자

  - 작은 값의 10진수를 2진수로 빠르게 변환하는 방법은 해당 값이 어떤 2의 n승들을 더해서 구성되는지 알면 된다. 예를 들어 10은 2의 3승인 8과 2의 1승인 1로 구성되므로 1010과 같이 쓸 수 있고 6은 2의 2승인 4와 2의 1승인 1로 구성되므로 110과 같이 쓸 수 있다. 

  - 1<<n은 2<sup>n</sup>과 같다.  a<<1은 a에 2를 곱하는 것과 같다. a>>1은 a에 2를 나눈는 것과 같다.

    - 따라서 부분집합을 구할 때도 많이 사용한다.

    ```python
    arr = [3,6,7,1,5,4]
    n = len(arr)          #n : 원소의 개수
    for i in range(1<<n):  #1<<n: 부분 집합의 개수(64)
        #i는 0~63까지의 값을 가진다. 2진수로는 000000~111111(10진수로 63)까지의 값을 가진다.
        for j in range(n): #원소의 수만큼 비트를 비교함
            if i & (1<<j):  #i의 j번째 비트가 0이 아니면 j번째 원소 출력
                print(arr[j],end=", ")
        print()
     
    #원리
    #n=6이므로 000000부터 111111까지 6자리 2진수를 가지게 된다.
    #즉, 2**5,2**4,2**3,2**2,2**1,2**0의 2진수가 만들어지게 된다.
    #n=6이므로 arr의 인덱스도 0~5까지 존재하게 된다.
    #그러므로 2의 제곱과 arr의 인데스가 0~5로 일치하므로 제곱에 인덱스를 대응시킬 수 있게 된다.
    #만일 0,2,4번 인덱스에 해당하는 값으로 이루어진 부분집합 [3,7,5]가 있다면
    #2**0, 2**2, 2**4의 비트값이 1이 되는 것이므로 2진수로는 010101이된다.
    
    #즉 정리하자면 000000~111111까지의 모든 2진수를 전부 탐색하면서 각 2진수의 비트를 리스트의 인덱스에 대응시키는 방식이다.
    #좀 더 작은 리스트로 예를 들어 보면
    brr = [1,2,3]
    n = len(brr)
    result = []
    for i in range(1<<n):
        temp = []
        for j in range(n):
            if i & (1<<j):
                temp.append(brr[j])
        result.append(temp)
    print(result)
    
    out
    [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
    
    
    #000~111까지의 2진수를 모두 나열하면 다음과 같다
    #000,001,010,100,011,110,101,111
    #이를 각 인덱스에 대응시키면 
    #[],[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]이와 같이 된다.
    #위 코드에서 i 가 6인 경우를 예로 들면 6은 2진수로 110이므로
    #j = 0일때 110의 첫 번째 비트값은 0이므로 brr[0]은 temp에 담기지 않는다.
    #j = 1일때 110의 두 번째 비트값은 1이므로 brr[1]은 temp에 담긴다.
    #j = 2일때 110의 세 번째 비트값은 1이므로 brr[2]는 temp에 담긴다.
    #결국 [2,3]이라는 부분집합이 나오게 된다.
    ```

    

    - 2를 곱하거나 나누는 코드를 작성해야 할때 *연산자나 /연산자를 사용하는 것 보다,  >>나 <<연산자를 사용하는 것이 훨씬 실행 속도가 빠르다.

    ```python
    a = 10
    print(a<<1)
    print(a>>1)
    
    out 
    20
    5
    #위와 같은 결과가 나오는 이유
    #10을 2진수로 변환하면 1010이다. 이 때 <<1을 해주면
    #10100이 되고 이를 10진수로 변환하면 20이 된다.
    #결국 x<<n은 x에 2**n을 곱한 것과 같은 결과가 나오게 된다(x*2**n).
    
    #반대로 10을 2진수로 변환한 1010에 >>1을 해주면
    #101이 되고 이를 10진수로 변환하면 5가 된다.
    #결국 x>>n은 x에 2**n을 나눈 것과 같은 결과가 나오게 된다(x/2**n).
    ```

  - &는 합집합 연산자로 i&(1<<j)와 같이 쓰면 i의  j번째 비트가 1인이 아닌지를 알 수 있다.

    ```python
    #0이 나오면 비트가0, 다른 숫자가 나오면 비트가1인 것이다.
    print(10&(1<<3))
    print(10&(1<<2))
    print(10&(1<<1))
    print(10&(1<<0))
    
    out
    8
    0
    2
    0
    ```

  - 또한 2진수 표현을 통해 홀짝 판단이 가능하다.

    - 2\*\*0은 1인데 2\*\*0의 비트값이 1이면 홀수, 0이면 짝수가 된다.
    - 홀짝 판단을 할때 보통 2로 나눠서 나머지가 있는지를 보는 방식을 쓰는데 그 방식보다 아래 방식이 훨씬 빠르게 수행된다.

    ```python
    if 6&1:    
        print('홀수')
    else:
        print('짝수')
    
    if 5&1:    
        print('홀수')
    else:
        print('짝수')
    
    out
    짝수
    홀수
    #6은 2진수로 110이고 1은 2진수로 1이다.
    #이를 다르게 표현하면 6은 110이고 1은 001이라고 할수 있다 110과 001은 겹치는 것이 하나도 없다.
    #110
    #001
    #따라서 6은 짝수이다.
    #반면에 5는 2진수로 101인데 101과 001은 마지막 1이 겹친다.
    #따라서 5는 홀수이다.
    ```

    

- 해싱: 키를 통해 그 키값에 해당하는 밸류를 찾는 것을 해싱이라 부른다. 딕셔너리도 이에 해당한다.





- 컴퓨터의 문자 표현

  - 영어가 대소문자 합쳐서 모두 52자이므로 6비트(2**6=64)면 모두 표현할 수 있다.

  - 초기에는 지역마다 표현 방식이 모두 달랐으나 1967년 미국에서 ASCII(American Standard Code for Information Interchange)라는 문자 인코딩 표준이 제정됨.

  - ASCII

    - 7비트 인코딩으로 128문자를 표현한다. 128문자는 33개의 출력 불가능한 제어 문자들과 공백을 포함한 95개의 출력 가능한 문자들로 이루어져 있다.

    - 일일이 대응하는 값을 외울 필요는 없지만 몇 가지 규칙을 알고 있으면 편하다

      -숫자가 대문자보다 작은 코드에 배정되어 있으며 대문자는 소문자보다 작은 코드에 배정되어 있다.

      -또한 0~9, A~Z, a~z는 각각 코드 값이 1씩 증가해 나간다.

    - 확장 아스키는 표준 문자 이외의 악센트 문자, 도형문자, 특수문자, 특수기호 등 부가적인 문자 128가지를 추가할 수 있게 하는 부호이다.

      - 기존의 아스키 코드에 1비트를 추거하여 8비트를 사용(256개)

      - 표준화된 것은 아니고 개발자가 할당하고 싶은 문자를 할당할 수 있는 것이다. 따라서 다른 사람과의 공유가 어렵다.

  - 유니코드

    - 인터넷이 전 세계로 발전하면서 국가 간에 코드 체계가 다른 문제가 발생하였고 다국어 처리를 위해 또 다시 표준을 만들었는데 이를 유니코드라 한다.

    - 여러 체계가 존재한다.

      -utf-8(웹에서 주로 사용), uff-16(윈도우와 자바에서 사용), utf32(리눅스에서 사용) 등이 있다.



- 파이썬의 문자열 처리
  - 다른 언어와 달리 char 타입이 없다, char는 다른 언어에서 한 문자를 표현하기 위한 것이나 파이썬은 한 문자도 문자열에 넣으면 된다. 예를 들어 a라는 하나의 문자를 처리하기 위해서 다른 언어에서는 char 타입을 사용해야 하지만 파이썬은 그냥 'a'와 같이 해주면 된다.
  - 문자열은 요소값을 변경 할 수 없다(immutable).



- 패턴 매칭: 주어진 패턴과 동일한 패턴을 찾는 문제

  - 일반적으로 주어진 패턴을 P 또는 p로 정의하고 그 길이를 M또는 m으로 정의하며 패턴의 인덱스를 j로 정의한다. 또한 패턴을 찾을 텍스트를 T또는t로 정의하고 그 길이를 N또는 n으로 정의하며 텍스트의 인덱스를 i로 정의한다. 

  - 내장함수가 존재한다(.find()).

    ```python
    P = "asd"
    M = len(P)
    T = "dgrgrloskmdoasdlgrpr"
    N = len(T)
    
    idx=T.find(P)  #해당 패턴이 시작하는 위치를 리턴해준다. 없을 경우 -1리턴
    print(idx, T[idx:idx+M])
    
    out
    12 asd
    ```

  - 고지식한 알고리즘: 주어진 패턴과 본문을 일일이 비교하여 찾는 것, 시간복잡도는 O(MN)

    ```python
    P = "asd"
    M = len(P)
    T = "dgrgrloskmdoasdlgrpr"
    N = len(T)
    
    #while문ver
    i = 0
    j = 0
    while i<N:
        if T[i]==P[j]:
            i+=1
            j+=1
            if j==M:
                print(i-j)  #패턴이 시작되는 인덱스를 출력
                j=0 #일치하는 패턴이 또 있을 수 있으므로 다시 j를 0으로 초기화
        else:
            i=i-j+1
            j=0
        
      
    #for문ver(주로 while로 작성하긴 한다)
    for i in range(N-M+1):
        for j in range(M):
            if P[i]!=T[i+j]:
                break
            else:
                print(i)
                i+=m #시작위치부터 m까지는 찾는 의미가 없으므로 +m해준다.
    ```

  

  - KMP알고리즘(이 알고리즘을 발견한 3명의 이름 첫자를 딴 것이다)

    - 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행, 시간복잡도는O(N+M)
    - 여기서는 구현은 하지 않고 아이디어만 살펴본다.

    ```
    p='klmno'
    t="abcklmndefghijklmnop"
    을 비교한다고 했을 때
    
    #고지식한 알고리즘으로 풀 때
    a b c k l m n | d e f g h i j k l m n o p
          k l m n | o     #불일치가 발생했으므로 다음과 같이 한 칸씩 옆으로 민다.
            k l m | n o       -> 1)
              k l | m n o     -> 2)
                k | l m n o   -> 3)
                       
    1)만일 |앞의 패턴인 klm과 그에 대응하는 텍스트인 lmn이 일치할 경우에만 이 단계를 비교하는 것이 의미가 있다.
    2)| 앞의 패턴인 kl과 그에 대응하는 텍스트인 mn이 일치할 경우에만 이 단계를 비교하난 것이 의미가 있다.
    3)| 앞의 패턴인 k와 그에 대응하는 텍스트인 n이 일치하는 경우에만 이 단계를 비교하는 것이 의미가 있다.
    ∴쓸데 없는 3번의 반복을 하는 셈이다.
    
    여기서 앞의 패턴인 klm,kl, k를 접두어, 그에 대응하는 텍스트인 lmn,mn,n을 접미어라 부른다.
    즉, 접두어와 접미어가 일치할 때에만 비교하는 의미가 있다.
    
    
    
    # KMP알고리즘
    따라서 klm과 그에 대응하는 텍스트인 lmn이 일치할 경우, kl과 그에 대응하는 텍스트인 mn이 일치할 경우, k와 그에 대응하는 텍스트인 n이 일치하는 경우에만 비교를 하는 것이 KMP알고리즘이다.
    따라서 이 경우 
    a b c k l m n | d e f g h i j k l m n o p
          k l m n | o 에서
          			k l m n o로 바로 건너뛴다.
    만일 접두어와 접미어가 일치할 경우
    T = ".....a b c d a b c d....."  
    P = "a b c d a b c e"
    .....a b c d a b c | d.....
    	 a b c d a b c | e d와 e의 불일치
    	   a b c d a b | c e 접두어(abcdab)와 접미어(bcbabc) 불일치로 비교X
    	     a b c d a | b c e 접두어(abcda)와 접미어(cdabc) 불일치로 비교X
    	       a b c d | a b c e 접두어(abcd)와 접미어(dabc) 불일치로 비교X
    	         a b c | d a b c e 접두어(abc)와 접미어(abc) 일치, 여기서 부터 비교 시작
    
    
    #위에서는 반복이 일어나는 것 처럼 설명했지만 실제 구현은 아래와 같이 바로 이동하게 된다.
    .....a b c d a b c | d.....  접미어 : abc
    	 a b c d a b c | e     이 위치에서 접미어와 접두어가 일치하는 위치로 옮기면
    	 		 a b c | d a b c e 접두어 : abc  여기서 부터 다시 반복을 시작한다.
    이 경우 텍스트의 인덱스 i는 불일치가 발생한 곳에서 이동할 필요가 없고, 패턴의 인덱스 j도 굳이 0으로 돌아갈 필요 없이 접두어 다음(위의 경우 3)으로 이동하면된다.
    	 		 
    	 		 
    
    만일 이 때 고지식한 알고리즘으로 푼다면
    .....a b c d a b c | d.....
    	 a b c d a b c | e          ->1
    	   	 a b c d a | b c e      ->2
    	   	   a b c d | a b c e    ->3
    	   	     a b c | d a b c e  #KMP알고리즘에선 하지 않았던 위 3번의 반복을 해야 한다.
    ```

  - 보이어-무어 알고리즘

    - 패턴의 인덱스만 오른쪽에서 왼쪽으로 비교, 텍스트와 패턴의 비교는 기존처럼 왼쪽에서 오른쪽으로.
    - 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
    - 패턴에 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이만큼 된다.
    - 보이어 무어 알고리즘은 KMP에서 살펴본 접미어 와 맨 마지막 단어 모두를 고려하는데 그 중 맨 마지막 단어만 고려하여 구현하는 심플한 버전을 보이어-무어-horspool 알고리즘 혹은 그냥 horspool알고리즘이라 부른다.

    ```
    T = "qwerqwerqwerasd"
    p = "asd"
    q w e r q w e r q w e r a s d
    a s d  #패턴의 오른쪽(d부터)부터 비교 시작e != d이고 패턴에 e가 없으므로 패턴의 길이 만큼 이동
          a s d  d!=w이고 패턴에 w가 없으므로 패턴의 길이만큼 이동
                a s d  똑같은 과정을 반복
          
     
    T = "qweqwewater"
    P = "water"
    q w e q w e w a t e r
          w a t e r #패턴의 오른쪽(r부터)부터 비교 시작, r과 a는 불일치하지만 패턴에 a가 존재는 함
                w a t e r  #a부터 비교 시작
    ```




- 재귀호출을 구현할 때 재귀호출 전에 쓴 내용은 순서대로 진행되고 뒤에 쓴 내용은 역순으로 진행된다.

  ```python
  def f(i,n)
  	if i==n:
          return
      print(i, "hello!") #순서대로 진행
      f(i+1,n)           #재귀함수를 기준으로
      print(i, "hello!") #역순으로 진행
      
  f(0,3)
  
  out
  0 hello!
  1 hello!
  2 hello!
  2 hello!
  1 hello!
  0 hello!
  ```

  

- 그래프 

  - 일반적으로 정점을 V로, 그 개수를 |V|로 표시하고, 간선을 M으로 간선의 개수를 |M|으로 표시함

  - 종류

    - 무향 그래프: 화살표가 없는 그래프, 동등한 관계, 양방통행이 가능한 관계
    - 유향 그래프: 화살표가 있는 그래프, 동등하지 않은 관계, 일방통행만 가능한 관계
    - 가중치 그래프: 그래프 사이의 관계에 가중치를 부여하는 그래프, 이동 시간, 비용 등
    - 사이클 없는 방향 그래프

  - 인접: 두 개의 정점 사이에 간선이 존재, 완전그래프는 가능한 간선이 모두 존재하는 경우를 말한다. 즉 모든 정점 사이에 간선이 존재하는 그래프이다.

    - 만일 유향그래프이고 1->2라면 1번은 2번 정점에 인접해있다고 하지만 2번은 1번 정점에 인접해 있지 않다.

  - 경로 중 한 정점을 최대 한 번만 지나는 경로를 단순경로라 한다.

  - 시작하 정점에서 끝나는 경로를 사이클이라고 한다.

  - 그래프의 표현

    - 인접행렬: |V|*|V|크기의 2차원 배열을 이용해서 간선 정보를 저장

      -만일 |V|가 5,000이면 총 25,000,000의 값을 저장할 2차 배열이 만들어지는데 |E|가 100,000이면 간선의 수에 비해 불필요하게 큰 2차배열을 만든 셈이 된다. 이럴 경우 공간도 낭비되고 25,000,000개의 값을 모두 뒤져야 하기에 굉장히 비효율적이다.

      ```
      간선이 있으면 1, 없으면 0
      v = [1,2,3]이고
      1-2
      1-3이면
      [[0,1,1] #1일 경우, 2,3과 간선이 있음
      [1,0,0]  #2일 경우  1과 간선이 있음
      [1,0,0]] #3일 경우  1과 간선이 있음
      ```

    - 인접 리스트: 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장

      ```python
    #input값, 첫 번째 줄에는 순서대로 V와 E의 개수가 주어지고 그 아래로 E개의 간선이 주어진다.
      7 8
      1 2   #무향 그래프
      1 3
      2 4
      2 5
      4 6
      5 6
      6 7
      3 7
      
      V, E = map(int,input().split())
      G = [[] for _ in range(V+1)] #정점은 7까지 있으므로 0번 인덱스는 비워 놓고 7번가지 표현							  하려면 +1을 해줘야 한다.
      for _ in range(E):
          u,v = map(int, input().split())
          G[u].append(v) #유향그래프이고 만일 u에서 v로만 갈 수 있다면 u에다 만 추가 하면 된다.
          G[v].append(u) #무향그래프이기에 u,v를 모두 추가해야한다.
      
      print(G)
      for i in range(1,V+1):
          print(i,G[i])
      
          
      out
      [[], [2, 3], [1, 4, 5], [1, 7], [2, 6], [2, 6], [4, 5, 7], [6, 3]]
      1 [2, 3]  #1번 노드는 2,3번과 연결
      2 [1, 4, 5]
      3 [1, 7]
      4 [2, 6]
      5 [2, 6]
      6 [4, 5, 7]
      7 [6, 3]
      ```
    
      
    
    - 간선의 배열: 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장 



- 부분집합과 같이 가상의 상태공간트리를 탐색하며 모든 경우의 수를 고려해보는 완전검색 문제를 풀 때,   매 단계를 선택의 과정으로 생각하는 것이 좋다.
  - 예를 들어 [1,2,3]의 부분집합을 구할 경우 n번째 원소가 들어가는 경우와 들어가지 않는 경우의 2가지 경우의 수가 있다. 따라서 최종적으로 부분집합의 개수는 2<sup>n</sup>개가 있게 된다.
  - 가위바위보를 하는 경우를 생각해 보면 가위바위보는 경우의 수가 3개 이므로 n번 했을 때 나올 수 있는 경우의 수는 3<sup>n</sup>이 된다.
  - 즉 가상의 상태공간 트리는 가위를 선택한 경우, 바위를 선택한 경우, 보를 선택한 경우로 매 선택마다 나뉘게 된다.
  - 이렇게 어떤 선택들을 해야 모든 경우를 탐색할 수 있을지를 생각하면서 문제를 푸는 것이 좋다.





# Queue

- 일반적으로 Queue에서 자료가 마지막으로 삽입된 곳을 rear, 마지막으로 빠진 곳을 front라 한다. 

- 큐의 사용을 위해 필요한 연산

  > 보통 함수의 이름을 아래와 같이 정의하여 사용한다. 함수명은 정의하는 사람 마음이지만 아래와 같이 정의했을 경우 모르는 사람이 봐도 Queue를 사용하고 있다는 것을 바로 알 수 있다는 장점이 있다.

  - enQueue(item): 큐의 뒤쪽(rear)에 원소를 삽입
  - deQueue(): 큐의 앞쪽(front)에 원소를 삭제하고 반환
  - createQueue():공백 상태의 큐를 생성
  - isEmpty():큐가 공백 상태인지 확인
  - isFull(): 큐가 포화 상태인지 확인
  - Qpeek(): 큐의 앞쪽에서 원소를 삭제 없이 반환





# Linked list

- 단일 연결 리스트에서 삽입, 삭제를 할 때에는 앞 쪽에 있는 노드에 대한 정보를 알아야 한다. 따라서 앞 쪽 노드에 대한 정보 탐색을 가장 먼저 해야 한다.

  - 각 노드는 데이터 필드와 다음 노드에 대한 주소를 가지고 있다.

  - 즉 이전 노드에는 다음 노드에 대한 주소가 존재한다.

  - 만일 새로운 노드를 추가하고자 한다면 앞의 노드가 가리키는 노드를 새로운 노드가 가르키도록 변경하고 앞쪽 노드는 추가한 노드를 가리키게 한다. 즉, 둘 다 앞 쪽 노드를 알아야 가능하다.

  - 삭제도 마찬가지로 앞쪽 노드가 가르키는 노드를 삭제할 노드가 가르키는 노드로 변경하면 된다.

    ex. 서울-부산이 있을 때 중간에 대전을 추가하고 싶다면 우선 첫 번째로 서울이 가리키는 부산이라는 주소를 읽어와서 대전의 주소로 만들고 서울이 가리키는 주소를 대전으로 변경한다. 만일 서울-대전-부산에서 대전을 빼고 싶다면 서울이 카르키던 대전을 부산으로 바꾸면 된다.

    

- 연결 리스트에서 뭘 먼저 연결해야 할지 헷갈린다면 삽입해야 할 노드의 주소를 먼저 수정하는 것이 안전하다.



- 삽입정렬(배열의 요소 별로 배열을 쭉 순회하면서 요소보다 작은 값과 큰 값 사이에 해당 요소를 삽입하여 정렬하는 방식)은 연결리스트로 구현하는 것이 더 효율적이다.
  - 일반리스트의 경우 삽입 후 삽입한 위치 뒤의 요소들은 모두 한 칸씩 뒤로 밀어야 한다는 단점이 있다.
  - 연결리스트로 구현하면 앞뒤 요소와 연결만 해주면 된다.

 

- 병합정렬 역시 연결 리스트로 구현하면 더 효율적이다.



- 원형 연결리스트는 원형이기에 tail은 잘 쓰지 않는다. head는 원형 연결 리스트의 시작점을 의미한다.
  - 모든 노드의 next와 prev에 None이 존재하지 않는다.

