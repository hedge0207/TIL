- 좋은 알고리즘
  - 정확성: 얼마나 정확하게 동작하는가
  - 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  - 메모리 사용량: 얼마나 적은 메모리를 사용하는가
  - 단순성: 얼마나 단순한가
  - 최적성: 더 이상 개선할 여지없이 최적화되었는가

- 파이썬에서 음수의 나눗셈

  ```python
  a,b = -3,2
  print(a//b)
  print(int(a/b))
  if a<0:
  	print(-(abs(a)//b))
  
  #a//b의 경우 결과값이 다르게 나온다. 따라서 파이썬에서 음수의 나눗셈을 할 경우 다른 두 경우와 같이 해주는 것이 좋다.
  out
  -2
  -1
  -1
  ```

  

cf. 이차배열 형성할 때 주의 점

```python
arr = [[0]*3]*3 #이와 같이 생성하면 안되는데 그 이유는
arr[0][0] = 1
arr[0][1] = 2
arr[0][2] = 3
print(arr)

out
[[1,2,3],[1,2,3],[1,2,3]] #이처럼 출력된다.
#즉 원본 을 그대로 복사해서 적용되기에 이처럼 이차배열을 설정해선 안된다.

따라서 아래와 같이 생성해야 한다.
arr = [[0]*3 for _ in range(3)]
```



cf. 배열의 인덱스 설정을 위해 범위를 설정할 때(e.g. 미로 문제에서 범위를 벗어날 경우의 처리) 인덱스를 활용한 조건을 함께 써준다면, 반드시 범위 관련 설정을 먼저 써야 한다.

```python
if nr>=N or nr<0 or nc>=N or nc<0 and visited[nr][nc]==0:

#만일 위와 같은 코드를 아래와 같이 쓰면 인덱스 에러가 날 수 있다.

if visited[nr][nc]==0 and nr>=N or nr<0 or nc>=N or nc<0:
    
and는 앞에서부터 참거짓을 판별하여 앞의 조건이 거짓이면 뒤의 조건은 판별하지 않고 False를 반환한다.
만일 nr이나 nc가 범위를 벗어난 값일 경우 첫 번째 코드처럼 쓰면 뒤의 visited[nr][nc]==0은 처리되지 않고 넘어간다. 그러나 두 번째 코드처럼 쓰면 우선 앞의 if visited[nr][nc]==0를 먼저 판별하는데 만일 nr이나 nc가 범위를 벗어난 값이었다면 인덱스 에러가 발생하게 된다.
```





- 부분집합 관련 배경지식

  - 집합의 원소가 n개일 때, 공집합을 포함하는 부분집합의 수는 2<sup>n</sup>개이다.
  - 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모두 원소에 적용한 경우의 수와 같다.

- 비트 연산자

  - 작은 값의 10진수를 2진수로 빠르게 변환하는 방법은 해당 값이 어떤 2의 n승들을 더해서 구성되는지 알면 된다. 예를 들어 10은 2의 3승인 8과 2의 1승인 1로 구성되므로 1010과 같이 쓸 수 있고 6은 2의 2승인 4와 2의 1승인 1로 구성되므로 110과 같이 쓸 수 있다. 

  - 1<<n은 2<sup>n</sup>과 같다.  a<<1은 a에 2를 곱하는 것과 같다. a>>1은 a에 2를 나눈는 것과 같다.

    - 따라서 부분집합을 구할 때도 많이 사용한다.

    ```python
    arr = [3,6,7,1,5,4]
    n = len(arr)          #n : 원소의 개수
    for i in range(1<<n):  #1<<n: 부분 집합의 개수(64)
        #i는 0~63까지의 값을 가진다. 2진수로는 000000~111111(10진수로 63)까지의 값을 가진다.
        for j in range(n): #원소의 수만큼 비트를 비교함
            if i & (1<<j):  #i의 j번째 비트가 0이 아니면 j번째 원소 출력
                print(arr[j],end=", ")
        print()
     
    #원리
    #n=6이므로 000000부터 111111까지 6자리 2진수를 가지게 된다.
    #즉, 2**5,2**4,2**3,2**2,2**1,2**0의 2진수가 만들어지게 된다.
    #n=6이므로 arr의 인덱스도 0~5까지 존재하게 된다.
    #그러므로 2의 제곱과 arr의 인데스가 0~5로 일치하므로 제곱에 인덱스를 대응시킬 수 있게 된다.
    #만일 0,2,4번 인덱스에 해당하는 값으로 이루어진 부분집합 [3,7,5]가 있다면
    #2**0, 2**2, 2**4의 비트값이 1이 되는 것이므로 2진수로는 010101이된다.
    
    #즉 정리하자면 000000~111111까지의 모든 2진수를 전부 탐색하면서 각 2진수의 비트를 리스트의 인덱스에 대응시키는 방식이다.
    #좀 더 작은 리스트로 예를 들어 보면
    brr = [1,2,3]
    n = len(brr)
    result = []
    for i in range(1<<n):
        temp = []
        for j in range(n):
            if i & (1<<j):
                temp.append(brr[j])
        result.append(temp)
    print(result)
    
    out
    [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
    
    
    #000~111까지의 2진수를 모두 나열하면 다음과 같다
    #000,001,010,100,011,110,101,111
    #이를 각 인덱스에 대응시키면 
    #[],[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]이와 같이 된다.
    #위 코드에서 i 가 6인 경우를 예로 들면 6은 2진수로 110이므로
    #j = 0일때 110의 첫 번째 비트값은 0이므로 brr[0]은 temp에 담기지 않는다.
    #j = 1일때 110의 두 번째 비트값은 1이므로 brr[1]은 temp에 담긴다.
    #j = 2일때 110의 세 번째 비트값은 1이므로 brr[2]는 temp에 담긴다.
    #결국 [2,3]이라는 부분집합이 나오게 된다.
    ```

    

    - 2를 곱하거나 나누는 코드를 작성해야 할때 *연산자나 /연산자를 사용하는 것 보다,  >>나 <<연산자를 사용하는 것이 훨씬 실행 속도가 빠르다.

    ```python
    a = 10
    print(a<<1)
    print(a>>1)
    
    out 
    20
    5
    #위와 같은 결과가 나오는 이유
    #10을 2진수로 변환하면 1010이다. 이 때 <<1을 해주면
    #10100이 되고 이를 10진수로 변환하면 20이 된다.
    #결국 x<<n은 x에 2**n을 곱한 것과 같은 결과가 나오게 된다(x*2**n).
    
    #반대로 10을 2진수로 변환한 1010에 >>1을 해주면
    #101이 되고 이를 10진수로 변환하면 5가 된다.
    #결국 x>>n은 x에 2**n을 나눈 것과 같은 결과가 나오게 된다(x/2**n).
    ```

  - &는 합집합 연산자로 i&(1<<j)와 같이 쓰면 i의  j번째 비트가 1인이 아닌지를 알 수 있다.

    ```python
    #0이 나오면 비트가0, 다른 숫자가 나오면 비트가1인 것이다.
    print(10&(1<<3))
    print(10&(1<<2))
    print(10&(1<<1))
    print(10&(1<<0))
    
    out
    8
    0
    2
    0
    ```

  - 또한 2진수 표현을 통해 홀짝 판단이 가능하다.

    - 2\*\*0은 1인데 2\*\*0의 비트값이 1이면 홀수, 0이면 짝수가 된다.
    - 홀짝 판단을 할때 보통 2로 나눠서 나머지가 있는지를 보는 방식을 쓰는데 그 방식보다 아래 방식이 훨씬 빠르게 수행된다.

    ```python
    if 6&1:    
        print('홀수')
    else:
        print('짝수')
    
    if 5&1:    
        print('홀수')
    else:
        print('짝수')
    
    out
    짝수
    홀수
    #6은 2진수로 110이고 1은 2진수로 1이다.
    #이를 다르게 표현하면 6은 110이고 1은 001이라고 할수 있다 110과 001은 겹치는 것이 하나도 없다.
    #110
    #001
    #따라서 6은 짝수이다.
    #반면에 5는 2진수로 101인데 101과 001은 마지막 1이 겹친다.
    #따라서 5는 홀수이다.
    ```

    

- 해싱: 키를 통해 그 키값에 해당하는 밸류를 찾는 것을 해싱이라 부른다. 딕셔너리도 이에 해당한다.





- 컴퓨터의 문자 표현

  - 영어가 대소문자 합쳐서 모두 52자이므로 6비트(2**6=64)면 모두 표현할 수 있다.

  - 초기에는 지역마다 표현 방식이 모두 달랐으나 1967년 미국에서 ASCII(American Standard Code for Information Interchange)라는 문자 인코딩 표준이 제정됨.

  - ASCII

    - 7비트 인코딩으로 128문자를 표현한다. 128문자는 33개의 출력 불가능한 제어 문자들과 공백을 포함한 95개의 출력 가능한 문자들로 이루어져 있다.

    - 일일이 대응하는 값을 외울 필요는 없지만 몇 가지 규칙을 알고 있으면 편하다

      -숫자가 대문자보다 작은 코드에 배정되어 있으며 대문자는 소문자보다 작은 코드에 배정되어 있다.

      -또한 0~9, A~Z, a~z는 각각 코드 값이 1씩 증가해 나간다.

    - 확장 아스키는 표준 문자 이외의 악센트 문자, 도형문자, 특수문자, 특수기호 등 부가적인 문자 128가지를 추가할 수 있게 하는 부호이다.

      - 기존의 아스키 코드에 1비트를 추거하여 8비트를 사용(256개)

      - 표준화된 것은 아니고 개발자가 할당하고 싶은 문자를 할당할 수 있는 것이다. 따라서 다른 사람과의 공유가 어렵다.

  - 유니코드

    - 인터넷이 전 세계로 발전하면서 국가 간에 코드 체계가 다른 문제가 발생하였고 다국어 처리를 위해 또 다시 표준을 만들었는데 이를 유니코드라 한다.

    - 여러 체계가 존재한다.

      -utf-8(웹에서 주로 사용), uff-16(윈도우와 자바에서 사용), utf32(리눅스에서 사용) 등이 있다.



- 파이썬의 문자열 처리
  - 다른 언어와 달리 char 타입이 없다, char는 다른 언어에서 한 문자를 표현하기 위한 것이나 파이썬은 한 문자도 문자열에 넣으면 된다. 예를 들어 a라는 하나의 문자를 처리하기 위해서 다른 언어에서는 char 타입을 사용해야 하지만 파이썬은 그냥 'a'와 같이 해주면 된다.
  - 문자열은 요소값을 변경 할 수 없다(immutable).



- 패턴 매칭: 주어진 패턴과 동일한 패턴을 찾는 문제

  - 일반적으로 주어진 패턴을 P 또는 p로 정의하고 그 길이를 M또는 m으로 정의하며 패턴의 인덱스를 j로 정의한다. 또한 패턴을 찾을 텍스트를 T또는t로 정의하고 그 길이를 N또는 n으로 정의하며 텍스트의 인덱스를 i로 정의한다. 

  - 내장함수가 존재한다(.find()).

    ```python
    P = "asd"
    M = len(P)
    T = "dgrgrloskmdoasdlgrpr"
    N = len(T)
    
    idx=T.find(P)  #해당 패턴이 시작하는 위치를 리턴해준다. 없을 경우 -1리턴
    print(idx, T[idx:idx+M])
    
    out
    12 asd
    ```

  - 고지식한 알고리즘: 주어진 패턴과 본문을 일일이 비교하여 찾는 것, 시간복잡도는 O(MN)

    ```python
    P = "asd"
    M = len(P)
    T = "dgrgrloskmdoasdlgrpr"
    N = len(T)
    
    #while문ver
    i = 0
    j = 0
    while i<N:
        if T[i]==P[j]:
            i+=1
            j+=1
            if j==M:
                print(i-j)  #패턴이 시작되는 인덱스를 출력
                j=0 #일치하는 패턴이 또 있을 수 있으므로 다시 j를 0으로 초기화
        else:
            i=i-j+1
            j=0
        
      
    #for문ver(주로 while로 작성하긴 한다)
    for i in range(N-M+1):
        for j in range(M):
            if P[i]!=T[i+j]:
                break
            else:
                print(i)
                i+=m #시작위치부터 m까지는 찾는 의미가 없으므로 +m해준다.
    ```

  

  - KMP알고리즘(이 알고리즘을 발견한 3명의 이름 첫자를 딴 것이다)

    - 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행, 시간복잡도는O(N+M)
    - 여기서는 구현은 하지 않고 아이디어만 살펴본다.

    ```
    p='klmno'
    t="abcklmndefghijklmnop"
    을 비교한다고 했을 때
    
    #고지식한 알고리즘으로 풀 때
    a b c k l m n | d e f g h i j k l m n o p
          k l m n | o     #불일치가 발생했으므로 다음과 같이 한 칸씩 옆으로 민다.
            k l m | n o       -> 1)
              k l | m n o     -> 2)
                k | l m n o   -> 3)
                       
    1)만일 |앞의 패턴인 klm과 그에 대응하는 텍스트인 lmn이 일치할 경우에만 이 단계를 비교하는 것이 의미가 있다.
    2)| 앞의 패턴인 kl과 그에 대응하는 텍스트인 mn이 일치할 경우에만 이 단계를 비교하난 것이 의미가 있다.
    3)| 앞의 패턴인 k와 그에 대응하는 텍스트인 n이 일치하는 경우에만 이 단계를 비교하는 것이 의미가 있다.
    ∴쓸데 없는 3번의 반복을 하는 셈이다.
    
    여기서 앞의 패턴인 klm,kl, k를 접두어, 그에 대응하는 텍스트인 lmn,mn,n을 접미어라 부른다.
    즉, 접두어와 접미어가 일치할 때에만 비교하는 의미가 있다.
    
    
    
    # KMP알고리즘
    따라서 klm과 그에 대응하는 텍스트인 lmn이 일치할 경우, kl과 그에 대응하는 텍스트인 mn이 일치할 경우, k와 그에 대응하는 텍스트인 n이 일치하는 경우에만 비교를 하는 것이 KMP알고리즘이다.
    따라서 이 경우 
    a b c k l m n | d e f g h i j k l m n o p
          k l m n | o 에서
          			k l m n o로 바로 건너뛴다.
    만일 접두어와 접미어가 일치할 경우
    T = ".....a b c d a b c d....."  
    P = "a b c d a b c e"
    .....a b c d a b c | d.....
    	 a b c d a b c | e d와 e의 불일치
    	   a b c d a b | c e 접두어(abcdab)와 접미어(bcbabc) 불일치로 비교X
    	     a b c d a | b c e 접두어(abcda)와 접미어(cdabc) 불일치로 비교X
    	       a b c d | a b c e 접두어(abcd)와 접미어(dabc) 불일치로 비교X
    	         a b c | d a b c e 접두어(abc)와 접미어(abc) 일치, 여기서 부터 비교 시작
    
    
    #위에서는 반복이 일어나는 것 처럼 설명했지만 실제 구현은 아래와 같이 바로 이동하게 된다.
    .....a b c d a b c | d.....  접미어 : abc
    	 a b c d a b c | e     이 위치에서 접미어와 접두어가 일치하는 위치로 옮기면
    	 		 a b c | d a b c e 접두어 : abc  여기서 부터 다시 반복을 시작한다.
    이 경우 텍스트의 인덱스 i는 불일치가 발생한 곳에서 이동할 필요가 없고, 패턴의 인덱스 j도 굳이 0으로 돌아갈 필요 없이 접두어 다음(위의 경우 3)으로 이동하면된다.
    	 		 
    	 		 
    
    만일 이 때 고지식한 알고리즘으로 푼다면
    .....a b c d a b c | d.....
    	 a b c d a b c | e          ->1
    	   	 a b c d a | b c e      ->2
    	   	   a b c d | a b c e    ->3
    	   	     a b c | d a b c e  #KMP알고리즘에선 하지 않았던 위 3번의 반복을 해야 한다.
    ```

  - 보이어-무어 알고리즘

    - 패턴의 인덱스만 오른쪽에서 왼쪽으로 비교, 텍스트와 패턴의 비교는 기존처럼 왼쪽에서 오른쪽으로.
    - 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
    - 패턴에 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이만큼 된다.
    - 보이어 무어 알고리즘은 KMP에서 살펴본 접미어 와 맨 마지막 단어 모두를 고려하는데 그 중 맨 마지막 단어만 고려하여 구현하는 심플한 버전을 보이어-무어-horspool 알고리즘 혹은 그냥 horspool알고리즘이라 부른다.

    ```
    T = "qwerqwerqwerasd"
    p = "asd"
    q w e r q w e r q w e r a s d
    a s d  #패턴의 오른쪽(d부터)부터 비교 시작e != d이고 패턴에 e가 없으므로 패턴의 길이 만큼 이동
          a s d  d!=w이고 패턴에 w가 없으므로 패턴의 길이만큼 이동
                a s d  똑같은 과정을 반복
          
     
    T = "qweqwewater"
    P = "water"
    q w e q w e w a t e r
          w a t e r #패턴의 오른쪽(r부터)부터 비교 시작, r과 a는 불일치하지만 패턴에 a가 존재는 함
                w a t e r  #a부터 비교 시작
    ```




- 재귀호출을 구현할 때 재귀호출 전에 쓴 내용은 순서대로 진행되고 뒤에 쓴 내용은 역순으로 진행된다.

  ```python
  def f(i,n)
  	if i==n:
          return
      print(i, "hello!") #순서대로 진행
      f(i+1,n)           #재귀함수를 기준으로
      print(i, "hello!") #역순으로 진행
      
  f(0,3)
  
  out
  0 hello!
  1 hello!
  2 hello!
  2 hello!
  1 hello!
  0 hello!
  ```

  

- 그래프 

  - 일반적으로 정점을 V로, 그 개수를 |V|로 표시하고, 간선을 M으로 간선의 개수를 |M|으로 표시함

  - 종류

    - 무향 그래프: 화살표가 없는 그래프, 동등한 관계, 양방통행이 가능한 관계
    - 유향 그래프: 화살표가 있는 그래프, 동등하지 않은 관계, 일방통행만 가능한 관계
    - 가중치 그래프: 그래프 사이의 관계에 가중치를 부여하는 그래프, 이동 시간, 비용 등
    - 사이클 없는 방향 그래프

  - 인접: 두 개의 정점 사이에 간선이 존재, 완전그래프는 가능한 간선이 모두 존재하는 경우를 말한다. 즉 모든 정점 사이에 간선이 존재하는 그래프이다.

    - 만일 유향그래프이고 1->2라면 1번은 2번 정점에 인접해있다고 하지만 2번은 1번 정점에 인접해 있지 않다.

  - 경로 중 한 정점을 최대 한 번만 지나는 경로를 단순경로라 한다.

  - 시작하 정점에서 끝나는 경로를 사이클이라고 한다.

  - 그래프의 표현

    - 인접행렬: |V|*|V|크기의 2차원 배열을 이용해서 간선 정보를 저장

      -만일 |V|가 5,000이면 총 25,000,000의 값을 저장할 2차 배열이 만들어지는데 |E|가 100,000이면 간선의 수에 비해 불필요하게 큰 2차배열을 만든 셈이 된다. 이럴 경우 공간도 낭비되고 25,000,000개의 값을 모두 뒤져야 하기에 굉장히 비효율적이다.

      ```
      간선이 있으면 1, 없으면 0
      v = [1,2,3]이고
      1-2
      1-3이면
      [[0,1,1] #1일 경우, 2,3과 간선이 있음
      [1,0,0]  #2일 경우  1과 간선이 있음
      [1,0,0]] #3일 경우  1과 간선이 있음
      ```

    - 인접 리스트: 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장

      ```python
    #input값, 첫 번째 줄에는 순서대로 V와 E의 개수가 주어지고 그 아래로 E개의 간선이 주어진다.
      7 8
      1 2   #무향 그래프
      1 3
      2 4
      2 5
      4 6
      5 6
      6 7
      3 7
      
      V, E = map(int,input().split())
      G = [[] for _ in range(V+1)] #정점은 7까지 있으므로 0번 인덱스는 비워 놓고 7번가지 표현							  하려면 +1을 해줘야 한다.
      for _ in range(E):
          u,v = map(int, input().split())
          G[u].append(v) #유향그래프이고 만일 u에서 v로만 갈 수 있다면 u에다 만 추가 하면 된다.
          G[v].append(u) #무향그래프이기에 u,v를 모두 추가해야한다.
      
      print(G)
      for i in range(1,V+1):
          print(i,G[i])
      
          
      out
      [[], [2, 3], [1, 4, 5], [1, 7], [2, 6], [2, 6], [4, 5, 7], [6, 3]]
      1 [2, 3]  #1번 노드는 2,3번과 연결
      2 [1, 4, 5]
      3 [1, 7]
      4 [2, 6]
      5 [2, 6]
      6 [4, 5, 7]
      7 [6, 3]
      ```
    
      
    
    - 간선의 배열: 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장 



- 부분집합과 같이 가상의 상태공간트리를 탐색하며 모든 경우의 수를 고려해보는 완전검색 문제를 풀 때,   매 단계를 선택의 과정으로 생각하는 것이 좋다.
  - 예를 들어 [1,2,3]의 부분집합을 구할 경우 n번째 원소가 들어가는 경우와 들어가지 않는 경우의 2가지 경우의 수가 있다. 따라서 최종적으로 부분집합의 개수는 2<sup>n</sup>개가 있게 된다.
  - 가위바위보를 하는 경우를 생각해 보면 가위바위보는 경우의 수가 3개 이므로 n번 했을 때 나올 수 있는 경우의 수는 3<sup>n</sup>이 된다.
  - 즉 가상의 상태공간 트리는 가위를 선택한 경우, 바위를 선택한 경우, 보를 선택한 경우로 매 선택마다 나뉘게 된다.
  - 이렇게 어떤 선택들을 해야 모든 경우를 탐색할 수 있을지를 생각하면서 문제를 푸는 것이 좋다.





# Queue

- 일반적으로 Queue에서 자료가 마지막으로 삽입된 곳을 rear, 마지막으로 빠진 곳을 front라 한다. 

- 큐의 사용을 위해 필요한 연산

  > 보통 함수의 이름을 아래와 같이 정의하여 사용한다. 함수명은 정의하는 사람 마음이지만 아래와 같이 정의했을 경우 모르는 사람이 봐도 Queue를 사용하고 있다는 것을 바로 알 수 있다는 장점이 있다.

  - enQueue(item): 큐의 뒤쪽(rear)에 원소를 삽입
  - deQueue(): 큐의 앞쪽(front)에 원소를 삭제하고 반환
  - createQueue():공백 상태의 큐를 생성
  - isEmpty():큐가 공백 상태인지 확인
  - isFull(): 큐가 포화 상태인지 확인
  - Qpeek(): 큐의 앞쪽에서 원소를 삭제 없이 반환





# Linked list

- 단일 연결 리스트에서 삽입, 삭제를 할 때에는 앞 쪽에 있는 노드에 대한 정보를 알아야 한다. 따라서 앞 쪽 노드에 대한 정보 탐색을 가장 먼저 해야 한다.

  - 각 노드는 데이터 필드와 다음 노드에 대한 주소를 가지고 있다.

  - 즉 이전 노드에는 다음 노드에 대한 주소가 존재한다.

  - 만일 새로운 노드를 추가하고자 한다면 앞의 노드가 가리키는 노드를 새로운 노드가 가르키도록 변경하고 앞쪽 노드는 추가한 노드를 가리키게 한다. 즉, 둘 다 앞 쪽 노드를 알아야 가능하다.

  - 삭제도 마찬가지로 앞쪽 노드가 가르키는 노드를 삭제할 노드가 가르키는 노드로 변경하면 된다.

    ex. 서울-부산이 있을 때 중간에 대전을 추가하고 싶다면 우선 첫 번째로 서울이 가리키는 부산이라는 주소를 읽어와서 대전의 주소로 만들고 서울이 가리키는 주소를 대전으로 변경한다. 만일 서울-대전-부산에서 대전을 빼고 싶다면 서울이 카르키던 대전을 부산으로 바꾸면 된다.

    

- 연결 리스트에서 뭘 먼저 연결해야 할지 헷갈린다면 삽입해야 할 노드의 주소를 먼저 수정하는 것이 안전하다.



- 삽입정렬(배열의 요소 별로 배열을 쭉 순회하면서 요소보다 작은 값과 큰 값 사이에 해당 요소를 삽입하여 정렬하는 방식)은 연결리스트로 구현하는 것이 더 효율적이다.
  - 일반리스트의 경우 삽입 후 삽입한 위치 뒤의 요소들은 모두 한 칸씩 뒤로 밀어야 한다는 단점이 있다.
  - 연결리스트로 구현하면 앞뒤 요소와 연결만 해주면 된다.

 

- 병합정렬 역시 연결 리스트로 구현하면 더 효율적이다.



- 원형 연결리스트는 원형이기에 tail은 잘 쓰지 않는다. head는 원형 연결 리스트의 시작점을 의미한다.
  - 모든 노드의 next와 prev에 None이 존재하지 않는다.







# Tree

1. 트리 개요

- 용어 정리
  - 노드: 트리의 원소
    - 루트 노드: 트리의 시작 노드
    - 조상 노드: 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
    - 자손 노드: 서브 트리에 있는 하위 레벨의 노드들
    - 형제 노드: 같은 부모 노드의 자식 노드들
    - 단말 노드: 자식 노드가 없는 노드
  - 간선: 노드를 연결하는 선, 부모 노드와 자식 노드를 연결
    - 트리에서 간선의 수는 반드시 노드의 수-1개이다.
    - 즉 노드의 수>=간선의 수라면 트리가 아니다.
  - 서브트리: 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
    - 즉, 트리는 0개 이상의 하위 트리로 구성되어 있다.
  - 차수
    - 노드의 차수: 노드에 연결된 자식 노드의 수
    - 트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값
  - 높이(레벨)
    - 노드의 높이: 루트에서 노드에 이르는 간선의 수
    - 트리의 높이: 트리에 있는 노드의 높이 중에서 가장 큰 값
- 트리는 일종의 그래프이다. 
  - 그래프는 연결컴포넌트(어떤 임의의 두 노드를 선택하든지 둘 사이에 경로가 존재)
  - 트리 역시 연결컴포넌트 이지만 임의의 두 노드 사이에 유일한 경로가 존재한다. 즉 그래프와는 달리 두 노드 사이에 경로가 단 하나뿐이다.
  - 사이클이 존재하지 않는다. 즉 어떤 한 간선이라도 지우면 모든 노드가 연결된 상태는 아니게 되며 간선을 하나라도 추가하면 사이클이 생기게 된다(∵노드수=간선수+1).
- 트리의 특징
  - 루트(최상위 원소)에서 하위 원소로 내려가면서 확장되는 뿌리 모양의 구조
  - 가계도를 생각하면 쉽다.  실제로 가계도에서 많은 용어를 가져 왔다.
  - 비선형 자료구조
  - 하나(반드시 하나)의 부모 노드 아래에 0개 이상의 자식 노드가 존재하는 형태(원소들 간 1:n의 관계를 가진다)
  - 한 개 이상(∵루트는 반드시 존재)의 노드로 이루어진 유한 집합이다.
  - 루트를 제외한 나머지 노드들은 0개 이상의 분리집합(서로소)이다. 즉 한 집합 내부에 있는 원소가 다른 집합의 원소가 될 수는 없다.



2. 이진트리

- 이진트리
  - 모든 노드들이 최대 2개의 서브트리를 갖는 특별한 형태의 트리(0~2개의 자식 노드가 존재)
    - 레벨(높이) i에서 노드의 최대 개수는 2<sup>i</sup>개
    - 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개(모든 높이에 노드가 1개씩만 있는 경우), 최대 개수는 (2<sup>h+1</sup>-1)개
  - 왼쪽 자식과 오른쪽 자식을 구분한다.

- 포화 이진 트리
  - 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리(모든 높이에 노드가 2개씩 존재하는 트리)
  - 루트를 1번으로 하여 모든 노드가 번호를 가진다. 이 경우 가장 왼쪽의 노드를 쭉 타고 가면 번호는 2<sup>높이</sup>로 매겨진다. 오른쪽은 2<sup>높이+1</sup>-1로 매겨진다.
  
- 완전 이진 트리
  
  - 높이가 h이고 노드가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번 까지 빈자리가 없는 이진 트리, 즉 포화 이진트리는 아니지만 n번째 노드까지는 포화 이진 트리의 형태를 지닌다.
  
- 편향 이진 트리(사실상 연결리스트이다)
  - 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식만을 가진 이진 트리, 즉 노드가 2개 이상이거나 왼쪽자식, 오른쪽 자식이 혼재되어 있으면 편향 이진 트리가 아니다.
    - 왼쪽 편향 이진 트리
    - 오른쪽 편향 이진 트리
  - 트리의 장점을 잘 살리지 못하기에 좋지 않은 구조다.

- 이진트리에서의 순회(DFS를 사용)

  - 기본적인 순회 방법
    - 왼쪽 자식을 오른쪽 자식보다 먼저 방문한다는 원칙 하에 부모 노드를 언제 방문할지에 따라 3가지로 나뉜다.
    - 전위 순회:부모노드 방문 후, 자식 노드 좌,우 순 방문
    - 중위 순회: 왼쪽 자식, 부모노드, 오른쪽 자식 순으로 방문
    - 후위 순회: 좌,우 자식 방문 후 , 부모 노드  순으로 방문
  - 이진 트리 순회시 모든 부모 노드는 3번 방문한다.
    - 처음 노드에 진입할 때(이 때 방문 표시(혹은 원하는 처리)를 하면 전위 순회), A-B-D-E-H-I-C-F-G
    - 왼쪽 자식에서 돌아올 때(이 때 방문 표시(혹은 원하는 처리)를 하면 중위 순회),D-B-H-E-I-A-F-C-G
    - 오른쪽 자식에서 돌아올 때 (이 때 방문 표시(혹은 원하는 처리)를 하면 후위 순회)D-H-I-E-B-F-G-C-A

  | A    |      |      |      |      |      |
  | ---- | ---- | ---- | ---- | ---- | ---- |
  | B    |      |      | C    |      |      |
  | D    | E    |      | F    | G    |      |
  |      | H    | I    |      |      |      |

- 이진트리의 표현

  - 1차원 배열에 표현이 가능하다

  - 노드 번호가 i인 노드의 왼쪽 자식의 노드 번호는 2*i
  - 노드 번호가 i인 노드의 오른쪽 자식의 노드 번호는 2*i+1
  - 부모는 i//2(왼쪽 자식이던 오른쪽 자식이던 마찬가지다 ∵ //는 나머지를 버리므로 +1이 되던 안되던 상관 없다.)



- 수식트리
  - 수식을 표현하는 이진트리
  - 연산자는 부모, 피연산자는 좌,우의 자식 노드가 된다.
  - 단말 노드는 피연산자, 단말 노드가 아닌 노드(루트 노드와 가지 노드)는 모드 연산자
  - 단말노드에 가까울수록 연산의 우선 순위가 높아진다.



- 이진 탐색 트리

  - 탐색 작업을 효율적으로 하기 위한 자료 구조
  - 모든 원소는 서로 다른 유일한 키를 갖는다
  - key는 왼쪽 서브트리<루트 노드<오른쪽 서브트리 이다. 즉 왼쪽 서브트리는 루트보다 작은 값이, 오른쪽 서브트리는 루트보다 큰 값이 온다. 각각의 서브트리 역시 이진 탐색 트리가 된다.
  - 중위 순회를 하면 오름차순으로 정렬된 값을 얻을 수 있다.
  - 구체적 탐색 순서
    - 루트에서 시작
    - 탐색할 키 값 x를 루트 노드의 키 값과 비교
    - 루트 노드의 키 값>x 면 왼쪽 서브트리로 로 이동
      - 왼쪽 서브트리에서 다시 처음부터 시작
    - 루트 노드의 키 값<x 면 오른쪽 서브트리로 로 이동
      - 오른쪽 서브트리에서 다시 처음부터 시작
    - 루트 노드의 키 값==x 면 x를 찾음
  - 삽입 연산
    
- 위의 과정을 거쳐 탐색을 수행 후 탐색이 실패한 위치(삽입 하려는 값이기에 당연히 탐색해도 없을 것이므로 탐색은 실패하게 된다)에 삽입하려는 값을 삽입
    
- 삭제 연산
  
  - 삽입과 마찬가지로 탐색을 수행 후 찾으면 삭제
  
  - 삭제 후 만일 삭제한 노드에 자식이 있었다면 삭제한 노드의 부모 노드와 삭제한 노드의 자식노드를 연결해준다.
  
  - 만일 삭제한 노드의 자식 노드가 2개 였다면 왼쪽 서브트리의 가장 큰 값이나 오른쪽 서브트리의 가장 작은 값 중 하나가 삭제한 노드의 자리를 대체해 새로운 부모 노드가 된다.
  
    ∵key는 왼쪽 서브트리<루트 노드<오른쪽 서브트리
      - 왼쪽 서브트리의 가장 큰 값은 왼쪽 서브트리에서 오른쪽으로 갈 수 있을 때 까지 가면 가장 큰 값이 나오며
      - 오른쪽 서브트리의 가장 작은 값은 오른쪽 서브트리에서 왼쪽으로 갈 수 있을 때 까지 가면 가장 작은 값이 나온다.
  
  - 이진 탐색 트리에서 탐색, 삽입, 삭제 시간은 트리의 높이 만큼 걸린다.
    - 이진 트리가 균형적으로 생성되어 있는 경우(좌,우 서브트리의 높이차가 1이하): 대략 O(log n)
    - 최악의 경우: 한쪽으로 치우친 경사 이진트리의 경우: O(N)



3. 힙(heap) -추가 정리 필요

- 우선순위 큐(큐에 들어간 순서가 아닌, 우선순위에 따라 처리)를 구현하기 위해 사용
- 노드를 완전 이진 트리 형태로 저장하여 구현하여 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 힙을 정의하는 2가지 요소(둘 중 하나라도 충족하지 못하면 힙이 아니다)
  - 완전 이진 트리이다.
  - 부모 요소와 자식 요소 사이 키 값의 대소에 일관성이 존재한다.
    - 항상 부모 요소의 키 값이 크다(최대힙)
    - 항상 부모 요소의 키 값이 작다(최소힙)
- 즉, 우선순위 큐에서는 가장 작은 값이나 가장 큰 값을 먼저 처리하는데 자료의 추가나 삭제가 빈번히 일어나는 경우에 추가나 삭제가 일어날 때 마다 번번이 추가된 자료나 삭제된 자료를 고려하여 다시 크기 순으로 정렬하고  최대값이나 최솟값을 다시 찾아야 하는 번거로움이 있다. 그러나 힙에서는 항상 루트에 최소값(최소 힙)이나 최대값(최대 힙)을 위치시키기 때문에 다른 값의 정렬 여부와 관계 없이 항상 최대값, 혹은 최소값을 알 수 있다. 따라서 시간이 훨씬 적게 걸린다.
- 종류
  - 최대 힙
    - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
    - 부모노드의 키값>자식노드의 키값, 자식들(좌우) 사이의 키값의 대소는 상관 없다.
    - 루트 노드: 키값이 가장 큰 노드
  - 최소 힙
    - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
    - 부모노드의 키값<자식노드의 키값, 자식들(좌우) 사이의 키값의 대소는 상관 없다.
    - 루트 노드: 키값이 가장 작은 노드
- 특정 노드의 자식 노드가 있는지 확인하는 방법
  - 일반적으로 트리의 마지막 노드를 알 수 있다.
  - 따라서 만일 노드번호\*2를 했을 때 이 값이 트리의 마지막 노드 번호보다 크다면 자식 노드가 없는 것이다. 만일 같다면 왼쪽 자식 하나만 가지고 있는 것이고 노드번호\*2+1이 마지막 노드 번호보다 작거나 같다면 좌우 자식이 모두 있는 것이다.







# 문제 풀면서 알게 된 것들

- b_2667_단지 번호 붙이기

  - 리스트를 기준으로 반복문이 수행될 때, 리스트의 길이를 기준으로 수행될 때와 리스트로 반복문이 수행될 때 차이가 존재한다.

    ```python
    #길이를 기준으로 수행 되는 경우
    arr = [1]
    for i in range(len(arr)):
    	arr.append(i)
    	print("i")
    #위의 경우 반복문에 진입할 때의 arr의 길이를 기준으로 1번만 수행된다.
        
    
    #리스트를 기준으로 수행 되는 경우
    arr = [1]
    for i in arr:
    	arr.append(i)
    	print(i)
    #반면 위의 경우 arr에 계속 append가 되면서 반복문이 무한히 돌게 된다.
    ```

    