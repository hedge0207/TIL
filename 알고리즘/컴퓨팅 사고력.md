# 서론

- 프로그래밍의 두 가지 어려움
  - 프로그래밍 언어
  - 논리(hard logic)



- hard logic과 soft logic
  - soft logic 
    - 우리가 일상에서 상식적인 판단에 사용하는 로직
    - 빠르지만 부정확할 수 있다는 단점이 존재
  - hard logic
    - 프로그래밍에서 사용하는 logic
    - 보다 엄밀하고 정확한 logic
  - 알고리즘 설명을 봐도 이해가 안되는 것은 직관(soft logic)으로 이해하려 하기 때문이다.



# 명제

- 명제: 참이나 거짓을 알 수 있는 식이나 문장(p, q, r, ...로 표현)

  - ∀: 모든, ∃: 어떤

  - 진리값: T,F 또는 1,0

  - 항진 명제: 진리값이 항상 참

  - 모순 명제: 진리값이 항상 거짓

  - 사건 명제: 항진명제도 모순명제도 아닌 명제

  - 조건명제: p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)으로 제시되는 명제

    - p→q로 표현하고, 'p이면 q이다'로 읽는다.

    - 진리표

      > p가 거짓이면 q에 상관없이 p→q는 참이 된다.

      | p    | q    | p→q  |
      | ---- | ---- | ---- |
      | T    | T    | T    |
      | T    | F    | F    |
      | F    | T    | T    |
      | F    | F    | T    |

  - 쌍방조건명제:  p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제

    - p↔q , p이면 q이고, q이면 p이다.

    - 진리표

      | p    | q    | p↔q  |
      | ---- | ---- | ---- |
      | T    | T    | T    |
      | T    | F    | F    |
      | F    | T    | F    |
      | F    | F    | T    |



- 조건명제의 역, 이 , 대우

  - 역: q→p

  - 이: ~p→~q

  - 대우: ~q→~p

  - 진리표

    - 대우의 진리값은 조건명제의 진리값과 같다.

    | p    | q    | p→q  | q→p  | ~p→~q | ~q→~p |
    | ---- | ---- | ---- | ---- | ----- | ----- |
    | T    | T    | T    | T    | T     | T     |
    | T    | F    | F    | T    | T     | F     |
    | F    | T    | T    | F    | F     | T     |
    | F    | F    | T    | T    | T     | T     |

    

- 연산

  - 부정(NOT): 명제의 진릿값이 반대
    - ~p, ￢p 로 표현하고 not p,  p의 부정으로 읽는다.
  - 논리곱(AND): p, q가 명제일 때 p, q가 모두 참일 경우에만 참이 되는 명제
    - p∧q 로 표현하고 p and q,  p 그리고 q로 읽는다.
  - 논리합(OR): p, q가 명제일 때 p, q 모두 거짓일 경우에만 거짓이 되는 명제
    - p∨q 로 표현하고 p or q, p 또는 q로 읽는다. 

  - 배타적 논리합(XOR): p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제
    - p⊕q 로 표현하고 p xor q로 읽는다.

  - 연산자 우선 순위: NOT > OR,AND > ↔, →



- 명제식의 변형

  > 공통부분을 뺄 수 있다.

  - (p∧q)∨(p∧~q)를 예로 들면 공통 부분인 p를 밖으로 빼고 p∧q와 p∧~q 에 공통으로 들어가는 ∧도 함께 빼준 후 p∧q와p∧~q 사이에 들어가는 ∨를 괄호 안에 넣어준다. 결국 p∧(q∨~q)가 된다.



- 증명

  - 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함

  - 증명에 대한 많은 오해가 p→q를 p↔q와 혼동하는 것에서 일어남

  - 예시: 모든 당구공은 색이 같다는 다음 증명에서 잘못된 것은?

    - p(1)은 당구공 1개가 들어있는 집합은 모두 색이 같음
    - 수학적 귀납법: p(1)이 참이고, p(n)→p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해서 참이다.
    - p(n)→p(n+1)을 증명하기 위해 p(n)이 참이라고 가정(p(n)이 참이라고 가정할 수 없다는 반론이 있을 수 있지만 수학적 귀납법에서 필요한 것은 p(n)→p(n+1)이 참임을 보이는 것 뿐이므로 P(n)이 정말로 참일 필요는 없다)
    - 당구공 n+1개가 들어 있는 임의의 집합을 생각함
    - 이 집합에서 하나를 빼면 당구공 n개가 있는 집합이 되므로 지금 상황에서 모든 당구공의 색이 같음
    - 방금 뺀 원소를 다시 넣고, 다른 당구공을 빼면 역시 당구공 n개가 있는 집합이 되므로 지금 상황에서도 모든 당구공의 색이 같음
    - 위의 두 상황에서 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같음을 알 수 있으므로 당구공 n+1개가 들어 있는 임의의 집합은 색이 같은 것 만을 포함함
    - 이 증명에서 잘못된 부분은 '처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같음을 알 수 있으므로' 부분으로 n=1인 경우 공통 부분이 없음

  - 수학적 귀납법과 증명의 수준

    - 수학적 귀납법의 기본형

      > p(1)이 참이고, p(n)→p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해서 참이다.

    - 수학적 귀납법의 강한 형태

      > p(1)이 참이고, p(1)∧p(2∧)p(3)∧...∧p(n)→p(n+1)이 참이면   p(n)은 모든 자연수 n에 대해 참이다.



- 예제

  - n이 짝수이면 3n+5는 홀수임을 증명하라.
    - n을 2k로 둔다(짝수 이므로)
    - 6k+5 = 2(3k+2)+1, 2(3k+2)는 2의 배수이므로 짝순데 +1을 하므로 2(3k+2)+1, 즉 3n+5는 홀수다.
  - m이 짝수이고 n이 홀수이면 2m+3n은 홀수임을 증명하라
    - m=2k로, n=2l+1로 둔다.
    - 2m+3n = 4k+6l+3=2(2k+3l+1)+1 ,2(2k+3l+1)는 2의 배수이므로 짝순데 +1을 하므로 2(2k+3l+1)+1, 즉 2m+3n는 홀수다.

  - n<sup>2</sup>이 짝수이면 n은 짝수임을 증명하라
    - 직접 증명이 쉽지 않으므로 대우를 증명(n이 홀수이면 n<sup>2</sup>은 홀수이다.)
    - n=2k+1로 둔다.
    - n<sup>2</sup>=(2k+1)<sup>2</sup>=4k<sup>2</sup>+4k+1=2(2k<sup>2</sup>+2k)+1이 된다.
    - n이 홀수이면 n<sup>2</sup>은 홀수라는 명제가 성립하므로 그 대우인 n<sup>2</sup>이 짝수이면 n은 짝수도 참이다.
  - n이 3의 배수가 아니면 n<sup>2</sup>은 3의 배수가 아니다.

    - n = 3k+1 or 3k+2(3의 배수가 아니면 나머지가 1이나 2가 된다.)
    - n이 3k+1인 경우: n<sup>2</sup>=(3k+1)<sup>2</sup>=9k<sup>2</sup>+6k+1=3(3k<sup>2</sup>+2k)+1, 따라서 n<sup>2</sup>은 3의 배수가 아니다.
    - n이 3k+2인 경우:n<sup>2</sup>=(3k+2)<sup>2</sup>=9k<sup>2</sup>+12k+4=3(3k<sup>2</sup>+4k+1)+1, 따라서 n<sup>2</sup>은 3의 배수가 아니다.
    - 따라서 n이 3의 배수가 아니면 n<sup>2</sup>은 3의 배수가 아니다.

  



# 수와 표현

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
  - k개의 비트를 사용하면 0부터 2<sup>k</sup>-1까지 표현 가능, 즉 2<sup>k</sup>가지의 값을 표현하는 것이 가능
  - 10진수로 k 자리를 쓰면 0부터 10<sup>k</sup>-1까지 표현 가능한 것과 완전히 동일한 과정
  - 어떤 값 n을 표현하기 위해서는 2<sup>k</sup>-1 >= n 이어야 한다. 달리 말하면 2<sup>k</sup>>=n+1이어야 k개의 비트로 n을 표현 할 수 있다. 
  - 같은 의미로 같은 의미로 k>=log(n+1)약 logn 비트가 필요



- x=logn과 2<sup>x</sup>=n은 같은 말이다.

  - 컴퓨터 분야에서 로그의 밑은 항상 2
  - x=logn일 때 x가 커질수록 n은 엄청나게 커진다.

  - logn이란
    - 2의 몇 승이 n이 되느냐의 답
    - n을 표현하는데 몇 비트가 필요한가의 답
    - 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 답
    - n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답



- 32비트 컴퓨터의 주소 공간은 2<sup>32</sup>, 약 40개 주소


$$
n+(\frac n 2+\frac n 2)+(\frac n 4+\frac n 4+\frac n 4+\frac n 4)+(\frac n 8+\frac n 8+\frac n 8+\frac n 8+\frac n 8+\frac n 8+\frac n 8+\frac n 8)+...+(1+1+...)
$$

$$
=nlogn
$$

- 위 식이 nlogn이 되는 이유는 다음과 같다.

  - 모든 항의 분모는 2의 제곱으로 타나내진다.

  - 맨 마지막항인(1+1+1+...)에서 n/2<sup>k</sup>이 1이 되려면 n=2<sup>k</sup>이어야 한다. 따라서 k=logn이 된다.

  - 위의 식에서 첫 항인 n을 제외하고 괄호로 묶인 항들은 모두 2의 제곱이 각 항의 순서를 나타낸다. 

  - 따라서 마지막 항인 (1+1+1+...)은 logn 번째 항이라고 볼 수 있다. 결국 모든 괄호를 n으로 묶은 후 보면(아래와 같이 하면) n이 logn개가 있게 된다는 것을 알 수 있다. 따라서 nlogn(n*logn)이 도출된다.
    $$
    n+n(\frac 1 2+\frac 1 2)+n(\frac 1 4+\frac 1 4+\frac 1 4+\frac 1 4)+...+(1+1+...)
    $$
    

- 예제
  - 문제1. 2진수 표현에서 logn비트로 표현할 수 있는 숫자 범위는 
    - 2<sup>n</sup>개















































