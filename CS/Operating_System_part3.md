# 프로세스 간 통신

- 프로세스 간 통신(IPC, Inter Process Communication)
  - 프로세스는 시스템 내에서 독립적으로 실행되기도 하고, 서로 데이터를 주고받으며 협업하기도 한다.
  - IPC란 프로세스가 다른 프로세스와 데이터를 주고받는 것을 의미한다.
    - 같은 컴퓨터 내에 있는 프로세스뿐만 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함된다.
  - IPC는 겉으로 보기에는 데이터를 주고(send) 받는(receive) 매우 간단한 작업이지만, 내부적으로는 복잡한 과정을 거쳐 이루어진다.





## IPC의 분류

- 통신 방향에 따른 분류
  - 양방향 통신
    - 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조.
    - 일반적인 통신은 모두 양방향 통신이다.
    - 소켓 통신이 이에 해당한다.
  - 반양방향 통신
    - 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 구조.
    - 무전기를 생각하면 된다.
  - 단방향 통신
    - 한쪽 방향으로만 데이터를 전송할 수 있는 구조.
    - 전역 변수나 파일, 파이프를 통핸 통신이 이에 해당한다.
  - 대부분의 통신은 양방향 통신이지만 전역 변수는 단방향 통신이다.
    - 만일 전역 변수를 사용하여 양방향 통신을 구현하려면 전역 변수를 2개 사용해야한다.



- 통신 구현 방식에 따른 분류
  - 바쁜 대기
    - 전역 변수를 사용하는 통신 방식의 가장 큰 문제는 언제 데이터를 보낼지 데이터를 받는 쪽에서는 모른다는 것이다.
    - 따라서 데이터를 받는 쪽에서는 반복적으로 전역 변수의 값을 점검해야한다.
    - 이처럼 상태 변화를 살펴보기위해 반복문을 무한 실행하며 기다리는 것을 바쁜 대기(busy wating)라 하며, 이는 나쁜 프로그램의 전형적인 예이다.
  - 바쁜 대기 문제를 해결하기 위해서는 데이터가 도착했음을 알려주는 동기화를 사용한다.
    - IPC는 동기화 기능 유무에 따라 대기가 있는 통신과 대기가 없는 통신으로 구분된다.
    - 대기가 있는 통신은 동기화 통신(synchronous communication), 대기가 없는 통신은 asyncronous communication이라고도 한다.
  - 대기가 있는 통신
    - 동기화를 지원하는 통신 방식.
    - 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있다.
    - 파이프나 소켓이 이에 속한다.
  - 대기가 없는 통신
    - 동기화를 지원하지 않는 통신 방식.
    - 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인한다.
    - 전역 변수와 파일을 이용한 통신은 대기가 없는 통신의 대표적인 예이다.
    - 대기가 없는 통신은 통신 오버헤드는 적지만 바쁜 대기처럼 사용자가 직접 처리해야 하는 작업이 많다.





## IPC 종류

- 프로세스 내부 데이터 통신
  - 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신.
  - 프로세스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고 받으며, 이는 운영체제의 도움 없이 진행된다.
  - 전역 변수를 이용한 통신
    - 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는 방식이다.
    - 데이터를 보내는 쪽에서 전역 변수나 파일에 값을 쓰고, 데이터를 받는 쪽에서 전역 변수의 값을 읽는다.
    - 전역 변수를 사용한 통신은 주로 부모 프로세스와 자식 프로세스 같이 직접적으로 관련이 있는 프로세스 간에 사용한다.
    - 전역 변수의 값이 변경되었는지 알 수 있는 방법이 없으므로, 전역 변수의 값이 변경되었는지를 계속 확인해야 한다(즉, 동기화에 문제가 있다).
  - 파일을 이용한 통신
    - 저장장치에 파일을 저장하고, 이 파일을 통해 다른 프로세스와 통신을 하는 방식이다.
    - 한 프로세스가 파일에 데이터를 쓰면, 다른 프로세스가 해당 파일에 쓰인 내용을 읽는 방식으로 통신이 이루어진다.
    - 전역 변수를 이용한 통신과 마찬가지로, 데이터를 받아오는 쪽에서는 파일의 내용이 변경되었는지 계속 확인해야하므로 동기화가 문제가 된다.



- 프로세스 간 데이터 통신
  - 같은 컴퓨터에 있는 여러 프로세스끼리의 통신.
  - 공용 파일 또는 운영체제가 제공하는 파이프를 통해 통신한다.
  - 소켓을 이용하면 같은 컴퓨터에 있는 서로 다른 프로세스 끼리도 통신이 가능하지만, 속도가 느리기에 굳이 할 경우는 없다.
  - 파이프를 이용한 통신
    - 파이프는 운영체제가 제공하는 동기화 통신 방식이다.
    - 기본적으로 단방향 통신이며, 양방향 통신을 위해서는 파이프 2개를 사용해야한다.
    - 파이프에 쓰기 연산을 하면 데이터가 전송되고, 읽기 연산을 하면 데이터를 받아온다.
    - 만약 한 프로세스가 파이프에 대해 읽기 연산을 수행했는데 다른 프로세스가 파이프에 쓰기 연산을 아직 하지 않았다면 읽기 연산을 수행한 프로세스는 대기 상태가 된다.
    - 다른 프로세스가 파이프에 대이터를 쓰는 순간 자동으로 대기 상태가 풀리는 방식으로 동기화가 이루어지므로, 바쁜 대기를 하지 않아도 된다.
    - 이름 없는 파이프(anonymous pipe)와 이름 있는 파이프(named pipe)로 나뉘며, 이름 없는 파이프는 주로 부모와 자식 혹은 같은 부모를 가진 자식 프로세스들 사이의 통신에 사용되고, 이름 있는 파이프는 FIFO라 불리는 특수 파일을 사용하여 서로 관련 없는 프로세스 간 통신에 사용된다.



- 네트워크를 통한 통신
  - 여러 컴퓨터가 네트워크로 연결되어 있을 때 서로 다른 컴퓨터의 프로세스 사이의 통신으로, 네트워킹이라고도 한다.
  - 소켓을 사용하여 네트워킹이 이루어진다.
    - 다른 컴퓨터에 있는 함수를 호출하여 통신하는 방식을 원격 프로시저 호출(RPC, Remote Procedure Call)이라 한다.
    - 원격 프로시저 호출은 소켓을 사용하여 구현한다.
    - 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 바쁜 대기를 하지 않아도 된다.
    - 양방향 통신을 위해 파이프 방식은 2개의 파이프를 필요로했지만, 소켓 방식은 하나의 소켓으로도 양방향 통신이 가능하다.



- 모든 통신에 관련된 연산은 아래와 같은 구조이다.

  > 파일뿐 아니라 소켓 등의 모든 통신 방식에 적용되며, 아래 순서에 따라 실행된다.

  - open()
    - 통신할 데이터를 작성하기 위해 데이터가 작성될 대상을 연다.
  - read()/write()
    - 데이터가 작성될/작성된 대상을 읽는/쓴다.
  - close()
    - 데이터가 작성된 대상을 닫는다.



## 공유 자원과 임계구역

- 공유 자원의 접근
  - 공유 자원(Shared resource)
    - 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다.
  - 공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰냐에 따라 그 결과가 달라질 수 있다.
    - 따라서 프로세스들의 공유 자원 접근 순서를 정하여 예상치 못한 문제가 발생하지 않도록 해야한다.
  - 경쟁 조건(race condition)
    - 두 개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 의미한다.
    - 경쟁 조건이 발생하면 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있다.



- 임계구역(Critical section)

  - 공유 자원 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 임계 구역이라한다.
    - 따라서 임계 구역으로 지정된 영역에서는 여러 프로세스들이 동시에 작업을 해선 안 된다.
    - 어떤 프로세스가 임계 구역에 들어가면 다른 프로세스는 임계구역 밖에서 기다려야 하며 임계구역의 프로세스가 나와야 임계구역에 들어갈 수 있다.

  - 생산자 소비자 문제(Producer-Consumer Problem)
    - 임계구역과 관련된 전통적인 문제이다. 
    - 생산자는 계속 버퍼에 데이터를 넣고, 소비자는 계속 버퍼에서 데이터를 가져오는데, 이를 위해 버퍼는 원형 버퍼를 사용한다.
    - 또한 버퍼가 비었는지 혹은 가득 찼는지를 확인하기 위해 저장된 데이터의 양을 저장하는 sum이라는 전역 변수를 사용한다.
    - 문제는 생산자 코드와 소비자 코드가 동시에 실행되어 생산자와 소비자가 동시에 전역 변수 sum에 접근할 경우  발생한다.
    - 생산자는 원형 버퍼에 데이터를 추가한 후 sum을 증가시키고, 소비자는 데이터를 가져온 후 sum을 감소시키는데, 이 작업이 동시에 실행될 경우 sum의 값이 부정확해질 수 있다.
  - 임계 구역의 해결 조건
    - 상호 배제(mutual exclusion): 한 프로세스가 임계구역에 들어가면, 다른 프로세스는 임계구역에 들어갈 수 없게 막는다.
    - 한정 대기(bounded wating): 어떤 프로세스도 임계구역에 들어가지 못한 채 계속 대기해선 안된다.
    - 진행의 융통성(progress flexibility): 한 프로세스가 다른 프로세스의 진행을 방해해선 안 된다.



