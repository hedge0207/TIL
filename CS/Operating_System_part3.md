# 프로세스 간 통신

- 프로세스 간 통신(IPC, Inter Process Communication)
  - 프로세스는 시스템 내에서 독립적으로 실행되기도 하고, 서로 데이터를 주고받으며 협업하기도 한다.
  - IPC란 프로세스가 다른 프로세스와 데이터를 주고받는 것을 의미한다.
    - 같은 컴퓨터 내에 있는 프로세스뿐만 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함된다.
  - IPC는 겉으로 보기에는 데이터를 주고(send) 받는(receive) 매우 간단한 작업이지만, 내부적으로는 복잡한 과정을 거쳐 이루어진다.





## IPC의 분류

- 통신 방향에 따른 분류
  - 양방향 통신
    - 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조.
    - 일반적인 통신은 모두 양방향 통신이다.
    - 소켓 통신이 이에 해당한다.
  - 반양방향 통신
    - 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 구조.
    - 무전기를 생각하면 된다.
  - 단방향 통신
    - 한쪽 방향으로만 데이터를 전송할 수 있는 구조.
    - 전역 변수나 파일, 파이프를 통핸 통신이 이에 해당한다.
  - 대부분의 통신은 양방향 통신이지만 전역 변수는 단방향 통신이다.
    - 만일 전역 변수를 사용하여 양방향 통신을 구현하려면 전역 변수를 2개 사용해야한다.



- 통신 구현 방식에 따른 분류
  - 바쁜 대기
    - 전역 변수를 사용하는 통신 방식의 가장 큰 문제는 언제 데이터를 보낼지 데이터를 받는 쪽에서는 모른다는 것이다.
    - 따라서 데이터를 받는 쪽에서는 반복적으로 전역 변수의 값을 점검해야한다.
    - 이처럼 상태 변화를 살펴보기위해 반복문을 무한 실행하며 기다리는 것을 바쁜 대기(busy wating)라 하며, 이는 나쁜 프로그램의 전형적인 예이다.
  - 바쁜 대기 문제를 해결하기 위해서는 데이터가 도착했음을 알려주는 동기화를 사용한다.
    - IPC는 동기화 기능 유무에 따라 대기가 있는 통신과 대기가 없는 통신으로 구분된다.
    - 대기가 있는 통신은 동기화 통신(synchronous communication), 대기가 없는 통신은 asyncronous communication이라고도 한다.
  - 대기가 있는 통신
    - 동기화를 지원하는 통신 방식.
    - 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있다.
    - 파이프나 소켓이 이에 속한다.
  - 대기가 없는 통신
    - 동기화를 지원하지 않는 통신 방식.
    - 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인한다.
    - 전역 변수와 파일을 이용한 통신은 대기가 없는 통신의 대표적인 예이다.
    - 대기가 없는 통신은 통신 오버헤드는 적지만 바쁜 대기처럼 사용자가 직접 처리해야 하는 작업이 많다.





## IPC 종류

- 프로세스 내부 데이터 통신
  - 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신.
  - 프로세스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고 받으며, 이는 운영체제의 도움 없이 진행된다.
  - 전역 변수를 이용한 통신
    - 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는 방식이다.
    - 데이터를 보내는 쪽에서 전역 변수나 파일에 값을 쓰고, 데이터를 받는 쪽에서 전역 변수의 값을 읽는다.
    - 전역 변수를 사용한 통신은 주로 부모 프로세스와 자식 프로세스 같이 직접적으로 관련이 있는 프로세스 간에 사용한다.
    - 전역 변수의 값이 변경되었는지 알 수 있는 방법이 없으므로, 전역 변수의 값이 변경되었는지를 계속 확인해야 한다(즉, 동기화에 문제가 있다).
  - 파일을 이용한 통신
    - 저장장치에 파일을 저장하고, 이 파일을 통해 다른 프로세스와 통신을 하는 방식이다.
    - 한 프로세스가 파일에 데이터를 쓰면, 다른 프로세스가 해당 파일에 쓰인 내용을 읽는 방식으로 통신이 이루어진다.
    - 전역 변수를 이용한 통신과 마찬가지로, 데이터를 받아오는 쪽에서는 파일의 내용이 변경되었는지 계속 확인해야하므로 동기화가 문제가 된다.



- 프로세스 간 데이터 통신
  - 같은 컴퓨터에 있는 여러 프로세스끼리의 통신.
  - 공용 파일 또는 운영체제가 제공하는 파이프를 통해 통신한다.
  - 소켓을 이용하면 같은 컴퓨터에 있는 서로 다른 프로세스 끼리도 통신이 가능하지만, 속도가 느리기에 굳이 할 경우는 없다.
  - 파이프를 이용한 통신
    - 파이프는 운영체제가 제공하는 동기화 통신 방식이다.
    - 기본적으로 단방향 통신이며, 양방향 통신을 위해서는 파이프 2개를 사용해야한다.
    - 파이프에 쓰기 연산을 하면 데이터가 전송되고, 읽기 연산을 하면 데이터를 받아온다.
    - 만약 한 프로세스가 파이프에 대해 읽기 연산을 수행했는데 다른 프로세스가 파이프에 쓰기 연산을 아직 하지 않았다면 읽기 연산을 수행한 프로세스는 대기 상태가 된다.
    - 다른 프로세스가 파이프에 대이터를 쓰는 순간 자동으로 대기 상태가 풀리는 방식으로 동기화가 이루어지므로, 바쁜 대기를 하지 않아도 된다.
    - 이름 없는 파이프(anonymous pipe)와 이름 있는 파이프(named pipe)로 나뉘며, 이름 없는 파이프는 주로 부모와 자식 혹은 같은 부모를 가진 자식 프로세스들 사이의 통신에 사용되고, 이름 있는 파이프는 FIFO라 불리는 특수 파일을 사용하여 서로 관련 없는 프로세스 간 통신에 사용된다.



- 네트워크를 통한 통신
  - 여러 컴퓨터가 네트워크로 연결되어 있을 때 서로 다른 컴퓨터의 프로세스 사이의 통신으로, 네트워킹이라고도 한다.
  - 소켓을 사용하여 네트워킹이 이루어진다.
    - 다른 컴퓨터에 있는 함수를 호출하여 통신하는 방식을 원격 프로시저 호출(RPC, Remote Procedure Call)이라 한다.
    - 원격 프로시저 호출은 소켓을 사용하여 구현한다.
    - 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 바쁜 대기를 하지 않아도 된다.
    - 양방향 통신을 위해 파이프 방식은 2개의 파이프를 필요로했지만, 소켓 방식은 하나의 소켓으로도 양방향 통신이 가능하다.



- 모든 통신에 관련된 연산은 아래와 같은 구조이다.

  > 파일뿐 아니라 소켓 등의 모든 통신 방식에 적용되며, 아래 순서에 따라 실행된다.

  - open()
    - 통신할 데이터를 작성하기 위해 데이터가 작성될 대상을 연다.
  - read()/write()
    - 데이터가 작성될/작성된 대상을 읽는/쓴다.
  - close()
    - 데이터가 작성된 대상을 닫는다.



## 공유 자원과 임계구역

- 공유 자원의 접근
  - 공유 자원(Shared resource)
    - 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다.
  - 공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰냐에 따라 그 결과가 달라질 수 있다.
    - 따라서 프로세스들의 공유 자원 접근 순서를 정하여 예상치 못한 문제가 발생하지 않도록 해야한다.
  - 경쟁 조건(race condition)
    - 두 개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 의미한다.
    - 경쟁 조건이 발생하면 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있다.



- 임계구역(Critical section)

  - 공유 자원 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 임계 구역이라한다.
    - 따라서 임계 구역으로 지정된 영역에서는 여러 프로세스들이 동시에 작업을 해선 안 된다.
    - 어떤 프로세스가 임계 구역에 들어가면 다른 프로세스는 임계구역 밖에서 기다려야 하며 임계구역의 프로세스가 나와야 임계구역에 들어갈 수 있다.

  - 생산자 소비자 문제(Producer-Consumer Problem)
    - 임계구역과 관련된 전통적인 문제이다. 
    - 생산자는 계속 버퍼에 데이터를 넣고, 소비자는 계속 버퍼에서 데이터를 가져오는데, 이를 위해 버퍼는 원형 버퍼를 사용한다.
    - 또한 버퍼가 비었는지 혹은 가득 찼는지를 확인하기 위해 저장된 데이터의 양을 저장하는 sum이라는 전역 변수를 사용한다.
    - 문제는 생산자 코드와 소비자 코드가 동시에 실행되어 생산자와 소비자가 동시에 전역 변수 sum에 접근할 경우  발생한다.
    - 생산자는 원형 버퍼에 데이터를 추가한 후 sum을 증가시키고, 소비자는 데이터를 가져온 후 sum을 감소시키는데, 이 작업이 동시에 실행될 경우 sum의 값이 부정확해질 수 있다.
  - 임계 구역의 해결 조건
    - 상호 배제(mutual exclusion): 한 프로세스가 임계구역에 들어가면, 다른 프로세스는 임계구역에 들어갈 수 없게 막는다.
    - 한정 대기(bounded wating): 어떤 프로세스도 임계구역에 들어가지 못한 채 계속 대기해선 안된다.
    - 진행의 융통성(progress flexibility): 한 프로세스가 다른 프로세스의 진행을 방해해선 안 된다.



### 임계구역 해결 방법

- 잠금을 사용한 간단한 해결 방법

  - Boolean 값을 사용해 임계구역이 잠금 상태인지 아닌지를 확인한 후 코드를 실행한다.
    - 아래 예시는 잔금을 10 증가시키는 코드로, 잔금을 변경하는 부분은 여러 프로세스가 동시에 수행해선 안 되는 임계구역이다.
    - 따라서 임계구역 진입 전에 lock을 true로 전환하여 다른 프로세스가 임계구역에 진입할 수 없도록 막고, 잔금 변경을 완료하고 임계구역을 빠져나오면서 lock을 false로 전환하여 다른 프로세스가 임계구역에 진입할 수 있도록 한다.

  ```c
  #include <stdio.h>
  
  // c에는 boolean type이 없으므로 boolean type을 정의해준다.
  typedef enum {false, true} boolean;
  // 임계구역 잠금 여부를 표현하기 위한 변수인 lock을 선언한다.
  extern boolean lock=false;
  extern int balance;
  
  main(){
      // lock이 true면 다른 프로세스들은 while문에서 loop를 돌게되고, 임계구역으로 진입하지 못 한다.
      while(lock==true);
      lock=true;
      balance=balance+10
      lock=false;
  }
  ```

  - 위 코드의 문제
    - 프로세스 P1이 while문의 실행을 마치고 lock을 true로 변경하는 코드를 실행하려는 순간 타임아웃이 발생하여 문맥 교환이 발생한다.
    - 문백 교환으로 실행권을 얻은 다른 프로세스 P2가  while문을 실행하는데, lock은 아직 false인 상태이므로, 바로 while문을 빠져나와 lock을 true로 변경하고 임계구역에 진입하는데, 또 다시 문맥교환이 발생한다.
    - 문맥 교환으로 다시 실행권을 얻은 P1역시 lock을 true로 변경하고 임계구역에 진입한다. 
    - 위처럼 둘 이상의 프로세스가 동시에 임계구역에 진입할 수 있다는 문제가 있다.
    - 즉 상호 배제 조건을 위반한다.
    - 또한 한 프로세스가 임계구역에 있는 동안 다른 프로세스들은 whild문에서 lock이 false로 변경되었는지를 지속적으로 확인하므로 바쁜 대기를 하게된다.

  - 위 문제를 해결하기 위한 코드
    - lock 변수 2개를 생성하여 하나는 P1이, 다른 하나는 P2가 사용하고, 둘 중 하나라도 true라면 한 process가 임계구역에 진입했다는 뜻이므로 while문에서 대기한다.

  ```c
  #include <stdio.h>
  
  typedef enum {false, true} boolean;
  extern boolean lock1=false;
  extern boolean lock2=false;
  extern int balance;
  
  // 프로세스 P1
  main(){
      lock1=true;
      while(lock2==true);
      balance=balance+10
      lock1=false;
  }
  
  // 프로세스 P2
  main(){
      lock2=true;
      while(lock1==true);
      balance=balance+10
      lock2=false;
  }
  ```

  - 위 코드의 문제
    - 여전히 바쁜 대기를 해야 하고, 프로세스의 개수만큼 공유 변수를 생성해야한다는 것 외에도 아래와 같은 문제가 있다.
    - P1이 lock1을 true로 변경하고 문맥 교환이 발생하여 P2가 실행 상태로 변경된다.
    - P2도 lock2를 true로 변경하고 문맥 교환이 발생하여 P1이 실행 상태로 변경된다.
    - 둘 다 while문에 막혀 무한 루프에 빠진다.
    - 따라서 한정 대기 조건을 위배한다.
  - 위 문제를 해결하기 위한 코드
    - lock 변수를 boolean type이 아닌 int type으로 선언하고 몇 번 프로세스가 임계구역을 점유중인지를 저장한다.
    - 아래 방식을 통헤 상호 배제와 한정 대기를 보장할 수 있다.

  ```c
  #include <stdio.h>
  
  extern int lock;
  extern int balance;
  
  // 프로세스 P1
  main(){
      while(lock==2);
      balance=balance+10
      lock=2;
  }
  
  // 프로세스 P2
  main(){
      while(lock==1);
      balance=balance+10
      lock=1;
  }
  ```

  - 위 코드의 문제
    - 바쁜 대기가 아직도 남아있다는 문제 외에도 아래와 같은 문제가 있다.
    - 무조건 둘이 번갈아가며 실행되어야 한다는 문제가 있다.
    - 한 프로세스가 연속하여 임계 구역에 진입할 수 없다.
    - 즉, 위 코드는 진행의 융통성 조건을 위배한다.
    - 이처럼 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 경직된 동기화(lockstep synchronization)라 한다.



- 피터슨 알고리즘(Peterson's Solution)

  - 임계구역 문제를 해결하기 위해 Gary Peterson이 제안한 알고리즘이다.
  - turn이라는 공유 변수를 사용한다.
    - P1은 임계구역에 진입하기 전에 먼저 잠금을 한 후 turn을 2로 설정한다.
    - 변수 turn은 두 프로세스가 동시에 lock을 설정하여 임계구역에 못 들어가는 상황, 즉 무한 대기 상황에 대비하기 위한 장치이다.
    - 즉 두 프로세스가 동시에 lock을 설정했더라도 turn을 사용하여 다른 프로세스에게 양보한다.
    - 예를 들어 P1이 lock1을 true로 변경하고 P2로 제어권이 넘어갔다.
    - 이 상태에서 P2는 turn=1까지 실행하고 P1으로 제어권이 넘어갔다.
    - P1은 turn=2를 이어서 실행하고, lock1=true, lock2=true, turn=2인 상태이므로 while문에서 대기한다.
    - 그러다 문맥 교환으로 P2로 제어권이 넘어가고, turn=2이므로 P2는 while문을 빠져나와 임계구역에 진입한다.

  ```c
  #include <stdio.h>
  
  typedef enum {false, true} boolean;
  extern boolean lock1=false;
  extern boolean lock2=false;
  extern int tern=1;
  extern int balance;
  
  // 프로세스 P1
  main(){
      lock1=true;
      turn=2;
      while(lock2==true && turn==2);
      balance=balance+10
      lock1=false;
  }
  
  // 프로세스 P2
  main(){
      lock2=true;
      turn=1;
      while(lock1==true && turn==1);
      balance=balance+10
      lock2=false;
  }
  ```

  - 한계
    - 임계구역 해결의 세 가지 조건을 모두 만족하지만, 프로세스가 증가할수록 공유 변수를 추가하고 코드를 변경해야한다는 한계가 있다.
    - 또한 현대적인 컴퓨터의 경우 성능 향상을 위해 프로세스 또는 컴파일러가 종속성이 없는 읽기 또는 쓰기 작업의 순서를 바꿀 수 있으므로 임계구역 해결의 조건을 만족하지 못 할 수 있다.
    - 또한 이 방식 역시 바쁜 대기를 사용한다.



- 데커 알고리즘(Dekker's Algorithm)

  - 임계구역 문제를 해결하기 위해 Theodorus Dekker가 제안한 알고리즘이다.
  - 마찬가지로 turn을 사용한다.
    - P1은 우선 잠금을 건다.
    - P2의 잠금이 걸렸는지 확인하고, 걸리지 않았다면 임계구역에 진입한다.
    - P2의 잠금이 걸렸다면 누가 먼저인지 turn을 통해 확인한다(`if(turn==2)`).
    - 만약 P1의 차례라면(즉, turn==1이라면), 임계구역으로 진입한다.
    - 만약 P2가 먼저라면 P1은 잠금을 풀고 while문에 진입하여 P2가 임계구역을 벗어날때까지 대기하고, P2가 임계구역을 벗어나면 lock을 걸고(`lock1=true`) 임계구역으로 진입한다.

  ```c 
  #include <stdio.h>
  
  typedef enum {false, true} boolean;
  extern boolean lock1=false;
  extern boolean lock2=false;
  extern int tern=1;
  extern int balance;
  
  // 프로세스 P1
  main(){
      lock1=true;
      while(lock2==true){
          if(turn==2) {
              lock1=false;
              while(turn==2);
              lock1=true;
          }
      }
      balance=balance+10
      turn=2;
      lock1=false;
  }
  
  // 프로세스 P2
  main(){
      lock2=true;
      while(lock1==true){
          if(turn==1) {
              lock2=false;
              while(turn==1);
              lock2=true;
          }
      }
      balance=balance+10
      turn=1;
      lock2=false;
  }
  ```

  - 한계
    - 임계구역 해결의 세 가지 조건을 모두 만족하지만 매우 복잡하다는 문제가 있다.
    - 프로세스가 증가함에 따라 공유 변수도 늘어나고 전체적인 코드도 복잡해진다.
    - 또한 이 역시 바쁜 대기를 사용한다는 문제가 있다.



- 세마포어(Semaphore)

  - 이전 알고리즘들의 문제점
    - 앞의 알고리즘들은 모두 바쁜 대기를 사용하여 자원을 낭비한다.
    - 프로세스가 증가할수록 코드의 복잡도가 올라간다.
  - 세마포어
    - 이전 알고리즘들의 문제점을 해결하기위해 Edsger Dijkstra가 제안한 알고리즘이다.
    - 임계구역에 진입하기 전에 flag를 사용중으로 변경한 후 임계구역으로 들어간다.
    - 이후 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 대기한다.
    - 프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보낸다.
    - 세마포어는 다른 알고리즘과 달리 임계구역이 잠겼는지 직접 점검하지 않아도 되므로, 바쁜 대기를 할 필요가 없다.
  - Pseudo code
    - 세마포어는 사용 전에 초기 설정을 하는데, 이 때 공유 가능한 자원의 수를 받는다(`Semaphore(n)`).
    - 임계구역에 진입하기 전에 임계구역을 사용중이라는 표시를 하고(`P()`), 임계구역을 나올 때 임계구역이 비었다는 표시를 한다(`V()`).

  ```python
  Semaphore(n)
  P()
  # 임계구역
  V()
  ```

  - 작동 과정
    - `Semaphore(n)`를 통해 현재 사용 가능한 자원의 개수를 저장하는 전역 변수 RS를 n으로 초기화한다.
    - `P()`를 실행하여, RS가 0보다 크면(가용한 자원이 있으면) 1만큼 감소시키고 임계구역에 진입하고, 0이면 0보다 커질 때 까지 기다린다.
    - `V()`를 통해 RS값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입하라는 wake_up 신호를 보낸다.
    - 세마포어에서 잠금이 해제되기를 기다리는 프로세스는 중단된 상태로 세마포어 큐에 저장되어 있다가 wake_up 신호를 받으면 큐에서 나와 다시 실행되며 임계구역에 진입한다.
    - 세마포어 큐에 저장될 때 프로세스는 중단된 상태가 되므로 바쁜 대기가 발생하지 않는다.
  - 문제점
    - 세마포어의 문제는 세마포어 자체의 문제라기 보다는 구현상의 실수가 발생했을 때  임계구역 해결의 조건을 위배하게 된다는 것이다.



- 모니터

  - 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스들을 동기화시킨다.
    - 임계구역에 접근하고자 하는 프로세스는 `P()`나 `V()`를 직접 사용하지 않고, 인터페이스를 통해 모니터에 작업 요청을 한다.
    - 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만 해당 프로세스에 알려준다.

  - 구현상의 실수가 발생하면 임계구역 해결의 조건을 위배하게 되는 세마포어의 문제점을 극복하기 위해 사용한다.
    - 즉, 정확히 구현된 세마포어를 모니터에 구현해두고, 세마포어를 사용하기 위한 인터페이스를 프로세스들에게 제공하여 프로세스들이 각기 세마포어를 구현함으로써 발생할 수 있는 문제를 방지하기 위해 사용한다.

  



