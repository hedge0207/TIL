- DSL(Domain-Specific Language, 도메인 특화 언어)
  - 특정 분야에 최적화된 프로그래밍 언어.
    - 특정한 목적이 있고 해당 목적의 달성만을 위해서 사용되는 언어
    - SQL의 경우 DB를 조작하는 데 사용하지만 그 이외의 목적으로는 사용하지 않는 DSL이다.
  - 해당 분야 또는 도메인의 개념과 규칙을 사용한다.
  - Python, Java 등의 범용 언어보다 덜 복잡하다.



# SSL과 TLS

> https://kanoos-stu.tistory.com/46
>
> https://12bme.tistory.com/80

- SSL(Secure Scokets Layer)
  - 원래 웹상의 데이터는 누구나 읽을 수 있는 일반 텍스트 형식으로 전송되었다.
  - 이러한 문제때문에 인터넷 통신의 개인정보 보호, 인증, 데이터 무결성을 보장하기 위해 Netscape가 1995년 처음으로 SSL을 개발하였다.
  - SSL은 암호화 기반 인터넷 보안 프로토콜이다. 
  - 전달되는 모든 데이터를 암호화하고 특정한 유형의 사이버 공격도 차단한다.
  - 다만 1996년 3.0 이후 업데이트가 되지 않고 있으며, 알려진 취약점들이 다수 존재해 앞으로 사라질 것으로 보인다.



- TLS

  - TLS 는 SSL의 업데이트 버전으로 SSL의 최종버전인 3.0과 TLS의 최초버전의 차이는 크지않다.
  - 그럼에도 이름이 바뀐것은 SSL을 개발한 Netscape가 업데이트에 참여하지 않게 되어 소유권 변경을 위해서이다.
  - 아직까지는 SSL이라는 명칭이 더 널리 사용된다.

  - SSL/TLS 를 사용하는 웹사이트 URL은 HTTP 대신 HTTPS가 사용된다.



- SSL 인증서
  - 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서.
  - SSL 인증서의 역할
    - SSL 인증서는 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다. 
    - SSL 통신에 사용할 공개키를 클라이언트에 제공한다.
  - 이러한 역할을 하는 민간 기업들을 CA(Certificate Authority)라고 부른다.
    - 당연히 아무 기업이나 될 수는 없고 엄격하게 공인된 기업들만 참여가 가능하다.
  - 다음과 같은 정보가 포함되어 있다.
    - 인증서를 발급한 CA, 서비스의 도메인 등의 서비스 관련 정보.
    - 공개키의 암호화 방법 등 서버측의 공개키에 대한 내용
    - 서비스의 도메인, 공개키 등의 정보는 서비스가 CA로부터 SSL 인증서를 구매할 때 제출해야한다.
    - 당연히 위의 정보들은 CA의 비공개키에 의해서 암호화된다.
  - 브라우저는 CA에 대한 정보를 가지고 있다.
    - 브라우저는 공인된 CA들에 대한 정보를 가지고 있다.
    - 웹 브라우저가 서버에 접속할 때 서버는 가장 먼저 인증서를 제공한다.
    - 브라우저는 이 인증서의 발급 기관(CA)가 자신의 CA 리스트에 있는지 확인한다.
    - CA 리스트에 있다면 해당 CA의 공개키를 활용하여 인증서를 복호화한다.
    - CA의 공개키에 의해서 인증서가 정상적으로 복화화 된다는 것은 해당 인증서가 CA의 비공개키에 의해 암호화 되었다는 것을 보장한다.



- 대칭키와 비대칭키(혹은 공개키)

  > https://12bme.tistory.com/80

  - key
    - 암호를 만드는 행위인 암호화를 진행할 때 사용하는 일종의 비밀번호를 키라 부른다.
    - 이 키에 따라서 암호화된 결과가 달라지기에 키를 모르면 암호를 푸는 행위인 복호화를 할 수 없다. 
  - 대칭키
    - 동일한 키로 암호화와 복호화를 진행하는 암호화 기법에 사용되는 키.
    - 암호를 주고 받는 사람들 사이에 대칭키를 주고 받기 어렵다는 문제가 있다.
    - 대칭키가 유출될 경우 암호화된 내용을 복호화할 수 있기에 암호화가 의미가 없어진다.
  - 비대칭키(혹은 공개키)
    - 암호화할 때와 복호화할 때 각기 다른 키를 사용하는 암호화 방식에 사용되는 키를 의미한다.
    - A, B 두 개의 키가 있을 때, A키로 암호화하면 B키로 복호화할 수 있고, B키로 암호화하면 A키로 복호화할 수 있다.
    - 두 개의 키 중 하나를 비공개키(private key, 개인키, 비밀키)로 하고, 남은 하나를 공개키(public key)로 지정하여 비공개키는 자신만 가지고 있고, 공개키를 타인에게 공개한다.
    - 공개키가 유출된다고해도 비공개키를 모르면 복호화가 불가능하기에 대칭키보다 안전한 방식이다.
  - 비공개키는 전자서명에도 사용되는데 원리는 다음과 같다.
    - 비공개키의 소유자는 비공개키를 이용해서 정보를 암호화 한 후에 공개키와 함께 암호화된 정보를 전송한다. 
    - 정보와 공개키를 획득한 사람은 공개키를 이용해서 암호화된 정보를 복호한다. 
    - 이 과정에서 공개키가 유출된다면 의도하지 않은 공격자에 의해서 데이터가 복호화 될 위험이 존재함에도 비공개키를 이용하여 정보를 암호화해서 보내는 이유는 이 과정이 데이터를 보호하는 것이 목적이 아니기 때문이다.
    - 암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키에 의해서 암호화 되었다는 것을 의미한다. 
    - 즉 공개키가 데이터를 제공한 사람의 신원을 보장해주게 된다. 



- SSL의 암호화
  - SSL은 대칭키 방식과 비대칭키 방식(공개키 방식)을 모두 사용한다.
    - 클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화한다.
    - 그리고 해당 대칭키를 비대칭키 방식으로 암호화해서 주고 받는다.
  - 두 방식을 모두 사용하는 이유는 다음과 같다.
    - 공개키 방식이 많은 컴퓨터 파워를 사용하기 때문이다. 
    - 만약 공개키를 그대로 사용하면 많은 접속이 몰리는 서버는 매우 큰 비용을 지불해야 할 것이다. 
    - 반대로 대칭키는 암호를 푸는 열쇠인 대칭키를 상대에게 전송해야 하는데, 암호화가 되지 않은 인터넷을 통해서 키를 전송하는 것은 위험하다. 
    - 따라서  속도는 느리지만 데이터를 안전하게 주고 받을 수 있는 공개키 방식으로 대칭키를 암호화하고, 실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받는 것이다.



- SSL의 동작 과정
  - Client hello
    - 클라이언트가 서버에 접속하는 단계
    - 클라이언트에서 생성한 랜덤 데이터, 클라이언트가 지원하는 암호화 방식, 세션 아이디 등을 서버로 전송한다.
    - 클라이언트가 지원하는 암호화 방식을 전송하는 이유는 서버와 클라이언트 사이에 지원하는 암호화 방식에 차이가 날 수 있기에 어떤 방식으로 암호화 할지 합의하기 위해서다.
    - 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하는데, 이 때 사용하기 위해 세션 아이디를 전송한다.
  - Server hello
    - 서버가 Client hello에 대한 응답을 클라이언트로 보낸다.
    - 서버에서 생성한 랜덤 데이터, 서버가 선택한 클라이언트의 암호화 방식, SSL 인증서를 클라이언트로 전송한다.
  - 인증서 확인
    - 서버가 전송한 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. 
    - 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호한다.
    - 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된다.
    - 또한 Client hello 단계에서 클라이언트가 생성한 랜덤 데이터와 Server hello 단계에서 서버가 생성한 랜덤 데이터를 조합하여 pre master secret이라는 키를 생성한다.
    - pre master secret는 실제로 주고 받을 데이터를 암호화 할 때 사용한다.
    - pre master secret는 대칭키이기 때문이 절대 제 3자에게 노출되어서는 안된다.
  - 클라이언트는 pre master secret를 서버의 공개키(서버가 보낸 인증서 안에 담겨 있다)로 암호화해서 서버로 전송한다. 
    - 서버는 자신의 비공개키로 이를 복호화하여 저장한다.
    - 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret값으로 만든다.
    - master secret 값을 사용하여 session key를 생성하는데, 이 session key 값을 사용해서 서버와 클라이언트는 대칭키 방식으로 데이터를 암호화해서 주고 받게 된다.
    - 여기까지 완료되면 클라이언트와 서버 사이의 handshake 단계가 종료된다.
  - 세션 단계
    - 세션은 실제로 서버와 클라이언트가 데이터를 주고받는 단계이다. 
    - 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한 것이다. 
    - 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.
  - 세션 종료
    - 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.
    - 이 때 통신에 사용된 대칭키인 세션키를 폐기한다.





- statement(문)와 expression(표현식)
  - expression
    - 하나 이상의 값으로 표현될 수 있는 코드를 말한다.
    - 평가가 가능해서 하나의 값으로 환원된다.
    - 예를 들어 `3+3`이라는 표현식은 평가 된 후 6이라는 값으로 환원된다.

  - statement
    - 실행 가능한 최소한의 독립적인 코드 조각을 말한다.
    - 표현식과 달리 평가와 평가에 따른 값의 환원이 존재하지 않는다.

  - expression은 statement에 포함되는 개념이다.
    - 즉 statement 중 평가되어 값을 반환하는 것들을 expression이라 부른다.




- 컴파일과 런타임
  - 컴파일: 소스 코드를 작성하고 해당 소스 코드를 기계어 코드로 변환하여 실행 가능한 프로그램이 되기 위한 편집 과정.
  - 런타임: 컴파일 과정을 마친 프로그램은 사용자에 의해 실행되며, 이러한 응용프로그램이 동작되는 시점을 런타임이라 부른다.




- 컴파일과 인터프리터
  - 컴파일러: 한 언어에서 다른 언어로 번역하는 역할을 수행, 프로그래밍 언어를 기계어 혹은 바이트 코드 등으로 번역하는 역할에 국한된 의미가 아니다 Java를 C로 번역한다면 이 역시 컴파일이라 할 수 있다.
    - 컴파일러가 실행되면 프로그래밍 언어를 번역해서 하나의 바이너리(혹은 어셈블리)파일로 저장하고 실제 프로그래밍 실행(런타임)은 이 파일을 실행함으로써 일어난다.
    - 즉 통으로 번역하고 번역한 파일을 실행한다.
    - 장점: 바이너리를 실행하기에 실행 속도가 인터프리터에 비해 빠르다.
    - 단점: 수정사항이 생길 때 마다 다시 컴파일을 진행해야 한다.
    - C, C++, Java 등은 컴파일 언어에 속한다.
    - Java의 경우 약간은 애매한 측면이 있다 컴파일러로 통으로 번역을 해 .class 파일을 생성한 뒤 .class 파일을 인터프리터를 통해 한 줄씩 실행한다.
  - 인터프리터:  번역해야 할 파일을 받아 한 줄씩 실행시키는 역할을 수행
    - 한 줄씩 번역하고 한 줄씩 실행한다.
    - 장점: 컴퓨터 마다 컴파일을 해주지 않아도 된다(플랫폼 독립적이다)
    - 단점: 컴파일 언어에 비해 속도가 느리다.
    - Python, Javascript, Ruby 등이 인터프리터 언어에 속한다.



- 배치 프로그램(Batch Program)

  - 정의: 사용자와 상호 작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방법

  - 배치 프로그램의 필수 요소
    - 이벤트 배치: 사전에 정의해 둔 조건 충족 시 자동으로 실행
    - 온디맨드 배치: 사용자의 명시적 요구가 있을 때마다 실행
    - 정기 배치: 정해진 시점(주로 야간)에 정기적으로 실행
  - 배치 스케줄러
    - 일괄 처리를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구.



- 데이터 마이닝(Data Mining)
  - 정의: 대용량의 데이터로부터 사용자의 요구사항에 맞는 의미있는 정보와 지식을 분석하여, 추출하는 방법
  - 등장 배경
    - 기술적 측면: 프로세싱 속도 및 자료저장 구조, 기계학습(ML)기술의 발전, 대량의 데이터 축적 및 데이터마이닝 도구의 발전
    - 비즈니스 측면: Mass 마케팅에서 Target 마케팅으로 패러다임 변화, 대량의 데이터로부터 의미있는 정보 추출을 통한 기업의 새로운 비즈니스 창출/개선/활용.



- 웹 마이닝(Web Mining)
  - 정의: 웹 환경에서 얻어지는 웹 문서, 고객의 정보 및 데이터로부터 특정 행위, 패턴 등의 유용한 정보를 이용하여 마케팅 및 의사결정에 활용하기 위한 마이닝 기법
  - 특징
    - 대용량: 대량의 웹로그를 기반으로 정보를 수집, 자료를 정제 및 클리닝 수행
    - 실시간성: Batch 작업(데이터를 실시간으로 처리하는 것이 아닌 일괄적으로 처리) 성격이 강한 일반 데이터 마이닝과 구별
    - One-to-One: 고객 행위 분석을 통한 개인화 지향(데이터 마이닝은 일반화)
    - 마이닝 기법: 신경망, 연관성, 순서화, 군집화, 의사결정 등에 마이닝 기법 사용



- BCP(Business Continuity Planning)
  - 정의: 지진, 홍수, 천재지변 발생 시, 시스템의 복구, 데이터 복원 등과 같은 단순 복구를 포함하여 기업 비즈니스의 연속성을 보장할 수 있는 체계
  - 등장 배경
    - 재해 대비 시스템 복구 기능이 정보시스템의 필수 요소로 인식되기 시작
    - 기업의 IT 시스템 안정성에 대한 법적 규제가 강화되는 추세
    - 시스템 중지로 인한 영업손실 방지
    - 재해 발생 시 조직 및 개인의 업무 정의 필요
    - 고객 정보 보호 및 업무 연속성 확보를 위한 안정장치 마련
    - 시스템 중단 시 발생하는 기업 이미지 실추 예방
  - 주요 계획
    - 재해 예방: 재해 발생 전 재해 발생 요인에 대응, 위기 관리를 통해 사전에 위기를 정성적, 정량적으로 분석
    - 대응 및 복구: 재해에 대한 정성적, 정량적 평가 항목을 도출, BIA(Business Impact Analysis)를 통한 파급 효과 분석 및 대응 방안 수립, Contingency Plan을 통한 복구 수립



- BCM(Business Continuity Management)
  - 정의: 예기치 않은 상황에서도 비즈니스를 지속적으로 운영하여 비즈니스의 연속성을 보장할 수 있는 경영 방식
  - 특징
    - 복원 능력(Resilience): 업무 중단 발생 시 견뎌낼 수 있는 능력
    - 반복 훈련(Simulation): 계획이 예상대로 수행되고 개선됨을 보장
    - 업무 중단 관리: IMP(Incident Management Plan, 사고 확산 통제), BCP를 통해 업무 중단 관리



- DRS(Disaster Recovery System)
  - 정의: 정보 시스템에 대한 비상 대비체계 유지와 각 업무 조직별 비상사태에 대비한 복구계획 수립을 통한 업무 연속성을 유지할 수 있는 체제
  - 필요성
    - 재해 상황에서 재해복구를 통한 서비스 연속성 확보
    - 연속성 확보를 통한 기업 신뢰도 확보
  - 구축 절차
    - 1단계: 업무 영향 분석
    - 2단계: 재해 복구 전략 수립
    - 3단계: 시스템 구축 및 복구 계획 수립
    - 4단계: 운영 및 모의 훈련



- BIA(Business Impact Analysis)
  - 재해 발생시 영향을 미칠 수 있는 위험을 정의하고, 업무 중단 영향에 대한 정량적, 정성적 분석을 통해 복구 우선순위를 도출하는 과정
  - 목적
    - 핵심 우선순위 결정: 모든 핵심점 사업의 프로세스에 우선순위를 부여함
    - 중단 시간 산정: 경쟁력 있는 기업으로 살아남기 위해 견딜 수 있는 최장시간의 산정
    - 자원 요구: 핵심 프로세스에 대한 지원 요구사항 정의, 시간에 민감한 프로세스에 대부분의 자원을 할당



- 클라우드 컴퓨팅

  - 정의: 하드웨어, 소프트웨어, 데이터 등의 IT 자원이 웹을 통해 표준화된 서비스의 형태로 제공되는 모델 

  - 클라우드로 제공되는 서비스에 대해 사용자는 언제, (IP지원이 되는) 어떤 장비를 통해서든, 원하는 만큼의 서비스를 골라서 사용할 수 있으며, 사용량에 기반하여 비용을 지불하는 비즈니스 모델

  - 3가지 서비스 모델

    > 사진 출처: https://www.redhat.com/ko/topics/cloud-computing/what-is-paas

    ![iaas-paas-saas-diagram](https://user-images.githubusercontent.com/60123095/108083318-4641ac80-70b6-11eb-9b4a-3cb3401ab225.png)

    - SaaS(Software as a Service)
    - PaaS(Platform as a Service)
    - IaaS(Infrastructure as a Service)

  - 4가지 전개 모델

    - Private Cloud: 자사의 내부에 직접 클라우드 인프라를 구축하여 내부에 소속된 사람만 이용
    - Community Cloud: 공통의 관심사를 가진 특정 커뮤니티의 여러 조직이 클라우드를 함께 이용
    - Hybrid Cloud: 내부에 사설 클라우드를 구축하여 운영하다가 필요에 따라 외부의 공용 클라우드를 함께 이용 하는 것
    - Public Cloud: 누구나 함께 이용할 수 있게 구축된 대규모 클라우드서비스

  - 5가지 특징

    - 사용자 중심 서비스: 사용자가 사용한 만큼 비용을 지불
    - 네트워크 접근: 네트워크 기반의 서비스
    - 신속한 서비스 제공
    - 계량 가능한 서비스
    - 컴퓨팅 자원 공유

  - 모바일 클라우드

    - 클라우드 컴퓨팅을 모바일 서비스에 접목시킨 것
    - 구성: 단말, 애플리케이션 제공자, 클라우드 컴퓨팅



- NoSQL	
  - 전통적인 관계형 데이터베이스 보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공
  - NoSQL 데이터베이스는 단순 검색 및 추가 작업을 위한 매우 최적화된 키 값 저장 공간.
  - Not only SQL이라 불리기도 한다.
  - MongoDB가 대표적이다.



- TPS(Transaction for second)
  - 초당 트랜잭션의 개수
  - 일정 기간동안 실행된 트랜잭션의 개수를 구하고 다시 1초 구간에 대한 값으로 변경하여 구한다.



- boiler plate code
  - 판에서 찍어낸 듯한 코드라는 의미이다.
  - 아래 조건을 만족하는 코드를 일컫는다.
    - 꼭 필요하고 간단한 기능을 위한 코드다.
    - 반복적으로 사용해야 하는 코드다.
    - 중복되어 많은 양의 코드가 생산된다.



-  스키마(Schema)과 스킴(Scheme)
   - 스키마는 대략적인 계획이나 도식을 뜻한다.
   - 스킴은 구체적이고 확정된 것을 말한다.