# Design Pattern

- Design pattern

  - 소프트웨어를 개발하면서 공통으로 발생하는 문제를 해결하기 위해 자주 사용되는 방법들을 정리한 패턴이다.

  - 생성, 구조, 행위 패턴이 있다.
    - 생성: 객체 인스턴스의 생성과 관련된 패턴
    - 구조: 더 큰 구조를 생성하기 위해 클래스나 객체의 조합을 다루는 패턴
    - 행위: 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴



## 생성

- Builder
  - 복잡한 인스턴스를 조립하여 만드는 구조
  - 객체를 생성하는 방법과 객체를 구현하는 과정을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 패턴



- Prototype
  - 일반적인 원형을 만들고, 필요한 부분만 수정하여 사용하는 패턴
  - 기존 객체를 복제하여 새로운 객체 생성



- Factory Method
  - 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 패턴
  - 생성할 객체의 클래스를 국한하지 안고 객체를 생성



- Abstract Factory
  - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공.
  - 동일한 주제의 다른 팩토리를 묶음



- Singleton
  - 객체를 하나만 생성하도록 하며 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴
  - 한 클래스에 한 객체만 존재하도록 제한



## 구조

- Bridge
  - 기능의 클래스 계층과 구현의 클래스 계층을 연결
  - 구현뿐 아니라 추상화 된 부분까지 변경해야 하는 경우 사용



- Decorator
  - 구현되어 있는 클래스에 필요한 기능을 추가
  - 상속의 대안으로 사용



- Facade
  - 복잡한 시스템에 대하여 단순한 인터페이스를 제공하여 사용자와 시스템간 결합도를 낮춰 시스템 구조에 대한 파악일 쉽게 하는 패턴
  - 통합된 인터페이스 제공



- Flyweight
  - 다수의 객체를 생성할 경우 모두가 갖는 본질적인 요소를 클래스화하여 공유
  - 메모리 절약과 클래스 경량화 목적
  - 가상 인스턴스 제공



- Proxy
  - 미리 할당하지 않아도 상관 없는 것들을 실제 사용할 때 할당하게 하는 패턴
  - 정보 은닉의 역할도 수행한다.



- Composite
  - 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴
  - 복합 객체와 단일 객체를 동일하게 취급



- Adapter
  - 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
  - 상속을 이용하는 클래스 패턴과 위임을 이용하는 인터페이스 패턴의 두 가지 형태로 사용된다.



## 행위

- Mediator
  - 서로 간 통신 시 중간에서 이를 통재하고 지시할 수 있는 역하를 하는 중재자를 두는 패턴.
  - 통신의 빈도수를 줄여준다.



- Interpreter
  - 여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴



- Iterator
  - 컬렉션 구현 방법을 노출시키지 않으면서도 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 패턴



- Template Method
  - 상위 클래스에는 추상 메서드를 통해 기능의 골격을 정의, 하위 클래스에는 세부 처리를 구체화 하는 패턴



- Observer
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들의 내용도 자동으로 갱신되는 패턴



- State
  - 객체의 상태에 따라 행위의 내용이 변경되는 패턴



- Visitor
  - 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 생성하고, 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행



- Command
  - 실행될 기능을 캡슐화하여 주어진 여러 기능을 수행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
  - 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행됨.



- Strategy
  - 알고리즘군을 정의하고 같은 알고리즘을 하나의 클래스로 캡슐화한 후 필요할 때 서로 교환해서 사용.
  - 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환



- Memento
  - 객체의 정보를 저장할 필요가 있을 때 적용
  - Undo 기능을 개발할 때 사용



- Chain of Responsibility
  - 한 요청을 2 개 이상의 객체에서 처리