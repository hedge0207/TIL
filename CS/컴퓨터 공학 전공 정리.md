# 소프트웨어의 이해

- 소프트웨어
  - 정의 컴퓨터 시스템을 효율적으로 운영하기 위해 개발된 프로그램의 총칭.
  - 소프트웨어의 구성 요소: source code, 산출물(자료구조, DB, 테스트 결과 등), 매뉴얼



- 소프트웨어의 분류

  - 정보 관리 소프트웨어

    - 정보 제공 및 관리 소프트웨어
    - DB에 자료를 저장 후 검색을 통해 사용자가 원하는 형태로 정보를 제공
    - 예시: 인터넷 뱅킹, 대학의 종합정보 시스템 등

  - 제어 소프트웨어

    - 각종 센서를 이용하거나 기기들의 동작을 제어하는 소프트웨어
    - 예시: 교통 신호 제어, 의료 기기 제어, 공장 장비 제어 등

  - 임베디드 소프트웨어

    - 장비나 기기에 내장된 형태의 소프트웨어

    - 예시: 가전제품내의 소프트웨어, 각종 공정 제어 시스템 내의 소프트웨어



- 소프트웨어의 특징
  - 제조가 아닌 개발
    - 제조: 정해진 틀에 맞춰 일정하게 생산하는 것, 많은 인력이 필요하고 능력별 결과물 차이가 근소함
    - 개발: 개인의 능력에 따라 결과물 차이가 매우 크다.
  - 소모가 아닌 품질 저하
    - 하드웨어: 오래 사용하면 부품이 닳고, 고장 발생 빈도가 높어지고, 기능도 저하된다.
    - 소프트웨어: 오래 사용해도 닳지 않고, 고장 발생 빈도 낮고, 기능도 동일하다.



- 소프트웨어 개발의 문제점
  - 아래 내용은 단순히 몇 십년 전에 개발된 테트리스와 현재 개발중인 다른 게임들을 비교해보면 차이를 확연히 알 수 있다.
  - 새로운 소프트웨어에 대한 사용자 요구가 증가하고 있으나 소프트웨어 개발의 발전 속도가 이를 따라가지 못함
  - 소프트웨어 개발에도 관리가 필요
    - 비용 관리, 일정 관리, 개발자 관리
    - PMBOK를 활용한 적극적인 프로젝트 관리가 필요하다.
    - PMBOK(Project Management Body Of Knowledge): 프로젝트 관리 협회에서 발간하는 프로젝트 관리를 위한 일련의 표준 용어 및 지침.
  - 개발 과정이 복잡해지고 있다.
  - 참여 인력이 많아지고 있다.
  - 개발 기간이 길어지고 있다.



- 소프트웨어 공학

  - 정의: 품질 좋은 소프트웨어를 경제적으로 개발하기 위해 계획을 세우고, 개발하며, 유지 및 관리하는 과정에서 공학, 과학, 수학적 원리와 방법을 적용하여 필요한 이론과 기술 및 도구들에 관해 연구하는 학문.

  - 목표: 개발 과정에서의 생산성 향상과 고품질 소프트웨어 생산을 통한 사용자의 만족도 향상.
  - 특성: 정해진 기간, 주어진 비용이라는 제약사항 내에서 개발을 해야 한다. 따라서 효율성을 향상시키려는 노력이 필요







# 소프트웨어 개발 생명 주기(SDLC, System Development Life Cycle)

- 폭포수 모델(Waterfall Model): S/W개발을 단계적으로 정의한 체계이며 대표적인 선형 순차적 모델이다. 가장 오래되고 널리 사용되고 있다.
  - 단계
    - 계획: 사용자의 문제 정의 및 전체 시스템이 갖춰야 할 기본 기능과 성능 요건을 파악
    - 요구분석: 사용자의 문제를 구체적으로 이해
    - 설계: 소프트웨어의 구조를 명확히 밝혀 구현을 준비하는 단계
    - 구현: 프로그래밍을 하는 단계
    - 테스트: 소프트웨어를 테스트하는 단계
    - 유지보수: 소프트웨어를 발전시키는 단계
  - 장점
    - 관리 용이
    - 체계적 문서화 가능
    - 요구사항 변화가 적은 프로젝트에 적합
  - 단점
    - 각 단계는 앞 단계가 완료되어야 수행 가능
    - 각 단계의 결과물이 완벽해야 다음 단계에 오류를 넘겨주지 않는다.
    - 사용자가 중간에 가시적인 결과를 볼 수 없다.



- 프로토타입 모델(Prototyping Model)
  - 점진적으로 시스템을 개발해 나가는 접근 방식, 진화적 프로세스 모델의 대표적 모델이다.
  - 프로토타입을 만들어 고객과 사용자가 함께 평가한 후 개발될 소프트웨어의 요구사항을 정제하여 보다 완전한 요구명세서를 완성하는 방식
  - 빠른 설계-프로토타입 제작-사용자에게 평가를 받음-사용자가 바라던 것이 아닐 경우 요구 사항 재정의, 맞을 경우 본격적인 개발 시작
  - 장점
    - 사용자 요구가 충분히 반영된다.
    - 프로토타입 사용을 통한 새로운 요구사항 발견
    - 프로토타입 사용을 통한 완성품 예측 가능
  - 단점
    - 인력 및 자원 산정의 어려움
    - 프로토타입 과정에 대한 통제 및 관리의 어려움
    - 불명확한 개발 범위로 인한 개발 종료 시점 및 목표의 불확실성



- 나선형 모델(Spiral Model)
  - 프로토타입 모델에 위험 분석을 더한 모델
  - 요구사항 분석 및 계획 수립 - 위험 분석 - 개발 및 검증 - 사용자 평가 순으로 반복
  - 위험 분석 단계에서 요구사항의 빈번한 변경, 경험이 부족한 팀원, 팀워크가 부족한 협업, 프로젝트 관리의 부족 등의 위험 요소를 분석한다.
  - 장점
    - 위험 요소 감소와 이를 통한 프로젝트 중단 확률 감소
    - 사용자의 요구가 충분히 반영되는 개발 과정
  - 단점
    - 반복적 개발에 의한 프로젝트 기간 연장의 가능성
    - 반복 회수 증가에 따른 프로젝트 관리의 어려움
    - 위험 전문가 필요에 따른 부담



- 통합 프로세스(UP) 모델
  - 개발의 모든 단계를 무자르듯 자르는 것이 아니라 모든 단계들이 유기적으로 연결되어 있다는 것을 인지하고 동시에 진행하는 방식
  - 단계
    - 도입 단계: 요구사항 분석 및 문제 정의
    - 구체화 단계: 설계
    - 구축 단계: 프로그래밍
    - 전이 단계: 테스트, 배포, 운영 등
    - 도입/구체화/구축/전이 단계의 공통 작업



- 애자일 프로세스 모델

  - agile: 날렵한, 민첩한
  - 정의: 고객의 요구에 민첩하게 대응하고 그때 그때 주어지는 문제를 풀어나가는 방법론, 반복적인 개발을 통한 잦은 출시를 목표로 한다.
  - 기본 가치
    - 프로세스와 도구 중심이 아닌, 개개인과의 상호 소통 중시
    - 문서 중심이 아닌, 실행 가능한 소프트웨어 중시
    - 계약과 협상 중심이 아닌, 고객과의 협력 중시
    - 계획 중심이 아닌, 변화에 대한 민첩한 대응 중시

  - 단계(아래 과정을 반복한다)
    - 설계
    - 개발
    - 테스트
    - 데모 출시
  - 스크럼 개발 프로세스
    - 소프트웨어 개발보다는 팀의 개선과 프로젝트 관리를 위한 애자일 방법론
    - 구체적인 프로세스를 명확하게 제시하지 않음
    - 개발 팀(조직)을 운영하는 효율적인 운영 방식(지침)
    - 일일 회의를 통한 팀원들 간의 신속한 협조와 조율이 가능하다.
    - 다른 개발 방법론에 비해 단순하고 실천 지향적이다.
    - 프로젝트 진행 현황 공유를 통해 신속하게 목표와 결과를 추정 가능하고 목표에 맞는 변화를 시도 가능하다.
  - XP(eXtreme Programming)
    - 의사소통, 피드백, 단순함, 용기, 존중에 가치를 두고 있는 애자일 방법론
    - 고객의 참여, 짧은 개발 과정의 반복을 극대화하는 방법
  - 단순하게 둘 다 애자일 방법론이라는 공통점이 있고 스크럼은 팀에, XP는 고객에 더 중점을 둔다고 생각하면 된다.







# 소프트웨어 개발 단계

## 프로세스

- 프로제스
  - 정의: 일이 처리되는 과정이나 공정, 주어진 일을 해결하기 위한 목적으로 그 순서가 정해져 수행되는 일련의 절차
  - 목적: 이전에 얻은 노하우를 바탕으로 시행착오를 감소시켜 빠르게 개발하기 위함, 가이드 역할



- 소프트웨어 프로세스의 정의

  - 작업(task):SW를 개발할 때 일을 수행하는 작은 단위
  - 작업(task) 순서의 집합+제약 조건(일정, 예산, 자원)을 포함하는 일련의 활동(activity)

  - 좁은 의미의 소프트웨어 개발 프로세스
    - SW 제품을 개발할 때 필요한 절차, 과정, 구조
    - 사용자의 요구사항을 SW시스템으로 구현하기 위한 일련의 활동
  - 넓은 의미의 소프트웨어 개발 프로세스
    - 절차, 구조, 방법, 도구, 참여자까지 모두 포함
    - SW개발 목적을 이루는데 필요한 통합적 수단



- 소프트웨어 프로세스 모델
  - 정의
    - SW를 어떻게 개발할 것인가에 대한 전체적인 흐름을 체계화한 개념
    - 공장에서 제품을 생산하듯이 소프트웨어 개발의 전 과정을 하나의 프로세스로 정의한다.
    - 주어진 예산과 자원으로 개발하고 관리하는 방법을 구체적으로 정의한다.
  - 특징
    - 개발 계획 수립부터 최종 폐기때까지의 전 과정을 다룬다.
    - 순차적인 단계로 이루어진다.
  - 목적
    - 궁극적으로 고품질의 소프트웨어 제품 생산을 목적으로 한다.
  - 역할
    - 프로젝트에 대한 전체적인 기본 골격을 세워준다.
    - 일정 계획을 수립할 수 있다.
    - 개발 비용을 포함한 여러 자원을 산정하고 분배할 수 있음
    - 참여자 간에 의사소통의 기준이 될 수 있다.
    - 용어의 표준화를 가능케 한다.
    - 개발 진행 상황을 명확히 파악 가능하다.
    - 각 단계 별로 생성되는 문서를 포함한 산출물을 활용하여 검토할 수 있게 해준다.



## 소프트웨어 개발 계획(무엇을 만들 것인가)

- 소프트웨어 개발 계획
  - 소프트웨어 개발에 필요한 비용, 기간, 자원에 대한 계획을 세우는 것
  - 계획 없는 소프트웨어 개발은 일정 지연, 비용 초과, 품질 저하, 유지보수 비용 증가 등의 문제가 발생할 수 있다.



- 문제의 정의
  - 무엇을 개발할 것인가를 결정
  - 개발의 범위를 결정
  - 프로젝트의 초기 타당성과 초기 계획을 작성할 수 있는 기초로 활용



- 타당성 분석
  - 경제적 타당성(투자 효율성, 시장성, 이 소프트웨어가 과연 팔릴지에 대한 고민)
  - 기술적 타당성(구현 가능성, 하드웨어 성능, 개발자의 기술력)
  - 법적 타당성(개발용 소프트웨어와 도구의 사용에 대한 법적 문제 검토, 지적 소유권과 프로그램 보호범에 대한 검토)



- 개발비 산정
  - 소프트웨어 개발 비용 예측은 개발자의 능력에 따라 생산성의 차이가 난다.
  - 다양한 개발 프로세스로 인한 표준화/자동화가 어렵다.
  - 위와 같은 이유들 때문에 명확한 개발비 산출이 어렵다.



- 소프트웨어 개발 비용에 영향을 주는 요소
  - 프로그래머의 자질: 초급 프로그래머와 고급 프로그래머의 생산성 차이
  - 소프트웨어 복잡도: 복잡도가 증가할 수록 개발 비용도 증가
    - 소프트웨어 크기: 크기가 증가하면 참여 인원이 증가하고 개발 기간도 길어지고 복잡도도 증가한다.
  - 가용 기간: 개발 가능한 기간, 관리자들의 잘못된 생각으로 인력/자원의 증가가 개발 기간을 단축시킨다고 생각한다.
    - 브룩스의 법칙: 지연되는 프로젝트에 인력을 더 투입하면 오히려 더 늦어진다는 이론. 3명이서 개발을 할 때에는 3명이서만 의사소통을 하면 되지만 한 명이 더 추가되면 4명이서 의사소통을 해야 하므로 의사소통의 복잡도가 증가하게 된다.
  - 요구되는 신뢰도 수준: 높은 신뢰도의 소프트웨어 개발은 개발 비용을 증가시킨다.
  - 기술 수준: 고급 언어를 사용할 경우 생산성이 증가한다.



- 개발비 산정 기법
  - 하향식 산정 기법
    - 전문가 판단 기법
    - 경험이 많은 전문가가 개발 비용을 산정
    - 짧은 시간에 개발비를 산정하거나 입찰에 응해야 하는 경우 많이 사용
    - 수학적 계산 방법보다 경험에만 의존할 경우 부정확 할 수 있음
    - 델파이 기법(전문가 합의법): 어떤 문제의 해결과 관계된 미래 추이의 예측을 위해 전문가 패널을 구성하여 수회 이상 설문하는 정성적 분석 기법

  - 상향식 산정 기법
    - 세부 작업 단위별로 비용 산정한 후 전체 비용 합산
    - 원시 코드라인 수(LOC) 기법: 원시 코드 라인 수의 비관치, 낙관치, 중간치를 측정 후 예측치를 구해 비용 산정
    - 개발 단계별 노력(effort per task) 기법: 생명주기의 각 단계별로 노력을 산정
  - 수학적 산정 기법
    - 상향식 비용 산정 기법의 하나
    - 경험적 추정 기법 또는 실험적 추정 기법
    - COCOMO 방법: SW 규모를 예측한 후 각 비용 산정 공식에 대입하여 비용 산정
    - Putnam 방법: 소프트웨어 생명 주기의 전 과정에 사용될 노력의 분포를 가정해준다.
    - 기능 점수(FP) 방법: 기능 점수를 구한 후 이를 이용해 비용 산정



- 일정 계획
  - 작업 순서, 소작업 개발 기간과 순서 등을 정한다.
  - 작업 분할 구조도(WBS, Work Breakdown Structure)
    - 프로젝트 목표를 달성하기 위해 필요한 활동과 업무를 세분화
    - 프로젝트 구성 요소들을 계층 구조로 분류
  - PERT/CPM
    - WBS의 작업 순서, 소요 기간 등을 네트워크 형태의 그래프로 표현
    - 어떤 작업이 중요한지, 일정에 여유가 있는 작업은 어떤 것인지 찾아내 중점 관리 해야 하는 작업을 명확히 하는데 사용
  - 간트 차트(Gantt chart)
    - 프로젝트 일정 관리를 위한 바 형태의 도구
  - WBS로 분석->PERT/CPM로 시각화->간트 차트로 정리



- 위험 관리 절차
  - 위험 요소 식별/위험 분석
    - 위험 요소가 발생할 가능성과 영향력을 판단
    - 과거 프로젝트의 데이터와 위험을 분석한 경험이 많은 개발자에 의존
  - 위험 계획 수립
    - 위험을 처리하는 위험 대응 방안 수립
  - 위험 감사
    - 식별된 위험 요소의 발생 확률과 변화 등을 관리
    - 예측한 위험의 실제 발생 여부 확인



- 요구 사항과 요구 분석 명세서

  - 고객 만족을 위한 분석 과정
    - 적시성
    - 유연성
    - 통합
  - 고객 만족의 개발 조건
    - 고품질
    - 정해진 기간
    - 주어진 예산
  - 요구사항: 사용자와 개발자 간에 합의한 개발 범위에서 시스템이 제공해야 하는 기능
  - 요구 분석 명세서: 개발 초기에 사용자의 요구 사항(비기능 요구 사항 포함)을 추출하여 정리한 문서
  - 요구 분석 절차
    - 자료 수집: 현행 시스템 파악, 실무 담당자 인터뷰
    - 요구 사항 도출: 수집한 자료를 바탕으로 요구 사항 도출
    - 문서화: 요구 분석 명세서 작성
    - 검증: 요구 분석 명세서 검토: 모순 사항, 빠뜨린 사항 등 점검

  - 요구 사항의 범위
    - 기능적 요구 사항
    - 비기능적 요구 사항: 품질, 제약 사항
    - 사용자 요구사항
    - 시스템 요구 사항
  - 품질
    - 신뢰성: 소프트웨어가 고장 없이 동작하는 것
    - 신뢰도 측정: 고장 간 평균 시간(MTBF)과 이용 가능성(가용성)을 척도로 사용
    - MTBF=MTTF+MTTR
    - MTBF(Mean TIme Between Failure, 고장 간 평균 시간): 고장에서 다음 고장까지의 평균 시간
    - MTTF(Mean Time To Failure, 평균 실패 시간): 수리한 후 다음 고장까지의 평균 시간
    - MTTR(Mean Time To Repair, 평균 수리 시간): 고장 발생 시점에서 수리 시까지의 평균 시간
    - 이용 가능성 = MTTF/(MTTF+MTTR)*100%
    - 이용 가능성: 주어진 시점에서 프로그램이 요구에 따라 작동되고 있을 가능성 
  - 성능
    - 사용자가 시스템에 어떤 요구를 했을 때 해당 기능을 정상적으로 수행하는 것은 물로 사용자가 원하는 조건(응답 시간, 데이터의 처리량 등)을 만족시키는 것
    - 보안성: 인증을 받지 않은 사람이 시스템에 접근하는 것을 막아 시스템과 데이터를 보호
    - 안전성: 작동하는 모든 시스템이 소프트웨어 오류로 인해 인명 피해가 발생하지 않아야 함
    - 사용성: 소프트웨어를 사용할 때 혼란스러워하거나 사용하는 순간에 고민하지 않게 하는 편의성



- 소프트웨어 개발에서의 모델
  - SW 개발에 여러 관점의 모델을 사용, UML 다이어그램 등을 이용하여 표현
  - 모델링 언어: 애매모호한 표현 등의 문제점을 해결하기 위해 모델링을 할 때 사용하는 기호, 표기법, 도구
  - 개발 방법론에 따른 모델링 언어
    - 구조적 방법론: DFD(Data Flow Diagram), DD(Data Dictionary), 프로세스 명세
    - 정보공학 방법론: DB 설계 시 표현은 ERD(Entity Relationship Diagram)
    - 객체 지향 방법론: UML(유스케이스 다이어그램) 표기법
  - 장점
    - 개발될 소프트웨어에 대한 이해도 향상
    - 이해 당사자 간의 의사소통 향상
    - 유지보수 용이
  - 단점
    - 과도한 문서 작업으로 인한 일정 지연 가능성
    - 형식적인 산출물로 전락할 가능성





## 소프트웨어 설계(어떻게 만들 것인가)/구현/테스트

### 설계

- 설계의 종류
  - 상위 설계
    - 아키텍처(구조) 설계: 시스템의 전체적인 구조
    - 데이터 설계: 시스템에 필요한 정보를 자료구조와 데이터베이스 설계에 반영
    - 시스템 분할: 전체 시스템을 여러 개의 서브 시스템으로 나눈다.
    - 인터페이스 정의: 시스템 구조와 서브 시스템들 사이의 인터페이스가 명확히 정의
    - UI 설계: 사용자가 익숙하고 편리하게 사용할 수 있도록 사용자 인터페이스 설계
  - 하위 설계
    - 각 모듈의 실제적인 내부를 알고리즘(Pseudo-code) 형태로 표현
    - 인터페이스에 대한 설명, 자료구조, 변수 등에 대한 상세한 정보를 작성



- 아키텍처 정의
  - 구성 요소
  - 구성 요소들 사이의 관계
  - 구성 요소들이 외부에 드러내는 속성
  - 구성 요소들과 주변 환경 사이의 관계
  - 구성 요소들이 제공하는 인터페이스
  - 구성 요소들의 협력 및 조립 방법



- 소프트웨어의 아키텍처
  - 소프트웨어의 전체적인 구조
  - 소프트웨어를 이루고 있는 여러 구성 요소
  - 구성 요소들의 인터페이스 간의 상호작용을 정의
  - 시스템 설계와 개발 시 적용되는 원칙과 지침



- 아키텍처 품질 속성
  - 시스템 품질 속성: 가용성, 변질 용이성, 성능, 보안성, 사용성, 테스트 용이성 등
  - 비즈니스 품질 속성: 시장 적시성, 비용과 이익, 예상 시스템 수명, 목표 시장, 신규 발매 일정 또는 공개 일정, 기존 시스템과의 통합
  - 개념적 무결성: 일관성
  - 정확성과 완전성: 사용자가 요구 하는 기능을 충족시키는 정도
  - 개발 용이성(구축 가능성): 정해진 기간 내에 완성하고, 개발 과정 중에 쉽게 변경가능 



- 아키텍처 구축 절차
  - 요구 사항 분석: 기능적, 비기능적 요구 사항 분류 및 명세
  - 아키텍처 분석
  - 아키텍처 설계: 관점 정의, 아키텍처 스타일 선택, 후보 아키텍처 도출
  - 검증 및 승인: 아키텍처 평가, 아키텍처 상세화(반복), 아키텍처 승인



- 아키텍처 모델
  - 데이터 중심형 모델
    - repository model
    - 주요 데이터를 repository 에서 중앙 관리
    - repository 와 여기에 접근하는 서브 시스템으로 구성
    - 데이터가 한 곳에 모여 있기에 데이터를 모순되지 않고 일관성 있게 관리 가능
    - 새로운 서브시스템 추가 용이
    - repository의 병목 현상 발생 가능
    - 서브 시스템과 repository  사이의 강한 결합으로 repository 변경 시 서브 시스템에 영향을 준다.
  - Client-Server 모델
    - 네트워크를 이용하는 분산 시스템 형태
    - 데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용
    - 분산 아키텍처에 유용
    - 서버: 클라이언트(서브시스템)에 서비스 제공
    - 클라이언트: 서버가 제공하는 서비스를 요청(호출) 하는 서브 시스템
  - Layering 모델
    - 기능을 몇 개의 계층으로 나누어 배치
    - 구성: 하위 계층은 서버, 상위 계층은 클라이언트 역할
  - MVC(Model View Controller) 모델
    - 중앙 데이터 구조
    - 같은 모델의 서브 시스템에 대하여 여러 뷰 서브 시스템을 필요로 하는 시스템에 적합
    - 장점: 데이터를 화면에 표현 하는 디자인(V)과 로직(M)을 분리함으로써 느슨한 결함 가능, 구조 변경 요청 시 수정 용이
    - 단점: 기본 기능 설계로 인한 클래스 수의 증라로 복잡도 증가, 속도가 중요한 프로젝트에 부적합



- 디자인 패턴
  - 자주 사용하는 설계 형태를 정형화해서 이를 유형별로 설계 템플릿을 만들어둔 것
  - 많은 개발자들이 경험상 체득한 설계 지식을 검증하고 이를 추상화하여 일반화한 템플릿
  - 장점
    - 개발자 간의 원활한 의사소통
    - 소프트웨어 구조 파악 용이
    - 재사용을 통한 개발 시간 단축
    - 설계 변경 요청에 대한 유연한 대처
  - 단점
    - 객체지향 설계/구현 위주
    - 초기 투자 비용 부담
  - GoF(Gang of Fours) 디자인 패턴
    - Creational Pattern: 객체를 생성하는데 관련된 패턴들, 객체가 생성되는 과정의 유연성을 증가시키고 코드 유지를 쉽게 한다.
    - Structural Pattern: 프로그램 구조에 관련된 패턴들, 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 활용할 수 있는 패턴들
    - Behavioral Pattern: 반복적으로 사용되는 객체들의 상호작용을 패턴화 해놓은 것들



- 모듈화

  - 모듈화: 소프트웨어 개발에서 큰 문제를 작은 단위로 나누는 것
  - 모듈: 기본적인 단위, 논리적인 기능을 수행, 독립 프로그램, 함수, 클래스 등
  - 특징
    - 다른 것들과 구별되는 독립적인 기능
    - 독립적으로 컴파일
    - 유일한 이름을 지님
    - 모듈에서 또 다른 모듈을 호출
    - 다른 프로그램에서도 모듈을 호출
  - 응집도: 모듈 내부에 존재하는 구성 요소들 사이의 밀접한 정도
    - 기능적 응집, 순차적 응집, 교환적 응집, 절차적 응집, 시간적 응집, 논리적 응집, 우연적 응집 등이 있다.
    - 위의 다양한 것들을 가이드라인으로하여 모듈화 한다.
    - 높을 수록 바람직한 설계라고 할 수 있다.
  - 결합도: 모듈과 모듈 사이의 관계에서 관련된 정도
    - 데이터 결합, 스탬프 결합, 제어 결합, 공통 결합, 내용 결합 등이 있다.
    - 이 역시 응집도의 기능적 응집, 순차적 응집 등과 마찬가지로 가이드라인이라 보면 된다.
    - 낮을 수록 바람직한 설계라고 할 수 있다.
  - 형태
    - 용도가 비슷한 것끼리 묶어놓은 라이브러리 함수, 그래픽 함수 등
    - 추상화된 자료 등

  - 장점
    - 분할정복의 원리가 적용
    - 복잡도 감소
    - 유지보수 용이
    - 오류로 인한 파급 효과를 최소화
    - 설계 및 코드를 재사용



- 방법론
  - 프로세스 지향 방법
    - 처리순서를 구조화하는 방법
    - 대표적인 모델 기법: DFD(Data Flow Design)
    - 기능이 중심(우선)이 되고 그 기능을 수행하는 데 필요한 데이터가 참조되는 형태로 구성
    - 프로세스와 데이터의 분리
    - 실세계를 컴퓨터 처리 방식으로 표현
    - 함수 중심(우선) 으로 모듈 구성
  - 데이터 지향 방법
    - 시스템이 취급하는 데이터에 관심
    - 즉 데이터가 중심(우선)이 되어 데이터를 구조화
    - 대표적인 SW 개발 방법론: 정보 공학 방법론
    - DB 설계를 위한 대표적 모델 표기법: E-R(Entity-Relationship) 다이어그램
  - 위 두 방법의 문제점
    - 변경이 미치는 영향이 크다: 프로세스와 데이터를 별개의 것으로 파악하기 때문
    - 프로그램의 복잡도 증가: 함수와 데어타가 분리되어 있기 때문
    - 프로그램 변경 시 프로그램 구조 파악 필요: 프로그래머는 프로그램의 구조와 영향을 미치는 곳도 파악해야 함
    - 재사용의 어려움: 프로세스와 데이터가 분리된 구조 때문
  - 객체 지향 방법
    - 위 문제점을 해결하기 위해 고안
    - 기능이나 데이터 대신 객체가 중심이 되어 개발
    - 데이터를 가장 먼저 찾고 그 데이터를 조작하는 메서드를 찾아 그 둘을 객체라는 이름으로 묶어 그 객체를 중심으로 모듈을 구성
    - 실세계를 사람이 생각하는 방식으로 표현한다.
    - 임의로 데이터에 접근할 수 없다.
    - 시스템은 객체들의 모임이다.
    - 요구 사항 변경에 유연한 대처가 가능하다.
    - 확장성과 재사용성이 높아진다.
    - 추상화를 통해 생산성과 품질이 향상된다.



### 구현

- 프로그래밍 언어 선정
- 코딩 규칙 설정: 높은 가독성,  간결하고 명확한 코딩, 개발 시간의 단축



### 테스트

- 테스트의 정의
  - IEEE(I Triple): 테스트는 시스템이 명시된 요구를 잘 만족하는지, 즉 예상된 결과와 실제 결과가 어떤 차이를 보이는지 수동이나 자동으로 검사하고 평가하는 작업
  - Zoha Manna: 테스트는 시스템의 명세까지 완벽하게 옳다고 확신할 수 없고, 테스트 시스템 그 자체가 맞다고 증명할 수 없기 때문에 프로그램을 완전히 테스트 할 수 없다.
  - Dahl, Dijkstra, Hoare: 테스트는 결함이 있음을 보여줄 뿐, 결함이 없음을 증명할 수는 없다.



- 결함과 오류
  - 오류: 소프트웨어 개발자에 의해 만들어지는 실수로 결함의 원인이다.
  - 결함: 오류의 결과로 고장의 원인이다.
  - 고장, 실패, 문제, 장애: 시스템이 요구 사항대로 작동하지 않는 것



- 소프트웨어 테스트
  - 소프트웨어 내에 존재하지만 드러나지 않고 숨어 있는 오류를 발견할 목적
  - 개발 과정에서 생성되는 문서나 프로그램에 있는 오류를 여러 기술을 이용해 검출하는 작업
  - 오류를 찾아내 정상적으로 실행될 수 있도록 하는 정도지 완전히 오류를 없앨 수는 없다.



- 테스트의 목표
  - 좁은 의미
    - 원시 코드 속에 남아 있는 오류를 발견하는 것
    - 결함이 생기는 것을 예방하는 것
  - 넓은 의미
    - 고객의 요구를 만족시키는지 확인하는 것
    - 고객이 사용하기에 충분한 소프트웨어라는 것을 보여주는 것
    - 소프트웨어의 신뢰성을 높이기 위한 작업



- 테스트의 분류
  - 시각에 따른 테스트
    - 확인 테스트: 각 단계에서 개발자의 시각으로 테스트, 설계도 대로 만들었는지 테스트
    - 검증 테스트: 사용자 요구 사항대로 만들었는지 테스트, 사용자의 시각에서 테스트
  - 사용 목적에 따른 테스트
    - 운영 목적 적합성 테스트
    - 수정 용이성 테스트
    - 운영 지원 용이성 테스트
  - 프로그램 실행 여부에 따른 테스트
    - 정적 테스트: 프로그램을 실행시키지 않고 코드리뷰를 통해 오류를 찾는 방법
    - 동적 테스트: 프로그램을 실행하면서 오류를 찾는 방법



