# Semantic Versioning Specification

> https://semver.org/

- Semantic Versioning specification(SemVer)
  - 소프트웨어의 버전 번호를 어떻게 정하고, 증가시킬지에 관한 명세이다.
  - Gravatars의 창시자이자 github 공동 창업자인 Tom Preston Werner가 작성했다.
  - 만든 이유
    - 시스템의 규모가 커지고 의존성이 높아질수록, 시스템을 구성하는 각기 다른 패키지들의 버전을 관리하는 것이 힘들어진다.
    - 의존성 관리를 너무 엄격하게 하면 의존하는 모든 패키지의 새 버전을 배포하지 않고는 업데이트를 할 수 없게 되고, 너무 느슨하게 관리하면, 서로 버전이 엉켜 문제가 발생한다.
    - 따라서, 버전 번호를 어떻게 정하고 증가시킬지를 명시함으로써 의존성 관리를 보다 쉽게 하는 데 그 목적이 있다.
  - 2012년 처음 작성되어 현재 널리 사용되고 있다.
    - Node의 npm이 대표적이다.
    - 모든 개념을 베르너가 처음 만든 것은 아니고, 기존 오픈소스 커뮤니티들에서 널리 사용되던 방식들을 취합하여 작성한 것이다.



- 명세
  - 유의적 버전을 사용하는 소프트웨어는 반드시 공개 API를 선언한다.
    - 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야한다.
    - 어떤 방식으로든, 정확하고 이해하기 쉬워야 한다.
  - 버전 번호는 X.Y.Z의 형태로 한다. 
    - X,Y,Z는 각각 음이 아닌 정수이다. 
    - 절대로 0이 앞에 붙어서는 안된다(e.g. 01과 같이 사용하지 않는다).
    - X는 주, Y는 부, Z는 수버전을 의미한다.
    - 각각은 반드시 증가하는 수여야한다(즉, 감소해서는 안된다).
  - 특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야한다.
    - 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.
  - 주버전 0(0.Y.Z)은 초기 개발을 위해서 사용한다.
    - 이 공개 API는 안정판으로 보지 않는게 좋다.
  - 1.0.0 버전은 공개 API를 정의한다.
    - 이후으 버전 번호는 이때 배포한 공개 API에서 어떻게 변경되는지에 따라 올린다.
  - 수버전 Z(x.y.Z | x > 0)는 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올린다.
    - 버그 수정은 잘못된 내부 기능을 고치는 것을 의미한다.
  - 공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 부버전 Y(x.Y.z | x > 0)를 올린다.
    - 공개 API의 일부가 앞으로 deprecate 될 것으로 표시한 경우에도 반드시 올려야한다.
    - 내부 비공개 코드에 새로운 기능이 대폭 추가되었거나 개선사항이 있을 때도 올릴 수 있다.
    - 부버전을 올릴 때 수버전을 올릴 때 만큼의 변화를 포함할 수도 있다.
    - 부버전이 올라가면 수버전은 반드시 0에서 다시 시작한다.
  - 공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주버전(X,Y,Z | X>0)을 올린다.
    - 부버전이나 수버전급 변화를 포함할 수 있다.
    - 주버전을 올릴 때는 반드시 부버전과 수버전을 0으로 초기화한다.
  - 수버전 바로 뒤에 `-`를 붙이고, 마침표로 구분된 식별자를 더해서 정식 정식 배포를 앞둔(pre-release) 버전을 표기할 수 있다.
    - 식별자는 반드시 아스키문자, 숫자, `-`만으로 구성한다(`[0-9A-Za-z-]`).
    - 식별자는 반드시 한 글자 이상으로 한다.
    - 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않는다.
    - 정식배포 전 버전은 관련한 보통 버전보다 우선순위가 낮다.
    - 정식배포 전 버전은 아직 불안정하며 연관된 일반 버전에 대하 호환성 요구사항이 충족되지 않을 수도 있다.
  - 빌드 메타데이터는 수버전이나 정식배포 전 식별자 뒤에 `+`기호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여서 표현할 수 있다.
    - 식별자는 반드시 아스키 문자와 숫자, `-`만으로 구성한다(`[0-9A-Za-z-]`).
    - 식별자는 반드시 한 글자 이상으로 한다.
    - 빌드 메타데이터는 버전 간의 우선순위를 판단하고자 할 때 만드시 무시해야한다.
    - 그러므로, 빌드 메타데이터만 다른 두 버전의 우선순위는 갖다.
  - 우선순위는 버전의 순서를 정령할 때 서로를 어떻게 비교할지를 나타낸다.
    - 우선순위는 반드시 주, 부, 수 버전, 그리고 정식 배포 전 버전의 식별자를 나누어 계산한다(빌드 메타데이터는 우선순위에 영향을 주지 않는다).
    - 우선순위는 다음의 순서로 차례로 비교하면서, 차이가 나는 부분이 나타나면 결정된다.
    - 주, 부, 수는 숫자로 비교한다.
    - 주, 부, 수 버전이 같을 경우, 정식 배포 전 버전이 표기된 경우의 우선순위가 더 낮다(e.g. 1.0.0-alpha < 1.0.0).
    - 주, 부, 수 ㅈ버전이 같은 두 배포 전 버전 간의 우선순위는 반드시 마침표로 구분된 식별자를 가각 차례로 비교하면서 차이를 찾는다(숫자로만 구성된 식별자는 수의 크기로 비교하고 알파벳이나 `-`가 포함된 경우에는 아스키 문자열 정렬을 하도록 한다).
    - 숫자로만 구성된 식별자는 어떤 경우에도 문자와 `-`가 있는 식별자보다 낮은 우선순위로 여겨진다.
    - 앞선 식별자가 모두 같은 배포 전 버전의 경우에는 필드 수가 많은 쪽이 더 높은 우선순위를 가진다.



- 유의적 버전의 BNF(Backus-Naur Form) 문법

  ```
  <유의적 버전> ::= <버전 몸통>
               | <버전 몸통> "-" <배포 전 버전>
               | <버전 몸통> "+" <빌드>
               | <버전 몸통> "-" <배포 전 버전> "+" <빌드>
  
  <버전 몸통> ::= <주> "." <부> "." <수>
  
  <주> ::= <숫자 식별자>
  
  <부> ::= <숫자 식별자>
  
  <수> ::= <숫자 식별자>
  
  <배포 전 버전> ::= <마침표로 구분된 배포 전 식별자들>
  
  <마침표로 구분된 배포 전 식별자들> ::= <배포 전 식별자>
                                | <배포 전 식별자> "." <마침표로 구분된 배포 전 식별자들>
  
  <빌드> ::= <마침표로 구분된 빌드 식별자들>
  
  <마침표로 구분된 빌드 식별자들> ::= <빌드 식별자>
                              | <빌드 식별자> "." <마침표로 구분된 빌드 식별자들>
  
  <배포 전 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
                  | <숫자 식별자>
  
  <빌드 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
               | <숫자들>
  
  <숫자와 알파벳으로 구성된 식별자> ::= <숫자 아닌 것>
                               | <숫자 아닌 것> <식별자 문자들>
                               | <식별자 문자들> <숫자 아닌 것>
                               | <식별자 문자들> <숫자 아닌 것> <식별자 문자들>
  
  <숫자 식별자> ::= "0"
               | <양의 숫자>
               | <양의 숫자> <숫자들>
  
  <식별자 문자들> ::= <식별자 문자>
                 | <식별자 문자> <식별자 문자들>
  
  <식별자 문자> ::= <숫자>
               | <숫자 아닌 것>
  
  <숫자 아닌 것> ::= <문자>
                | "-"
  
  <숫자들> ::= <숫자>
           | <숫자> <숫자들>
  
  <숫자> ::= "0"
          | <양의 숫자>
  
  <양의 숫자> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
  
  <문자> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"
  ```





# CNCF(Cloud Native Computing Foundation)

- Cloud Native
  - 클라우드 컴퓨팅 모델의 이점을 활용하는 애플리케이션 구축 방법론이다.
    - 클라우드가 제공하는 확장성, 탄력성, 복원성, 유연성 등의 이점을 활용하여 애플리케이션을 구축하는 방법론이다.
  - 애플리케이션이 클라우드에 상주하도록 애플리케이션을 설계한다.
  - Cloud Native를 적용한 애플리케이션을 클라우드 네이티브 앱이라고 부른다.
    - 클라우드 네이티브 애플리케이션은 아래와 같은 이점들이 있다.
    - 독립성: 클라우트 네이티브 앱을 서로 독립적으로 구축할 수 있도록 해준다.
    - 복원성: 인프라스트럭쳐가 중단되어도 온라인 상태를 유지할 수 있다.
    - 자동화: DevOps 자동화 기능을 사용하여 정기적으로 릴리스되는 소프트웨어 변경 사항을 지속적으로 전달 및 배포할 수 있다.
  - 클라우드 네이티브 아키텍처
    - 온프레미스 인프라가 아닌 클라우드에 존재하도록 특별히 설계된 애플리케이션 또는 서비스의 설계를 의미한다.
    - 성공적인 클라우드 네이티브 아키텍처는 유지보수가 용이하고, 비용 효율적이며 자가 복구가 가능하고, 높은 수준의 유연성을 가진다.



- CNCF
  - 클라우드 네이티브 기술의 채택을 촉진하는 오픈 소스 소프트웨어 재단.
    - 리눅스 재단이 설립하였다.
    - 퍼블릭 클라우드 공급 업체, 엔터프라이즈 소프트웨어 기업, 스타트업 등 400명 이상의 회원을 보유하고 있다.
    - 클라우드 네이티브 오픈소스들을 관리하고 장려하는 단체이다.
  - CNCF에서 관리되는 모든 프로젝트들은 성숙도 평가를 받아야 한다.
    - 성숙도에 따라 Sandbox, Incubating, Graduated라는 세 단계로 나뉜다.
    - 이 중 Graduated 단계의 경우 평가자 3분의 2이상의 찬성이 필요하다.
    - Graduated 프로젝트에는 Kubernetes(첫 Graduated 등급의 프로젝트), Prometheus, fluentd 등이 있다.





# Stream Backpressure

> https://doublem.org/stream-backpressure-basic/

- Backpressure(배압, 역압)
  - 파이프를 통한 유체 흐름에 반하는 저항을 말한다.
    - 액체나 증기가 관을 통해 배출 될 때, 유체가 흐르는 방향과 반대 방향으로 작용하는 저항 압력이다.



- 소프트웨어에서의 backpressure
  - 소프트웨어에도 Stream과 PIpe가 존재한다.
    - 두 용어 모두 유체의 흐름(stream)과 이를 이동시키는 pipe에서 따온 것이다.
    - 단지 내용물이 유체가 아닌 data라는 차이가 있을 뿐이다.
  - 마찬가지로, 소프트웨어에도 backpressure가 존재한다.
    - Data의 흐름이 일정치 않거나 예상치 못하게 높아질 경우 발생할 수 있다.
    - 예를 들어 A에서 B로 data를 옮길 때, B가 처리할 수 있는 데이터 양 보다 많은 양을 A가 지속적으로 보낼 경우 backpressure가 발생할 수 있다.
  - 소프트웨어에서 backpressure가 발생할 경우 아래와 같은 현상이 발생할 수 있다.
    - Network I/O
    - Disk I/O
    - Out of Memory
    - Drop data



- Backpressure를 방지할 수 있는 방법
  - Buffer를 사용하여 backpressure를 방지할 수 있다.
    - Buffer란 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이털를 보관하는 메모리 영역을 말한다.
    - Buffering이란 버퍼를 활용하는 것 혹은 버퍼를 채우는 것을 말한다.
    - 구현에 queue를 사용한다.
  - Pull 기반의 데이터 처리
    - Consumer가 처리할 수 있는 만큼만 producer로 부터 data를 받아와서 처리한 후 처리가 완료되면 다시 data를 받아오는 방식이다.



# Standard Stream, Standard Input, Output

> https://shoark7.github.io/programming/knowledge/what-is-standard-stream

- 표준 스트림
  - 컴퓨터 프로그램에서 표준적으로 입력으로 받고 출력으로 내보내는 데이터와 매체의 총칭.
  - Stream
    - 프로그램을 드나드는 데이터를 바이트의 흐름(stream)으로 표현한 단어이다.
    - 여러 종류의 하드웨어로부터 data를 읽어 오고, 일련의 처리를 거쳐서 이를 다시 출력하는 일은 매우 번거로운 일이었다.
    - Unix는 이런 번거로움을 해소하기 위해 장치를 추상화해서 각 장치를 파일처럼 다루는 것으로 이 문제를 해결했다.
    - 하드웨어의 종류별로 입력과 출력을 위한 설정을 따로 하는 대신, 파일을 읽고 쓰는 한 가지 작업으로 통일시킨 것이다.
    - 그리고 이 파일에서 읽히고 나가는 데이터를 stream이라고 정의했다.



- 표준 입출력
  - Standard
    - 많은 프로그램이 입력과 출력을 필요로 한다.
    - 만약 어떤 프로그램이 대부분의 입력과 출력이 한 출처로부터만 발생한다면, 사용자가 명시하지 않더라도 기본적으로 사용할 입력과 출력을 설정할 수 있으면 훨씬 간편할 것이다.
    - 이렇게 한 프로그램이 기본적으로 사용할 입출력 대상을 표준 입출력이라 한다.
  - 표준 입출력은 표준 입력과 표준 출력으로 나뉜다.
  - 표준 입력
    - 프로그램에 입력되는 데이터의 표준적인 출처를 일컬으며, stdin으로 줄여서 표현한다.
    - 유닉스 쉘에서는 표준 입력이 키보드로 설정되어 있다.
  - 표준 출력
    - 프로그램에서 출력되는 데이터의 표준적인 방향을 일컫는다.
    - 표준 출력(stdout)과 표준 에러(stderr)로 구분할 수 있다.
    - 유닉스에서는 표준 출력, 표준 에러 모두 콘솔로 설정되어 있다.
    - 표준 출력은 정상적인 출력이 반환되는 방향을 말하고, 표준 에러는 프로그램의 비정상 종료 시에 반환되는 방향을 말한다.





# Shorts

- Type system

  - 모든 프로그래밍 언어는 어떤 category에 속한 object가 어떤 작업을 할 수 있고, 어떤 category가 어떻게 처리될지를 형식화하는 type system을 가지고 있다.
  - Dynamic Typing
    - Type checking을 run time에 수행하고, 변수의 type이 변경되는 것을 허용하는 방식을 말한다.
    - 대표적으로 Python이 있는데, 아래 코드는 절대 error가 발생하지 않는다.

  ```python
  # 1과 "foo"를 더하는 것은 불가능하지만, 해당 코드는 실행되지 않으므로 에러가 발생하지 않는다.
  if False:
      1 + "foo"
  ```

  - Static Typing
    - Type checking을 compile time에 수행하고, 일반적으로 변수의 type 변경이 불가능하다.
    - 대표적으로는 Java가 있는데, 아래 코드는 compile time에 error가 발생한다.

  ```java
  String foo;
  foo = 1;
  ```



- duck typing

  > if it walks like a duck and it quacks like a duck, then it must be a duck
  >
  > 만일 어떤 것이 오리 처럼 걷고 오리처럼 꽥꽥거린다면, 그것은 오리일 것이다.

  - duck test에서 개념을 따 왔다.
  - 동적 타이핑 언어 및 다형성과 관련된 개념이다.
  - 객체의 type보다 해당 객체에 정의되어 있는 method 혹은 attribute가 더 중요하다는 개념이다.
    - 객체에 이미 존재하는 메서드를 호출하기 위해, 객체가 해당 메서드를 갖는 타입인지 확인하지 말고, 해당 메서드를 가지고 있다면 해당 타입으로 간주하라는 것이다.

  - 예시

  ```python
  class Duck:
      def fly(self):
          print("fly with wings")
  
          
  class Plane:
      def fly(self):
          print("fly with fuel")
          
          
  class Ostrich:
      def walk(self):
          print("walking")
  
          
  def fly_duck(duck):
      duck.fly()
  
  # Ostrich는 fly라는 메서드를 가지고 있지 않기에 error가 발생한다.
  for obj in [Duck(), Plane(), Ostrich()]:
      obj.fly()
  ```

  - 코드가 특정 type에 강하게 결합되지 않게 해준다는 장점이 있지만, 문제가 생길 경우 디버깅이 어려워진다는 단점이 있다.
  - Duck typing 덕분에 Python에서는 interface를 구현해야 하는 번거로움이 많이 줄어들었다.
    - Interface가 하는 역할을 duck typing이 해주고 있는 것이다.
    - 물론 그렇다고 Python에서 interface 자체가 쓸모 없다는 것은 아니다.

  



- Call by value, Call by reference, Call by sharing

  > https://en.wikipedia.org/wiki/Evaluation_strategy

  - 평가 전략(Evaluation Strategy)

    - 프로그래밍 언어에서 평가 전략이란 표현식을 평가하는 규칙들의 집합이다.
    - 그러나 주로 parameter 전달 전략(Parameter-passing strategy)의 개념을 가리킨다.
    - Parameter-passing strategy란 function에 전달되는 각 parameter의 값의 종류를 정의하고, 함수 호출시의 parameter를 평가할지 여부를 결정하고, 만약 평가한다면, 평가 순서를 결정하는 전략을 의미한다.

  - Parameter와 argument

    - Parameter(매개변수, 형식 매개변수(formal parameter))란 함수에 정의된 매개변수를 의미한다.
    - Argument(인자, 실인자(actual parameter))란 함수에 전달하는 값을 의미한다.
    - Parameter는 함수 선언부에 정의되고, argument는 함수 호출부에서 사용된다.

  ```python
  def f(a):	# 함수에 정의된 매개변수 a는 parameter
      return a
  
  f(1)		# 함수에 실제로 넘어가는 값인 1은 argument
  ```

  - Call by value
    - Argument 표현식의 평가된 값이 함수 내에서 일치하는 변수에 binding된다.
    - 주로 새로운 메모리에 값을 복사하는 방식으로 이루어진다.
    - 즉, 먼저 argument 표현식을 평가한다.
    - `f(1)`에서 argument 표현식에 해당하는 `1`이라는 표현식을 평가하면 `1`이라는 값을 얻게 된다.
    - 이 평가된 값을 함수 내에서 일치하는 변수인 `a`에 binding한다.
    - 이 때, 주로 1이라는 값을 복사하여 새로운 메모리 영역에 생성하는 방식을 사용한다.
    - 따라서 함수 내에서 값이 변경되어도 원본 값은 변경되지 않는다.
  - Call by reference
    - Parameter가 argument의 reference에 bound된다.
    - 이는 function이 argument로 사용된 변수를 변경할 수 있다는 것을 의미한다.
    - 이 방식은 프로그래머가 함수 호출의 영향을 추적하기 힘들게 만들고, 사소한 버그를 유발할 수도 있다.
  - Call by sharing(call by object, call by object-sharing)
    - Caller와 callee가 object를 공유하는 것이다.
    - 값이 원시 타입이 아니라 객체에 기반하고 있음을 표현하기 위해 주로 사용한다.
    - Callee에게 전달 된 값이 변경된다는 점에서 call by value와 다르고, 주소가 아닌 object를 공유한다는 점에서 call by reference와는 다르다.
    - Immutable object의 경우 call by value와 실질적인 차이가 존재하지 않는다.

  - Python과 Java, Javascript등의 언어는 Call by sharing 방식을 사용한다.

    - 그러나 일반적으로 call by sharing이라는 용어를 사용하지는 않는다.
    - Python community에서는 이를 call by assignment라 부른다.



- 도메인 로직(domain logic, 비즈니스 로직(Business logic))

  > https://velog.io/@eddy_song/domain-logic
  >
  > https://enterprisecraftsmanship.com/posts/what-is-domain-logic/

  - Problem space와 solution space
    - 하나의 프로젝트는 크게 problem space와 solution space라는 두 개의 영역으로 나눠진다.
    - Problem space는 일반적으로 domain 혹은 problem domain, core domain이라 부르며, software를 통해 해결하고자 하는 현실의 문제들을 의미한다.
    - Solution space는 business logic, business rules, domain logic, domain knowledge라 부르며, problem domain을 해결하기 위한 방안들을 의미한다.

  - 비즈니스 혹은 도메인
    - 소프트웨어 공학에서 비즈니스 혹은 도메인이라는 말은 소프트웨어가 해결하고자 하는 현실의 문제를 가리킨다.
    - 즉 소프트웨어의 존재 이유이다.
  - 도메인 로직
    - 소프트웨어가 해결하고자 하는 현실 문제를 해결하는 데 직접적으로 관련된 로직을 의미한다.
    - Software는 도메인 로직으로만 구성되지 않는다.
    - 개발을 하다 보면 다양한 코드를 작성하게 되며, 이들이 모두 domain model을 작성하는 것과 관련되지는 않는다.
    - 대부분의 경우 domain model을 DB 등의 data store, 외부 서비스, 사용자와 연결하기위해 많은 코드를 작성하게 된다.
    - 따라서 domain model과 직접적으로 관련된 코드와 그렇지 않은 코드를 구분하는 것은 쉽지 않다.
  - 애플리케이션 서비스 로직
    - 비즈니스 로직과 구분되는 현실 문제 해결에 직접적으로 관여하지 않는 로직을 의미한다.
    - 애플리케이션 서비스 로직은 애플리케이션 서비스 계층에서 결정들을 조율하고 의사결정 결과를 반영하는 등의 역할을 한다.
  - 도메인 로직과 애플리케이션 서비스 로직의 구분
    - 어떤 코드가 비즈니스에 대한 의사결정을 하고 있는가로 구분한다.

  - 왜 구분해야 하는가
    - 관심사의 분리를 가능하게 해준다.
    - 이를 통해 도메인과 관련된 로직에 보다 집중할 수 있게 된다.

  - 예시
    - 아래 코드는 application service layer를 보여준다.
    - 실제 비즈니스 로직은 atm 객체에서 처리하고 application service는 비즈니스에 관한 의사 결정 결과를 조율하고 반영하는 역할을 한다.
    - 비즈니스와 직접적으로 관련된 코드만 보고 싶다면 atm만 확인하면 된다.
    - 즉 아래와 같이 계층을 구분함으로써 코드를 보다 쉽게 읽을 수 있게 되고, 도메인 로직에 집중할 수 있게 된다.

  ```python
  class Bank:
      def __init__(self):
          self.atm = ATM()
          self.payment_gateway = None
          self.repository = None
  	
      # take_money 메서드 자체는 아무런 의사 결정을 하지 않는다.
      def take_money(amount):
          # 돈을 출금할 수 있는지에 대한 의사 결정은 atm 객체의 can_take_money 메서드를 통해 이루어진다.
          if self.atm.can_take_money(amount):
              # 수수료를 포함한 금액이 얼마인지에 대한 의사 결정 역시 atm 객체에서 이루어진다.
              amount_with_commision = self.amount.calculate_amount_with_commision(amount)
              
              self.payment_gateway.charge_payment(amount_with_commision)
              self.repository.save(self.atm)
          else:
              return "Not enough meney to withdraw"
  ```

  
