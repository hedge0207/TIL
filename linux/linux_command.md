- tar 명령어

  - `-c`: 파일을 tar로 묶는다.
  - `-p`: 파일 권한을 저장
  - `-v`: 묶거나 파일을 풀 때 과정 출력
  - `-f`: 파일 이름을 지정
    - 지정해주지 않을 경우 제대로 실행이 되지 않으므로 왠만하면 필수로 지정해준다.
  - `-x`: tar 압축 풀기
  - `-z`:  gzip으로 압축하거나 해제함

  ```bash
  # 이름 지정하여 압축
  $ tar -cf <압축파일명.tar> <압축할 폴더 또는 파일>
  # 압축 풀기
  $ tar -xf <압축을 풀 파일 또는 폴더>
  ```



- 폴더 생성하기

  `-p`: 상위 디렉토리도 함께 생성

  ```bash
  $ mkdir -p /hello/world
  ```





- 서버-로컬, 서버-서버 사이에 파일 복사하기.

  - 목적 디렉토리 끝에 `/`를 붙이지 않으면 해당 이름으로 파일이 복사된다.

  ```bash
  # 로컬->리모트
  $ scp 목적파일명(경로) 유저명@IP주소:목적디렉토리
  
  # 리모트->로컬
  $ scp 유저명@IP주소:파일디렉토리 목적디렉토리(경로)
  
  # 리모트->리모트
  $ scp 유저명@IP주소:파일디렉토리 유저명@IP주소:파일디렉토리
  ```



- 디렉토리 구조 보기

  ```bash
  $ tree 디렉토리명
  ```



- 파일 복사

  > - filezilla 설치가 가능하면 filezilla를 사용하는 것이 낫다.
  >
  > > https://filezilla-project.org/

  - `-r`: 디렉토리 전체 복사
  - `-p`: 소유주, 그룹, 권한, 시간 정보를 보존하여 복사
  
  ```bash
  $ cp <복사할 파일> <붙여넣을 폴더>



- 사용 중인 포트 확인하기

  - `-a`:  모든 연결 및 수 신 대기 포트를 표시
  - `-n`: 주소나 포트 형식을 숫자로 표현한다.
  - `-t`: TCP로 연결 된 포트를 보여준다.
  - `-u`: UDP로 연결된 포트를 보여준다.
  - `-p`: 해당 프로세스를 사용하고 있는 프로그램 이름을 보여준다.
  - `-r`: 라우팅 테이블을 보여준다.
  - `-l`: listen하고 있는 포트를 보여준다.
  - `-c`: 현재 명령을 매 초마다 실행한다.
  
  ```bash
  $ sudo netstat -antop
  ```



- 프로세스 PID로 어느 프로그램에서 사용중인지 확인하기

  ```bash
  $ ls -l /proc/<PID>/exe
  ```




- 특정 폴더 찾기

  ```bash
  # 전체 폴더에서 찾기
  $ find / -name <폴더명> -type d	# 작은 따옴표, 큰 따옴표 모두 가능하며, 안 쓰는 것도 가능하다.
  
  # 현재 폴더 및 하위 폴더에서 찾기
  $ find ./ -name <폴더명> -type d
  ```



- 특정 파일 찾기

  ```bash
  # 전체 폴더에서 찾기
  $ find / -name <'파일명'>  # 작은 따옴표, 큰 따옴표 모두 가능하며, 안 쓰는 것도 가능하다.
  
  # 현재 폴더 및 하위 폴더에서 찾기
  $ find ./ -name <'파일명'>
  ```



- gz 파일 압축 풀기

  ```bash
  $ gzip -d <압축파일명>
  ```



- 현재 디렉토리 파일별 용량 확인

  - `-s`: 디렉토리의 전체 사용량 표시
  - `-h` 파일 크기의 단위를 kb,mb,gb 단위로 표시

  ```bash
  $ du -sh *
  ```

  

- 파일 옮기기

  ```bash
  $ mv <이동할 파일명> <이동할 위치>
  ```



- 현재 경로 확인

  ```bash
  $ pwd
  ```



- 경로 이동

  - `~`: home 디렉토리로 이동
  - `-`: 이전 디렉토리로 이동
  - `..`: 상위 디렉토리로 이동
  - `/`: 루트 디렉토리로 이동

  ```bash
  cd [옵션]
  ```

  

- 디렉토리 내부 파일 및 디렉토리 확인

  - `-a`: 숨겨진 파일 보기
  - `-l`: 권한, 소유자, 갱신일 확인

  ```bash
  # 기본 명령어
  $ ls [옵션]
  
  # ls -l과 동일한 명령어
  $ ll
  ```

  

- vim

  - 리눅스의 에디터 중 하나
  - 설치

  ```bash
  $ apt-get update
  $ apt-get install vim
  ```

  - 실행

  ```bash
  $ vi <파일명>
  ```

  - 종료
    - `esc`누른 후
    - `:w`: 저장
    - `:q`: 닫기
    - `:q!`: 저장하지 않고 닫기
    - `:wq!`: 강제 저장 후 종료



- 삭제

  - `-r`: 폴더를 삭제하려면 이 옵션을 줘야 한다.

  ```bash
  $ rm <파일 or 폴더>
  ```



- 소유권 변경

  - 소유권 확인

  ```bash
  $ ls -al
  # 혹은
  $ ll
  ```
  
  - 소유권 변경
    - `-R`: 폴더 내 모든 파일, 폴더의 소유권을 변경한다.
  
  ```bash
  $ chown <옵션> [변경할 소유권자]<:변경할 그룹> [변경할 파일 혹은 폴더]
  ```

  - 소유권 변경에 root 권한이 필요할 수도 있다.
  
  ```bash
  # root 권한 얻기
  $ su
  
  # root 계정의 비밀번호를 설정한 적 없다면 아래와 같이 입력하면 된다.
  $ sudo passwd root
  ```




- sudo 권한 주기
  - /etc/sudousers에 아래와 같이 추가한다.
  
  ```bash
  $ sudo vi /etc/sudousers
  
  <계정명>    ALL=(ALL:ALL) ALL
  ```



- 계정

  - 계정 변경
    - 변경할 계정을 입력하지 않으면 자동으로  root 계정으로 변경된다.

  ```bash
  $ su <변경할 계정>
  ```

  - password 변경
    - 아래 명령어 입력 후 현재 비밀번호, 변경할 비밀번호 순으로 입력하면 된다.

  ```bash
  $ passwd
  ```



- 파일 수정

  - 특정 파일(들)을 찾고 해당 파일의 내용을 수정하기
  - `sed`와 `find`를 사용
    - `-i`는 변경한 내용이 실제 파일에 적용되도록 한다.

  ```bash
  find [변경할 파일의 경로] -exec sed -i 's/이전 내용/바꿀 내용/g' {} \;
  ```



- 파일의 줄 수를 계산하기

  ```bash
  $ cat <파일 경로> |  wc -l
  ```



- 파일을 분할하기

  - 정확히는 분할 보다는 대상 파일에서 지정해준 부분을 복사해서 새로운 파일을 만드는 것이다.
  - `>`을 사용한다.
  
  ```bash
  $ <조건> <파일명> > <새로 생성할 파일명>
  ```



- jupyter의 ipynb 파일을 py 파일로 변환하기

  ```bash
  $ jupyter nbconvert --to script <ipynb 파일명>
  ```




- 백그라운드에서 실행하기

  - `nohup` 명령어를 사용한다.
  - nohup.out 파일이 생성되며 여기에 로그가 입력되게 된다.

  ```bash
  $ nohup <명령어> &
  ```

  - nohup.out 파일은 어느 정도 로그가 쌓이면 한 번에 나오게 되는데 python의 경우, 이를 바로 나오게 해주는 방법이 있다.
    - `-u` 옵션을 준다.

  ```bash
  $ nohup python -u <파일명> &
  ```

  - 종료
    - 프로세스 아이디 확인 후 종료한다.
    - `ps -ef `만 입력해서 일일이 찾아도 된다.

  ```bash
  # 프로세스 id 확인
  $ ps -ef | grep <위에서 입력한 명령어>
  
  # 종료
  $ kill -9 <프로세스 id>
  ```



- free

  - 메모리 사용량을 체크할 수 있는 명령어
    - 메모리와 swap 메모리를 확인 가능하다.
  - swap 메모리
    - 메모리 사용량이 늘어났을 때 하드 디스크의 일부를 확장된 RAM 처럼 사용할 수 있게 해주는 기술
    - SSD 하드 디스크를 쓴다 하더라도 데이터를 읽어들이는 속도는 메모리에 비해 현저히 떨어지게 된다.
  - 옵션
    - `-m`,  `-g` 각각 mb, gb 단위로 출력한다(기본은 kb).

  ```bash
  $ free
  ```



- 파일 합치기

  - 두 파일 합치기

  ```bash
  $ cat <합칠 파일명1> <합칠 파일명2> > <합친 파일명>
  ```

  - 패턴에 맞는 파일 전부 합치기
    - xargs는 앞 명령어의 실행 결과를 다음 명령어의 입력으로 사용하게 해준다.

  ```bash
  $ ls <파일명 패턴> | xargs cat > <합친 파일명>
  ```

  - 예시
    - test1.txt, test2.txt, test3.txt 가 있다고 할 때 아래 명령어를 입력하면
    - `ls test*`의 결과인 test1.txt, test2.txt, test3.txt가 xargs에 담기게 되고
    - cat을 통해 위 세 파일이 출력되면서, 출력 리다이렉션(`>`)을 통해 출력 내용을 하나의 파일로 합치게 된다.

  ```bash
  $ ls test* | xargs cat > test.txt
  ```



- 특정 행 삭제

  ```bash
  $ sed -i <숫자>d <파일명>
  ```




- Python  파일 실행 후 로그 남기기

  ```bash
  $ python <실행할 파일명> > <로그 남길 파일명>
  ```




- 매개변수 지정

  - 쉘 스크립트에 매개 변수를 넘길 수 있다.
    - 공동으로 사용하는 쉘 스크립트의 경우 쉘 스크립트 자체를 변경시키는 것 보다 매개변수를 넘기는 것이 바람직하다.
  - 위치 매개 변수(아규먼트 변수)
    - 띄어쓰기를 기준으로 각 위치에 해당하는 값들을 가져온다.
    - `$숫자` 형태로 사용한다.
    - 10번째 부터는 중괄호로 감싸 줘야 한다(e.g`${10}`)
    - `$0`에는 실행된 쉘 스크립트명이 온다.

  ```bash
  # test.sh 파일
  echo $1 $2
  
  # 명령어
  $ sh test.sh hello world	# hello world
  ```

  - 특수 매개 변수
    - `$!`: 실행을 위해 백그라운드로 보내진 마지막 프로그램 프로세스 번호
    - `$$`: 쉘 스크립트의 PID
    - `$?`: 실행한 뒤의 반환 값(백그라운드로 실행된 것 제외)
    - `$_`: 지난 명령의 마지막 인자로 설정된 특수 변수
    - `$-`: 현재 쉘이 호출될 때 사용한 옵션들



- 운영체저 정보 확인

  ```bash
  $ cat /etc/issue
  ```



- 중복 행 제거

  - uniq 사용
    - 연속으로 중복 된 행이 있을 경우 중복된 행을 삭제한다.

  ```bash
  # test.txt
  orange
  apple
  apple
  watermelon
  watermelon
  apple
  orange
  (빈 줄)
  
  # 중복 제거
  $ cat test.txt | uniq
  
  # out
  orange
  apple
  watermelon
  apple
  orange
  ```

  - sort
    - 연속되지 않은 중복 행을 삭제하려 할 경우 먼저 정렬 후에 사용한다.

  ```bash
  $ cat test.txt | sort | uniq
  
  # out
  apple
  orange
  watermelon
  ```

  - `-c`
    - 몇 개가 중복되었는지 확인하기 위해 사용한다.

  ```bash
  $ cat test.txt | sort | uniq -c
  
  # out
  3 apple
  2 orange
  2 watermelon
  ```

  - 정렬하려는 대상 파일의 마지막에 빈 줄이 없으면 제대로 동작하지 않는다.
    - 항상 마지막 행은 어떤 행과도 중복되지 않는 고유한 행으로 취급된다.

  ```bash
  # test.txt
  orange
  apple
  apple
  watermelon
  watermelon
  apple
  orange
  
  # 중복 제거
  $ cat test.txt | sort | uniq -c
  
  # out
  3 apple
  1 orange
  1 orange
  2 watermelon
  ```




- 링크 설정하기

  - 파일 링크
    - 윈도우의 바로가기와 유사하다고 이해하면 된다.
  - Inode
    - 리눅스 파일 시스템에 이용되는 자료구조
    - 파일 혹은 디렉터리의 허가권, 소유권, 파일의 실제 위치 등에 관한 정보를 담고 있다.
    - `original file -> inode -> original file data`의 형식이다.
    - 모든 파일 혹은 디렉터리는 inode를 하나씩 가지고 있으며, 이들이 모여 있는 공간을 inode block이라고 한다.
    - `ls -i`로 inode 번호를 확인 가능하다.
  - 소프트링크(심볼릭 링크)
    - 소프트 링크를 생성하게 되면 원본 파일을 가리키고 있는 링크 파일을 하나 만들게 된다.
    - 이 링크 파일은 원본 파일과는 다른 inode를 가지게 되며, 따라서 완전히 다른 파일로 관리된다.
    - 링크 파일의 inode는 original file을 가리키는 데이터를 가리키고 있다.
    - `link file -> inode2 -> original file pointer -> original file -> inode1 -> original file data`의 형식이다.
    - 원본 파일이 삭제될 경우 링크 파일은 아무런 역할을 하지 못하게 된다.
    - 심볼릭 링크 폴더에서의 생성, 수정, 삭제 등은 원본 폴더에도 그대로 적용된다.
    - 그러나 링크 폴더 자체를 삭제한다고 원본 폴더도 삭제되는 것은 아니다.
  - 하드링크
    - 하드링크는 원본 파일과 동일한 inode를 지닌다.
    - 따라서 링크 파일을 수정해도 원본 파일이 수정되며, 그 반대도 마찬가지다.
    - 하드링크는 소프트링크와는 달리 파일에만 사용이 가능하다.
    - 심볼릭 링크와 마찬가지로 하드링크 역시 하드링크 파일에서의 수정이 원본 파일에도 그대로 적용된다.
    - 심볼릭 링크와 달리 원본 파일이 삭제되어도 하드링크 파일은 사용이 가능하다.
  - 링크 확인하기
    - `ls` 명령어에 `l` 옵션을 준다.
    - 링크가 생성되면 다음과 같이 맨 앞에 `l`이 붙고, `link -> original/` 처럼 링크 표시가 뜬다.

  ```bash
  $ ls -l
  total 4
  lrwxrwxrwx 1 root root    9 Jul 26 12:12 link -> original/
  ```

  - 심볼릭 링크 생성하기
    - window 환경에서는 bash 등을 사용해도 링크가 제대로 잡혔는지 나오지 않으므로 리눅스 환경에서 테스트 해봐야 한다.
    - 심볼릭 링크는 기본 명령어인 `ln`에 `-s` 옵션을 추가하여 생성한다.

  ```bash
  $ ln -s <원본 파일 또는 폴더 경로> <링크를 생성할 파일 또는 폴더>
  ```

  - git 관련
    - vscode의 변경 사항 추적은 적용되지 않는다.
    - 그러나 git status로 확인해보면 실제로는 변경 사항이 그대로 추적되는 것을 확인 가능하다.
    - 따라서 링크 디렉토리에서도 그냥 사용하면 된다.



- crontab

  - 특정 시간에 특정 프로그램을 특정 주기로 실행시키는 프로그램
  - 설치

  ```bash
  $ apt-get install cron
  ```

  - 크론탭 설정하기
    - vi 에디터를 사용하여 크론탭 설정을 입력한다.
    - `*` , 숫자,  `,`, `-`를 조합해서 설정한다.

  ```bash
  $ corntab -e
  
  *			*			*			*			*
  분(0-59)	   시간(0-23)   일(1-31)	 월(1-12)	요일(0-7, 0과 7은 일요일, 1-6은 월-토요일 순이다.)
  
  # 만일 아래와 같이 설정하면 test.sh를 매분 실행하겠다는 뜻이다.
  * * * * * test.sh
  # 매월 5,15,25일 10시 정각, 20분, 30분에 test.sh를 실행하겠다는 뜻이다.
  0,20,30 10 5,15,25 * * test.sh
  # 매월 10~20일 매 20분마다 test.sh를 실행하겠다는 뜻이다.
  */20 * 10-20 * * test.sh
  
  # 로그 남기기
  * * * * * test.sh > test.sh.log 2>&1
  ```

  - 크론탭 설정 내용 확인

  ```bash
  $ crontab -l
  ```

  - 크론탭 설정 내용 삭제

  ```bash
  $ crontab -d
  ```



- 리눅스 특수 문자

  - 표준출력
    - `>`, `>>`을 사용한다.
    - `>`는 새로운 파일을 쓰는 것이고, `>>`는 기존 파일에 추가하는 것이다.

  ```bash
  $ <명령어> > <저장할 파일>
  $ <명령어> >> <저장할 파일>
  ```

  - 표준 입력
    - `<`를 사용한다.

  ```bash
  $ cat < text.txt
  ```

  - 와일드 카드
    - `*`, `?`가 있다.
    - `*`는 복수의 문자를 대체하는 와일드 카드이고, `?`는 하나의 문자를 대체하는 와일드 카드이다.

  ```bash
  # test.txt, text.txt
  $ ls te*.txt
  $ ls te?t.txt
  ```

  - 파이프 문자
    - 특정 프로세스의 표준 출력을 다른 프로세스의 표준 입력으로 보내는 문자

  ```bash
  $ cat ll | grep txt
  ```

  - 명령 문자
    - 명령에 괸련된 문자들
    - `;` : 명령의 끝을 나타낸다.
    - `||`: 이전 명령이 실패하면 실행하는 조건문 문자
    - `&&`: 이전 명령이 성공하면 실행하는 조건문 문자
    - `&`: 명령을 백그라운드에서 실행
    - `$`: 변수에 접근할 수 있는 문자
  - 변수 접근 기호
    - `0`: 표준 입력
    - `1`: 표준 출력
    - `2`: 에러 출력

  ```bash
  # 로그 파일 출력하기
  $ ./test.sh >> ./test.log 2>&1
  ```



- 리눅스에서 공백 문자 표현

  - 리눅스에서 공백 문자, 괄호 등은 `\+공백문자`, `\+괄호`를 통해 표현한다.
  - 예를 들어 파일명이 `Hello World(EN).txt`인 경우 `Hello\ World\(EN\).txt`로 표현한다.

  ```bash
  $ mv Hello\ World\(EN\).txt Hello\ World\(KR\).txt
  ```




- 리눅스에서 현재 날짜 구하기

  - `date` 명령어를 입력한다.

  ```bash
  $ date
  Thu Sep 16 09:17:49 KST 2021
  ```

  - 포맷

  | 포맷 | 설명                                                |
  | ---- | --------------------------------------------------- |
  | %%   | % 기호를 출력한다.                                  |
  | %a   | 요일을 약어로 출력                                  |
  | %A   | 요일을 전체 단어로 출력                             |
  | %b   | 월 이름을 약어로 출력                               |
  | %B   | 월을 전체 단어로 출력                               |
  | %y   | 년도의 뒤의 두 자리를 출력한다.                     |
  | %Y   | 전체 년도를 출력한다.                               |
  | %m   | 월을 출력한다.                                      |
  | %d   | 일을 출력한다.                                      |
  | %H   | 시간을 24시간 표현법으로 출력한다.                  |
  | %M   | 분을 출력한다.                                      |
  | %S   | 초를 출력한다.                                      |
  | %s   | 1970-01-01 00:00:00 UTC로부터 경과된 초를 출력한다. |
  | %D   | %m/%d/%y 형태로 날짜를 보여준다.                    |
  | %T   | %H:%M:%S 형태로 시간을 보여준다.                    |
  | %p   | AM, PM 출력                                         |
  | %r   | 00:00:00 AM 형태로 시간을 출력한다.                 |
  | %j   | 년을 기준으로 며칠이 지났는지 출력한다.             |
  | %n   | 출력 시에 줄을 바꾼다.                              |
  | %z   | 타임존 값을 출력한다.                               |
  | %Z   | 시간 대역의 이름을 출력한다.                        |

  - 예시
    - 포맷의 맨 앞에 `+`를 넣어야 한다.

  ```bash
  $ date +%Y-%m-%d
  2021-09-16
  ```

  - 과거 날짜 구하기

  | 명령어                 | 결과           |
  | ---------------------- | -------------- |
  | yesterday              | 어제           |
  | 1 day ago              | 어제           |
  | 2 day ago              | 2일 전         |
  | 35 day ago             | 35일 전        |
  | 1 week ago             | 일주일 전      |
  | 2 month ago            | 두 달 전       |
  | 4 year ago             | 4년 전         |
  | 10 second ago          | 10초 전        |
  | 10 minute ago          | 10분 전        |
  | 10 hour ago            | 10 시간 전     |
  | 1 year 1month 1day ago | 1년 1달 1일 전 |

  - 미래 날짜 구하기
    - 과거 날짜 구하기에서 ago를 빼면 된다.
    - 내일 날짜는 tomorrow를 쓴다.
  - 예시
    - `-d` 옵션을 붙여줘야 한다.

  ```bash
  # 이틀 전 출력하기
  $ date -d '2 day ago'
  
  # 1년 전을 특정 포맷으로 출력하기
  date -d '1 year ago' +%Y-%m-%d
  ```

  - 특정 시간을 기준으로 날짜 더하고 빼기

  ```bash
  $ date -d '2020-01-01 00:00:00 + 1 day 12 hour'
  ```

  

















