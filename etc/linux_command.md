- tar 명령어

  - `-c`: 파일을 tar로 묶는다.
  - `-p`: 파일 권한을 저장
  - `-v`: 묶거나 파일을 풀 때 과정 출력
  - `-f`: 파일 이름을 지정
    - 지정해주지 않을 경우 제대로 실행이 되지 않으므로 왠만하면 필수로 지정해준다.
  - `-x`: tar 압축 풀기
  - `-z`:  gzip으로 압축하거나 해제함

  ```bash
  # 이름 지정하여 압축
  $ tar -cf <압축파일명.tar> <압축할 폴더 또는 파일>
  # 압축 풀기
  $ tar -xf <압축을 풀 파일 또는 폴더>
  ```



- 서버-로컬, 서버-서버 사이에 파일 복사하기.

  - 목적 디렉토리 끝에 `/`를 붙이지 않으면 해당 이름으로 파일이 복사된다.

  ```bash
  # 로컬->리모트
  $ scp 목적파일명(경로) 유저명@IP주소:목적디렉토리
  
  # 리모트->로컬
  $ scp 유저명@IP주소:파일디렉토리 목적디렉토리(경로)
  
  # 리모트->리모트
  $ scp 유저명@IP주소:파일디렉토리 유저명@IP주소:파일디렉토리
  ```



- 디렉토리 구조 보기

  ```bash
  $ tree 디렉토리명
  ```



- 파일 복사

  > - filezilla 설치가 가능하면 filezilla를 사용하는 것이 낫다.
  >
  > > https://filezilla-project.org/

  - `-r`: 디렉토리 전체 복사
  - `-p`: 소유주, 그룹, 권한, 시간 정보를 보존하여 복사
  
  ```bash
  $ cp <복사할 파일> <붙여넣을 폴더>



- 사용 중인 포트 확인하기

  - `-a`:  모든 연결 및 수 신 대기 포트를 표시
  - `-n`: 주소나 포트 형식을 숫자로 표현한다.
  - `-t`: TCP로 연결 된 포트를 보여준다.
  - `-u`: UDP로 연결된 포트를 보여준다.
  - `-p`: 해당 프로세스를 사용하고 있는 프로그램 이름을 보여준다.
  - `-r`: 라우팅 테이블을 보여준다.
  - `-l`: listen하고 있는 포트를 보여준다.
  - `-c`: 현재 명령을 매 초마다 실행한다.
  
  ```bash
  $ sudo netstat -antop
  ```



- 프로세스 PID로 어느 프로그램에서 사용중인지 확인하기

  ```bash
  $ ls -l /proc/<PID>/exe
  ```




- 특정 폴더 찾기

  ```bash
  # 전체 폴더에서 찾기
  $ find / -name <폴더명> -type d	# 작은 따옴표, 큰 따옴표 모두 가능하며, 안 쓰는 것도 가능하다.
  
  # 현재 폴더 및 하위 폴더에서 찾기
  $ find ./ -name <폴더명> -type d
  ```



- 특정 파일 찾기

  ```bash
  # 전체 폴더에서 찾기
  $ find / -name <'파일명'>  # 작은 따옴표, 큰 따옴표 모두 가능하며, 안 쓰는 것도 가능하다.
  
  # 현재 폴더 및 하위 폴더에서 찾기
  $ find ./ -name <'파일명'>
  ```



- gz 파일 압축 풀기

  ```bash
  $ gzip -d <압축파일명>
  ```



- 현재 디렉토리 파일별 용량 확인

  - `-s`: 디렉토리의 전체 사용량 표시
  - `-h` 파일 크기의 단위를 kb,mb,gb 단위로 표시

  ```bash
  $ du -sh *
  ```

  

- 파일 옮기기

  ```bash
  $ mv <이동할 파일명> <이동할 위치>
  ```



- 현재 경로 확인

  ```bash
  $ pwd
  ```



- 경로 이동

  - `~`: home 디렉토리로 이동
  - `-`: 이전 디렉토리로 이동
  - `..`: 상위 디렉토리로 이동
  - `/`: 루트 디렉토리로 이동

  ```bash
  cd [옵션]
  ```

  

- 디렉토리 내부 파일 및 디렉토리 확인

  - `-a`: 숨겨진 파일 보기
  - `-l`: 권한, 소유자, 갱신일 확인

  ```bash
  # 기본 명령어
  $ ls [옵션]
  
  # ls -l과 동일한 명령어
  $ ll
  ```

  

- vim

  - 리눅스의 에디터 중 하나
  - 설치

  ```bash
  $ apt-get update
  $ apt-get install vim
  ```

  - 실행

  ```bash
  $ vi <파일명>
  ```

  - 종료
    - `esc`누른 후
    - `:w`: 저장
    - `:q`: 닫기
    - `:q!`: 저장하지 않고 닫기
    - `:wq!`: 강제 저장 후 종료



- 삭제

  - `-r`: 폴더를 삭제하려면 이 옵션을 줘야 한다.

  ```bash
  $ rm <파일 or 폴더>
  ```



- 소유권 변경

  - 소유권 확인

  ```bash
  $ ls -al
  ```

  - 소유권 변경
    - `-R`: 폴더 내 모든 파일, 폴더의 소유권을 변경한다.

  ```bash
  $ chown <옵션> [변경할 소유권자]<:변경할 그룹> [변경할 파일 혹은 폴더]
  ```

  - 소유권 변경에 root 권한이 필요할 수도 있다.

  ```bash
  # root 권한 얻기
  $ su
  
  # root 계정의 비밀번호를 설정한 적 없다면 아래와 같이 입력하면 된다.
  $ sudo passwd root
  ```

  - sudo 권한 주기
    - /etc/sudousers에 아래와 같이 추가한다.

  ```bash
  $ sudo vi /etc/sudousers
  
  <계정명>    ALL=(ALL:ALL) ALL
  ```



- 계정

  - 계정 변경
    - 변경할 계정을 입력하지 않으면 자동으로  root 계정으로 변경된다.

  ```bash
  $ su <변경할 계정>
  ```

  - password 변경
    - 아래 명령어 입력 후 현재 비밀번호, 변경할 비밀번호 순으로 입력하면 된다.

  ```bash
  $ passwd
  ```



- 파일 수정

  - 특정 파일(들)을 찾고 해당 파일의 내용을 수정하기
  - `sed`와 `find`를 사용
    - `-i`는 변경한 내용이 실제 파일에 적용되도록 한다.

  ```bash
  find [변경할 파일의 경로] -exec sed -i 's/이전 내용/바꿀 내용/g' {} \;
  ```



- 파일의 줄 수를 계산하기

  ```bash
  $ cat <파일 경로> |  wc -l
  ```



- 파일을 분할하기

  - 정확히는 분할 보다는 대상 파일에서 지정해준 부분을 복사해서 새로운 파일을 만드는 것이다.
  - `>`을 사용한다.
  
  ```bash
  $ <조건> <파일명> > <새로 생성할 파일명>
  ```



- jupyter의 ipynb 파일을 py 파일로 변환하기

  ```bash
  $ jupyter nbconvert --to script <ipynb 파일명>
  ```




- 백그라운드에서 실행하기

  - `nohup` 명령어를 사용한다.
  - nohup.out 파일이 생성되며 여기에 로그가 입력되게 된다.

  ```bash
  $ nohup <명령어> &
  ```

  - nohup.out 파일은 어느 정도 로그가 쌓이면 한 번에 나오게 되는데 python의 경우, 이를 바로 나오게 해주는 방법이 있다.
    - `-u` 옵션을 준다.

  ```bash
  $ nohup python -u <파일명> &
  ```

  - 종료
    - 프로세스 아이디 확인 후 종료한다.
    - `ps -ef `만 입력해서 일일이 찾아도 된다.

  ```bash
  # 프로세스 id 확인
  $ ps -ef | grep <위에서 입력한 명령어>
  
  # 종료
  $ kill -9 <프로세스 id>
  ```



- free

  - 메모리 사용량을 체크할 수 있는 명령어
    - 메모리와 swap 메모리를 확인 가능하다.
  - swap 메모리
    - 메모리 사용량이 늘어났을 때 하드 디스크의 일부를 확장된 RAM 처럼 사용할 수 있게 해주는 기술
    - SSD 하드 디스크를 쓴다 하더라도 데이터를 읽어들이는 속도는 메모리에 비해 현저히 떨어지게 된다.
  - 옵션
    - `-m`,  `-g` 각각 mb, gb 단위로 출력한다(기본은 kb).

  ```bash
  $ free
  ```



- 파일 합치기

  - 두 파일 합치기

  ```bash
  $ cat <합칠 파일명1> <합칠 파일명2> > <합친 파일명>
  ```

  - 패턴에 맞는 파일 전부 합치기
    - xargs는 앞 명령어의 실행 결과를 다음 명령어의 입력으로 사용하게 해준다.

  ```bash
  $ ls <파일명 패턴> | xargs cat > <합친 파일명>
  ```

  - 예시
    - test1.txt, test2.txt, test3.txt 가 있다고 할 때 아래 명령어를 입력하면
    - `ls test*`의 결과인 test1.txt, test2.txt, test3.txt가 xargs에 담기게 되고
    - cat을 통해 위 세 파일이 출력되면서, 출력 리다이렉션(`>`)을 통해 출력 내용을 하나의 파일로 합치게 된다.

  ```bash
  $ ls test* | xargs cat > test.txt
  ```



- 특정 행 삭제

  ```bash
  $ sed -i <숫자>d <파일명>
  ```




- Python  파일 실행 후 로그 남기기

  ```bash
  $ python <실행할 파일명> > <로그 남길 파일명>
  ```




- 매개변수 지정

  - 쉘 스크립트에 매개 변수를 넘길 수 있다.
    - 공동으로 사용하는 쉘 스크립트의 경우 쉘 스크립트 자체를 변경시키는 것 보다 매개변수를 넘기는 것이 바람직하다.
  - 위치 매개 변수(아규먼트 변수)
    - 띄어쓰기를 기준으로 각 위치에 해당하는 값들을 가져온다.
    - `$숫자` 형태로 사용한다.
    - 10번째 부터는 중괄호로 감싸 줘야 한다(e.g`${10}`)
    - `$0`에는 실행된 쉘 스크립트명이 온다.

  ```bash
  # test.sh 파일
  echo $1 $2
  
  # 명령어
  $ sh test.sh hello world	# hello world
  ```

  - 특수 매개 변수
    - `$!`: 실행을 위해 백그라운드로 보내진 마지막 프로그램 프로세스 번호
    - `$$`: 쉘 스크립트의 PID
    - `$?`: 실행한 뒤의 반환 값(백그라운드로 실행된 것 제외)
    - `$_`: 지난 명령의 마지막 인자로 설정된 특수 변수
    - `$-`: 현재 쉘이 호출될 때 사용한 옵션들



- 운영체저 정보 확인

  ```bash
  $ cat /etc/issue
  ```



- 중복 행 제거

  - uniq 사용
    - 연속으로 중복 된 행이 있을 경우 중복된 행을 삭제한다.

  ```bash
  # test.txt
  orange
  apple
  apple
  watermelon
  watermelon
  apple
  orange
  (빈 줄)
  
  # 중복 제거
  $ cat test.txt | uniq
  
  # out
  orange
  apple
  watermelon
  apple
  orange
  ```

  - sort
    - 연속되지 않은 중복 행을 삭제하려 할 경우 먼저 정렬 후에 사용한다.

  ```bash
  $ cat test.txt | sort | uniq
  
  # out
  apple
  orange
  watermelon
  ```

  - `-c`
    - 몇 개가 중복되었는지 확인하기 위해 사용한다.

  ```bash
  $ cat test.txt | sort | uniq -c
  
  # out
  3 apple
  2 orange
  2 watermelon
  ```

  - 정렬하려는 대상 파일의 마지막에 빈 줄이 없으면 제대로 동작하지 않는다.
    - 항상 마지막 행은 어떤 행과도 중복되지 않는 고유한 행으로 취급된다.

  ```bash
  # test.txt
  orange
  apple
  apple
  watermelon
  watermelon
  apple
  orange
  
  # 중복 제거
  $ cat test.txt | sort | uniq -c
  
  # out
  3 apple
  1 orange
  1 orange
  2 watermelon
  ```

  

