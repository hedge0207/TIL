재귀호출 예제1)

```python
def factorial(a):
    if a == 1:
        return 1
    return factorial(a-1)*a

print(factorial(5))

output
120
```

- 과정

  1)factorial 함수에 5가 들어감, if에 걸리지 않으므로 factorial(4)*5를 리턴하기 위해  factorial(4)로 들어감

  2)factorial함수에 4가 들어감, if에 걸리지 않으므로 factorial(3)*4를 리턴하기 위해  factorial(3)으로 들어감

  3)factorial함수에 3이 들어감, if에 걸리지 않으므로 factorial(2)*3을 리턴하기 위해  factorial(2)로 들어감

  4)factorial함수에 2가 들어감, if에 걸리지 않으므로 factorial(1)*2를 리턴하기 위해  factorial(1)로 들어감

  5)factorial함수에 1이 들어감, if에 걸리므로 1을 리턴함.

  6)factorial(1)은 1이므로 factorial(1)*2은 2가 되고 factorial(2)는 2를 리턴함.

  7)factorial(2)는 2이므로 factorial(2)*3은 6이 되고 factorial(3)는 6를 리턴함.

  8)factorial(3)은 6이므로 factorial(3)*4는 24가 되고 factorial(4)는 24를 리턴함.

  9)factorial(4)는 24이므로 factorial(4)*5는 120이 되고  최종적으로 factorial(5)는 120을 리턴함



재귀호출 예제2)

```python
cnt = 0
def fibo(n):
    print("fibo {}를 구함".format(n))
    global cnt
    cnt += 1
    if n < 2:
        return n
    return fibo(n-2)+fibo(n-1)
print(fibo(6))
print(cnt)


output
fibo 6를 구함
fibo 4를 구함
fibo 2를 구함
fibo 0를 구함
fibo 1를 구함
fibo 3를 구함
fibo 1를 구함
fibo 2를 구함
fibo 0를 구함
fibo 1를 구함
fibo 5를 구함
fibo 3를 구함
fibo 1를 구함
fibo 2를 구함
fibo 0를 구함
fibo 1를 구함
fibo 4를 구함
fibo 2를 구함
fibo 0를 구함
fibo 1를 구함
fibo 3를 구함
fibo 1를 구함
fibo 2를 구함
fibo 0를 구함
fibo 1를 구함
8 #1 1 2 3 5 8이므로 6번째 수는 8이 된다.
25 #총 25번 호출한다.
```

- 과정

  1)fibo함수에 6이 들어감, if에 걸리지 않으므로 fibo(4)+fibo(5)를 리턴하기 위해 fibo(4)와fibo(5)로 들어감

  

  ​	(1)fibo함수에 4가 들어감, if에 걸리지 않으므로 fibo(2)+fibo(3)를 리턴하기 위해 fibo(2) 와 fibo(3)로 들어가    		게 됨

  ​		①fibo함수에 2가 들어감, if에 걸리지 않으므로 fibo(0)+fibo(1)을 리턴하기 위해 fibo(0)과fibo(1)로 들어			가게 됨

     			ⓐfibo함수에 0이 들어감, if에 걸리므로 0을 리턴

     			ⓑfibo함수에 1이 들어감, if에 걸리므로 1을 리턴

     			ⓒ결국 fibo(2)는 0+1이 되어 1이 되고 1을 리턴

  ​		②fibo함수에 3이 들어감, if에 걸리지 않으므로 fibo(1)+fibo(2)를 리턴하기 위해 fibo(1)과fibo(2)로 들어			가게 됨

     			ⓐfibo함수에 1이 들어감, if에 걸리므로 1을 리턴

     			ⓑfibo함수에 2가 들어감, if에 걸리지 않으므로 fibo(0)+fibo(1)을 리턴하기 위해 fibo(0)과fibo(1)로    					들어 가게됨

  ​       				(ㄱ)fibo함수에 0이 들어감, if에 걸리므로 0을 리턴

  ​       				(ㄴ)fibo함수에 1이 들어감, if에 걸리므로 1을 리턴

  ​       				(ㄷ)결국 fibo(2)는 0+1이 되어 1이 되고 1을 리턴

     			ⓒfibo(1)은 1을, fibo(2)도 1을 리턴하여 결국 fibo(3)은 2를 리턴

  ​		③fibo(2)는 1을, fibo(3)은 2를 리턴하므로 fibo(4)는 1+2가 되고 결국 3을 리턴

  

  ​	(2)fibo함수에 5가 들어감, if에 걸리지 않으므로 fibo(3)+fibo(4)를 리턴하기 위해 fibo(3)과fibo(4)로 들어감

  ​		①fibo함수에 3이 들어감, if에 걸리지 않으므로 fibo(1)+fibo(2)를 리턴하기 위해 fibo(1)과fibo(2)로 들어			가게 됨

  ​			   ⓐfibo함수에 1이 들어감, if에 걸리므로 1을 리턴

     			ⓑfibo함수에 2가 들어감, if에 걸리지 않으므로 fibo(0)+fibo(1)을 리턴하기 위해 fibo(0)과fibo(1)로    					들어 가게됨

  ​       				(ㄱ)fibo함수에 0이 들어감, if에 걸리므로 0을 리턴

  ​       				(ㄴ)fibo함수에 1이 들어감, if에 걸리므로 1을 리턴

  ​       				(ㄷ)결국 fibo(2)는 0+1이 되어 1이 되고 1을 리턴

     			ⓒfibo(1)은 1을, fibo(2)도 1을 리턴하여 결국 fibo(3)은 2를 리턴

  ​         ②fibo함수에 4가 들어감, if에 걸리지 않으므로 fibo(2)+fibo(3)를 리턴하기 위해 fibo(2) 와 fibo(3)로 들			어가게 됨

  ​				ⓐfibo함수에 2가 들어감, if에 걸리지 않으므로 fibo(0)+fibo(1)을 리턴하기 위해 fibo(0)과fibo(1)로 					들어가게 됨

     					(ㄱ)fibo함수에 0이 들어감, if에 걸리므로 0을 리턴

     					(ㄴ)fibo함수에 1이 들어감, if에 걸리므로 1을 리턴

     					(ㄷ)결국 fibo(2)는 0+1이 되어 1이 되고 1을 리턴

  ​				ⓑfibo함수에 3이 들어감, if에 걸리지 않으므로 fibo(1)+fibo(2)를 리턴하기 위해 fibo(1)과fibo(2)로 					들어가게 됨

     					(ㄱ)fibo함수에 1이 들어감, if에 걸리므로 1을 리턴

     					(ㄴ)fibo함수에 2가 들어감, if에 걸리지 않으므로 fibo(0)+fibo(1)을 리턴하기 위해 fibo(0)과							fibo(1)로 들어 가게됨

  ​       						(a)fibo함수에 0이 들어감, if에 걸리므로 0을 리턴

  ​       						(b)fibo함수에 1이 들어감, if에 걸리므로 1을 리턴

  ​       						(c)결국 fibo(2)는 0+1이 되어 1이 되고 1을 리턴

     					(ㄷ)fibo(1)은 1을, fibo(2)도 1을 리턴하여 결국 fibo(3)은 2를 리턴

  ​				ⓒfibo(2)는 1을, fibo(3)은 2를 리턴하므로 fibo(4)는 1+2가 되고 결국 3을 리턴

  ​			③fibo(3)는 2를, fibo(4)는 3을 리턴하므로 fibo(5)는 2+3이 되고 결국 5를 리턴

  

  ​	2)fibo(4)는 3, fibo(5)는 5를 리턴하므로 fibo(6)은 8을 리턴하고 모든 과정이 종료됨.





메모이제이션

- 위의 과정에서 보듯 재귀호출은 중복호출이 매우 자주 일어난다. 피보나치 수열의 6번째 수를 구하는 간단한 위의 식에서도 fibo(4)를 2번, fibo(3)을 3번,  fibo(2)를 5번, fibo(1)을 8번, fibo(0)을 5번 호출해야 했다. 따라서 재귀의 깊이가 깊어질 수록 호출 횟수도 기하급수적으로 증가한다. 따라서 시간도 증가하게 된다.  따라서 호출 횟수를 줄이기 위해 한 번 호출한 값을 리스트에 저장한 후 이후에 다시 호출 할 일이 있을때 그 리스트에서 빼오는 방식을 사용한다.

  ```python
  N = 6
  memo = [-1] * (N + 1) #꼭 -1이 아니어도 된다. 여기서는 단지 피보나치 수열에 음수가 나오지는 않으므로 -1로 설정해준 것이다. 인덱스로 접근하려면 +1을 해줘야 한다. ex.[1]은 첫번째 값이 아닌 두번째 값이다.
  memo[0] = 0  #0번째는 리스트로 접근하기 위해 해준 것이므로 아무 숫자나 넣어도 되지만 피보나치수열이므로 혼란이 없게 하기 위하여 0을 넣어준다.
  memo[1] = 1
  def fibo(N):
      if memo[N] == -1:
          memo[N] = fibo(N - 2)+fibo(N - 1)
      return memo[N]
  
  print(fibo(N))
  print(memo)
  
  
  
  output
  8
  [0, 1, 1, 2, 3, 5, 8]
  ```

- 과정

  1)memo라는 임의의 리스트를 설정한다. 이 리스트에  앞으로 호출할 것들이 순서대로 담기게 된다. [0]과 [1]을 미리 설정해준 이유는 그래야 피보나치수열을 산출할 수 있기 때문이다.

  2)fibo함수에 6이 들어감, if에 걸리므로 memo[6]은  fibo(4)+fibo(5)가 되고 이를 구하기 위해 fibo(4)와fibo(5)로 들어감

  ​	(1)fibo함수에 4가 들어감, if에 걸리므로 memo[4]는 fibo(2)+fibo(3)가 되고 이를 구하기 위해 fibo(2) 와 		fibo(3)으로 들어감

  ​		①fibo함수에 2가 들어감, if에 걸리므로 memo[2]는 fibo(0)+fibo(1)가 되고 이를 구하기 위해 fibo(0)과			fibo(1)로 들어감

  ​			ⓐfibo함수에 0이 들어감, if문에 걸리지 않으므로 memo[0]인 0을 리턴함

  ​			ⓑfibo함수에 1이 들어감, if문에 걸리지 않으므로 memo[1]인 1을 리턴함

  ​			ⓒ결국 fibo(0)+fibo(1)는 1이 되므로 memo[2]에는 1이 담기게 됨.

  ​		②fibo함수에 3이 들어감, if에 걸리므로 memo[3]은 fibo(1)+fibo(2)가 되고 이를 구하기 위해 fibo(1)과			fibo(2)로 들어감

  ​			ⓐfibo함수에 1이 들어감, if문에 걸리지 않으므로 memo[1]인 1을 리턴함

  ​			ⓑfibo함수에 2가 들어감, if문에 걸리지 않으므로 memo[2]인 1을 리턴함

  ​			ⓒ결국 fibo(1)+fibo(2)는 2가 되므로 memo[3]에는 2가 담기게 됨.

  ​		③fibo(2)+fibo(3)은 1+2가 되므로 memo[4]에는 3이 담기게 됨.

  ​	(2)fibo함수에 5가 들어감, if에 걸리므로 memo[5]는 fibo(3)+fibo(4)가 되고 이를 구하기 위해 fibo(3) 과 		fibo(4)로 들어감

  ​		①fibo함수에 3이 들어감, if에 걸리지 않으므로 memo[3]인 2를 리턴함

  ​		②fibo함수에 4가 들어감, if에 걸리지 않으므로 memo[4]인 3을 리턴함

  ​		③fibo(3)+fibo(4)는 2+3이 되므로 memo[5]에는 5가 담기게 됨.

  ​	(3)결국 fibo(4)+fibo(5)는 3+5가 되므로 memo[6]에는 8이 담기게 되고 그 상태로 조건문을 빠져나온 		     	     memo[6]를 리턴하게 되어 8이 출력된다. 

  

  - 이처럼 메모이제이션을 사용하면 한 번 호출한 함수를 다시 호출할 필요가 없으므로 실행 시간이 훨씬 빨라진다. 당장 위와 같이 단순한 코딩도 실행 과정이 절반으로 줄어드는데 더 복잡하고 더 큰 수를 다룰 경우 훨씬 더 실행시간이 줄어들게 된다.








DFS예제

```python
def dfs(visited, V):
    print(V, end=" ")
    for i in range(1, N + 1):
        if arr[V][i] == 1 and i not in visited:
            visited.append(i)
            dfs(visited, i)


N, M = map(int, input().split())

arr = [[0] * (N + 1) for _ in range(N + 1)]       #N+1을 해주는 이유는 인덱스와 맞추기 위해서

for i in range(M):
    st, ed = map(int, input().split())
    arr[st][ed] = arr[ed][st] = 1       #방향성이 있을 경우 이 문장은 쓰면 안됨, 방향성이 있으면 st에서 ed로만 갈 수 있지 ed에서 st로 갈 수는 없다.

dfs([1], 1)

#input값
# 7 8(7개의 지점과 8개의 연결)
# 1 2
# 1 3
# 2 4
# 2 5
# 4 6
# 5 6
# 6 7
# 3 7

output
1 2 4 6 5 7 3 
```

 위의 코드에서 재귀함수인 dfs에서는 크게 2가지의 과정이 이루어 지게 된다.
첫째로 우리 눈에 보이는 과정으로 우리가 생성한 visited 배열에 우리가 거쳐간 수들이 하나씩 담기는 것이고, 우리 눈에는 보이지 않지만 컴퓨터가 수행하는 과정으로 스택에 컴퓨터가 수행한 작업들을 쌓아 나가는 과정이다.

1) 눈에 보이는 과정, 즉 visited 배열에 거쳐온 숫자들이 쌓이는 과정이다. 맨 윗줄은 각 지점을, 다음 줄은 배열에 들어가게 되는 순서를 나타낸다.

| 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 7    | 3    | 5    | 4    | 6    |

2)눈에 보이지 않지만 컴퓨터가 수행하는 과정.

(1)1단계

| ST.5 V=5, i=1부터 검토를 시작, i=1~i=7까지 훑어도 해당사항이 없으므로 이 스택 전체가 pop되고 다시 이전 스택으로 돌아감 |
| ------------------------------------------------------------ |
| ST.4 V=6,i=1부터 검토를 시작, i=5일 때 arr\[V][i]의 값이 1이므로(∵arr\[st][ed] = arr\[ed][st] = 1) 5를 visited에 넣은 후 다음 스택으로,이 스택에는 V=6,i=1~5까지가 담김 |
| ST3. V=4,i=1부터 검토를 시작, i = 6일 때 arr\[V][i]의 값이 1이므로 6을 visited에 넣은 후 다음 스택으로,이 스택에는 V=4,i=1~6까지가 담김 |
| ST2. V=2,i=1부터 검토를 시작  i=4일 때 arr\[V][i]의 값이 1이므로 4를 visited에 넣은 후 다음 스택으로,이 스택에는 V=2,i=1~4까지가 담김 |
| ST1. V=1(main)V=1,i=1부터 검토를 시작, V=1,i=2일때 arr\[V][i]의 값이 1이므로 2를 visited에 넣은 후 다음 스택으로, 다음 스택에선 i가 V가 됨, 이 스택에는 V=1,i=1~2까지가 담김 |

(2)2단계

| ST6. V=3, i=1부터 검토를 시작, i=1~i=7까지 훑어도 해당사항이 없으므로 이 스택 전체가 pop되고 다시 이전 스택으로 돌아감 |
| ------------------------------------------------------------ |
| ST5. V=7, i=1부터 검토를 시작, i=3일때 arr\[V][i]의 값이 1이므로 7을 visited에 넣은 후 다음 스택으로,이 스택에는 V=7,i=1~3까지가 담김 |
| ST4. V=6,i=1~5까지가 담긴 이 스택으로 다시 돌아와 V=6, i=6부터 검토 시작, i = 7일 때 arr\[V][i]의 값이 1이므로 7을 visited에 넣은 후 다음 스택으로,이 스택에는 V=4,i=1~7까지가 담김 |
| ST3. V=4,i=1~6까지가 담김                                    |
| ST2. V=2,i=1~4까지가 담김                                    |
| ST1. V=1,i=1~2까지가 담김                                    |

(3)단계

| ST5.V=7,i=1~3까지가 담김, i=4부터 i=7까지 훑어도 해당사항 없으므로 pop되고 이전 단계로 돌아감 |
| ------------------------------------------------------------ |
| ST4.V=4,i=1~7까지가 담김, 해당 사항 없으므로 pop되고 이전 단계로 돌아감 |
| ST3.V=4,i=1~6까지가 담김, i=7을 마저 조사해도 해당사항 없으므로 pop되고 이전 단계로 돌아감 |
| ST2.V=2,i=1~4까지가 담김, i=5부터 i=7까지 훑어도 해당사항 없으므로 pop되고 이전 단계로 돌아감 |
| ST1. V=1,i=1~2까지가 담김, i=3부터 i=7까지 훑어도 해당사항 없으므로 전체 과정이 종료 |

cf. 편의를 위해 V가 바뀔 때마다 스택이 변하는 것처럼 작성하였으나 실제로는 V,와 i가 변하는 모든 과정이 스택에 담기는 것이다. 즉 V=1, i=1~4까지 담긴 스택은 아래와 같다.

| V=1, i=1일때 stack | V=1, i=2일때 stack | V=1, i=3일때 stack | V=1, i=4일때 stack |
| ------------------ | ------------------ | ------------------ | ------------------ |
|                    |                    |                    | V=1, i=4           |
|                    |                    | V=1, i=3           | V=1, i=3           |
|                    | V=1, i=2           | V=1, i=2           | V=1, i=2           |
| V=1,i=1            | V=1, i =1          | V=1, i=1           | V=1, i=1           |



