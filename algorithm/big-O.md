# big-O

- big-O(혹은 O) notation

  - 입력값이 무한대로 향할 때 함수의 상한을 설명하는 수학적 표기법이다.
  - 입력값이 커질 때 알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 어떻게 증가하는지를 분류하는 데 사용된다.

  - 점근적 실행 시간(Asymptotic Running Time)을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나이다.
    - 점근적 실행 시간: 입력값 n이 무한대로 향할 때 함수의 실행 시간의 추이를 의미한다.
    - 컴퓨터의 빠른 처리 능력으로 인해 복잡한 알고리즘이라도 입력의 크기가 작으면 금방 종료된다.
    - 따라서 입력의 크기가 충분히 클 때 알고리즘의 효율성을 정확히 측정할 수 있다.
    - 점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있다.
  - 시간 복잡도(Time Complexity)
    - 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도최고(Computational Complexity)를 의미한다.
    - 계산 복잡도를 표기하는 대표적인 방법이 big-O다.
    - big-O로 시간복잡도를 계산할 때는 최고차항만을 표기하며 계수는 무시한다.



- big-O 표기법의 종류
  - O(1)
    - 입력값이 아무리 커도 실행 시간은 일정하다.
    - 상수 시간을 갖는 알고리즘은 최고의 알고리즘이라 할 수 있다.
    - 그러나 상수 시간에 실행된다고 해도 상수값이 매우 크다면 사실상 일정한 시간이 의미가 없다.
  - O(log n)
    - 매우 큰 입력값에도 영향을 받지 않는 편이다. 
    - 웬만한 n의 크기에 대해서도 매우 견고하다.
  - O(n)
    - 입력값만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다.
    - 이 시간 복잡도를 가지는 알고리즘을 선형 시간(Linear-Time) 알고리즘이라 한다.
  - O(n log n)
    - 대부분의 효율 좋은 정렬 알고리즘이 이에 속한다.
  - O(n<sup>2</sup>)
    - 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당한다.
  - O(2<sup>n</sup>)
    - 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다.
  - O(n!)
    - 외판원 문제를 브루트 포스로 풀이할 때가 이에 해당한다.
    - 가장 느린 알고리즘으로, 입력값이 조금만 커져도 웬만한 다항 시간 내에는 계산이 어렵다.



- 상한과 최악
  - 빅오는 상한을 의미한다.
  - 하한을 의미하는 빅오메가, 평균을 의미하는 빅세타가 있는데, 업계에서는 빅세타와 빅오를 하나로 합쳐 단순화해서 표현하려는 경향이 있다.



- 분할 상환 분석(Amortized Analysis)
  - 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나.
    - 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 등장했다.
    - 로버트 타잔이 [상각된 계산 복잡도(Amortized Computational Complexity)]라는 논문에서 처음으로 소개했다.
  - 분할 상환 혹은 상각이라고 표현하는, 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다.





---

---

---





- 알고리즘과 병렬화
  - 딥러닝의 인기와 함께 병렬화가 큰 주목을 받고 있다.
  - 근래에 들어서는 알고리즘의 우수성을 평가할 때, 병렬화가 가능한지도 평가한다.



- 자료구조, 자료형, 추상 자료형
  - 자료구조
    - 데이터에 효율적으로 접근하고 조작하기 위한 데이터의 조직, 관리, 저장 구조를 의미한다.
    - 학문적인 성격이 강하다.
  - 자료형
    - 자료구조를 특정 언어에서 구현한 것이다.
    - 컴파일러 또는 인터프리터에게 프로그래머가 어떻게 데이터를 사용하는지 알료주는 일종의 데이터 속성이다.
  - 추상 자료형(ADT)
    - 자료형에 대한 수학적 모델을 지칭한다.
    - 해당 유형의 자료에 대한 연산들을 명기한 것이다.
    - 행동만을 정의할 뿐 실제 구현 방법은 명시하지 않는다.





- Python에서 Boolean은 내부적으로 0 과 1로 처리되는 정수형의 subclass이다.



- Python str immutable

  ```python
  str1 = "abc"
  print(id(str1))
  str1 += "d"
  print(id(str1))
  
  str1[0] = "z"	# error
  ```

  - int immutable

  ```python
  my_int = a
  print(id(my_int))
  my_int += 1
  print(id(my_int))
  ```



- Python List의 주요 연산의 시간복잡도

  | 연산           | 시간 복잡도 | 설명                                                         |
  | -------------- | ----------- | ------------------------------------------------------------ |
  | len(a)         | O(1)        | 전체 요소의 개수를 반환                                      |
  | a[i]           | O(1)        | 인덱스 i의 요소를 반환                                       |
  | a[i:j]         | O(k)        | 인덱스 i부터 j-1까지 k개의 요소를 가져온다, k 개의 객체에 대한 조회가 필요하므로 O(k)이다. |
  | elem in a      | O(n)        | elem 요소가 존재하는지 확인한다. 처음부터 순차탐색하므로 n만큼의 시간이 소요된다. |
  | a.count(elem)  | O(n)        | elem 요소의 개수를 반환한다.                                 |
  | a.index(elem)  | O(n)        | elem 요소의 index를 반환한다.                                |
  | a.append(elem) | O(1)        | 리스트의 마지막에 elem을 추가한다.                           |
  | a.pop()        | O(1)        | 리스트의 마지막 요소를 추출한다.                             |
  | a.pop(0)       | O(n)        | 리스트의 첫 번째 요소를 추출한다. 그 후, 뒤의 요소들을 앞으로 한 칸씩 땡긴다(메모리 상의 주소를 한 칸씩 땡긴다). |
  | del a[i]       | O(n)        | i에 따라 다르지만, 최악의 경우 O(n).                         |
  | a.sort()       | O(n log n)  | Timsort를 사용하여, 최선의 경우 O(n)에도 가능하다.           |
  | min, max       | O(n)        | 전체를 선형탐색해야한다.                                     |
  | a.reverse()    | O(n)        | 리스트 전체를 뒤집는다.                                      |



- Python의 list
  - Python의 list는 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 type을 연결해 배치하는 연결 리스트의 장점을 모두 지니고 있다.
    - 이는 list의 독특한 구현 방식 때문이다.
  - List의 구현
    - CPython에서 리스트는 요소에 대한 포인터 목록(ob_item)을 가지고 있는 구조체로 선언되어 있다.
    - 리스트 내부의 요소를 추가, 삭제 등의 조작을하기 시작하면, ob_item의 사이즈를 조절해 나가는 형태로 구현되어 있다.
    - 일반적인 배열에서는 연속된 memory 공간에 저장된 동일한 type의 값들을 담는 방식으로 구현하여, 서로 다른 type을 하나의 배열에 넣는 것이 불가능하다.
    - 그러나 Python의 list는 memory 상의 주소들을 가리키는 pointer들을 담아내어, memory 공간에 연속되어 존재하지 않더라도, 즉 type이 다르더라도 하나의 list에 담는 것이 가능하다.



- Dictionary의 주요 연산의 시간 복잡도

  - Python 3.6부터는 dict의 메모리 사용량이 20% 정도 줄어드는 성능 개선이 이루어졌다.
  - Python 3.7부터는 인덱스를 이용해 입력 순서를 유지하도록 변경되었다.

  | 연산           | 시간 복잡도 | 설명                                 |
  | -------------- | ----------- | ------------------------------------ |
  | len(a)         | O(1)        | 요소의 개수를 반환한다.              |
  | a[key]         | O(1)        | 키를 조회하여 값을 반환한다.         |
  | a[key] = value | O(1)        | 키/값을 삽입한다.                    |
  | key in a       | O(1)        | 딕셔너리에 키가 존재하는지 확인한다. |

  

- defaultdict
- counter
- orderedDict
  - python 3.7부터는 사용할 필요가 없어졌다.



- 문자열 슬라이싱
  - 내부적으로 매우 빠르게 동작하므로, 문자열 문제를 풀 때 문자열 슬라이싱으로 풀이가 가능하다면 문자열 슬라이싱을 적극 활용하는 것이 좋다.
  - 문자열을 list로 매핑하여 처리하는 것은 데이터 구조를 다루는 입장에서는 좋은 방법이지만, 별도 자료형으로 매핑하는 과정에서 상당한 연산 비용이 필요하므로 속도가 느려질 수 있다.
  - `[::-1]`을 사용하여 문자열을 뒤집는 것이 `reverse`로 list를 뒤집는 것 보다 5배 정도 빠르다.



- 125
  - `isalnum()`
  - `[::-1]`을 사용한 문자열 뒤집기



- 937

  - `sort` 메서드의 key에는 함수를 넣을 수 있다.
    - 아래 code는 lst의 nested list를 첫 번째 요소로 정렬하되, 첫 번째 요소가 동일할 경우에는 두 번째 요소로 정렬하는 코드이다.

  ```python
  def func(nested_lst):
      return nested_lst[0], nested_lst[1]
  
  lst = [[3, "c"], [3, "a"], [2, "b"], [1, "z"]]
  lst.sort(key=func)
  print(lst)		# [[1, 'z'], [2, 'b'], [3, 'a'], [3, 'c']]
  ```

  - 당연히 lambda 식을 사용하는 것도 가능하다.
    - 위 코드와 완전히 동일하게 동작하는 코드이다.

  ```python
  lst = [[3, "c"], [3, "a"], [2, "b"], [1, "z"]]
  lst.sort(key=lambda x:(x[0], x[1]))
  ```

  - 보다 복잡한 정렬
    - lambda로 표현하기에도 복잡한 방식으로 정렬해야 한다면 아래와 같이 `functools` 패키지에서 제공하는 `cmp_to_key`를 사용하면 된다.
    - `cmp`는 compare의 약어이다.
    - `cmp_to_key`의 인자로는 대소비교를 할 함수를 넘기는데, 이 때 양수를 반환하면 첫 번째 인자가 두 번째 인자보다 크다는 것을 의미하고, 음수를 반환하면 첫 번째 인자가 두 번째 인자보다 작다는 것을 의미하며, 0을 반환하면 두 인자의 값이 같다는 것을 의미한다.

  ```py
  import functools
  
  
  def compare(a, b):
      if a > b:
          return 1
      elif a == b:
          return 0
      else:
          return -1
  
  
  data = [5, 3, 1, 2, 4]
  data.sort(key=functools.cmp_to_key(compare))
  print(data)