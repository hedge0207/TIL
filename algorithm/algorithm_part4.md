- two pointer
  - 배열에서 원래 이중 for문으로 O(N<sup>2</sup>)에 처리되는 작업을 2개 포인터의 움직임으로 O(N)에 해결하는 알고리즘
    - 완전 탐색으로 풀면 시간 초과가 나는 문제에 적용하면 풀리는 경우가 많다.
  - 종류
    - 앞에서 시작하는 포인터와 끝에서 시작하는 포인터가 만나는 형식
    - 동일한 지점에서 시작하여 빠른 포인터가 느린 포인터 보다 앞서가는 방식
  - 유사한 알고리즘으로 슬라이딩 윈도우가 있다.



- List를 최대한 균등하게 N분할하기

  - code

  ```python
  def split(a, n):
      k, r = divmod(len(a), n)
      result = []
      st = 0
      print(k, r)
      for i in range(n):
          # 나머지가 다 소진될 때 까지 앞에서부터 1개씩 추가한다.
          # 뒤에 있는 것들은 1칸씩 밀리기에 또 다시 1씩 증가시키면서 더해줘야한다.
          # 나머지가 다 소진되면, 나머지 만큼만 더해준다.
          ed = (i + 1) * k + min(i + 1, r)
          arr = a[st:ed]
          st = ed
          result.append(arr)
  
      return result
  
  
  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
  for i in split(arr, 4):
      print(i)
  ```

  - 예시
    - `[1,2,3,4,5,6,7,8,9,10,11]`라는 list를 4(`N`)분할 하고자 한다.
    - Element의 개수가 11개이므로 `11 // 4`를 하면 2가 되고, 나머지(`11 % 4`)는 3이 된다.
    - 즉, 4개로 분할하면 분할 된 list 하나 당 2개가 들어가고 3개가 남게 된다.
    - `[1, 2]`, `[3, 4]`, `[5, 6]`, `[7, 8]`이 되고, `[9, 10, 11]`은 남게 된다.
    - 남은 3개의 element를 앞에서부터 하나씩 추가하여 `[1, 2, 9]`, `[3, 4, 10]`, `[5, 6, 11]`, `[7, 8]`이 되도록 해도 되지만, 이러면 list의 순서를 유지해야 하는 경우 문제가 된다.
    - 따라서, 처음에 분할 할 때 부터 앞에서부터 나머지에서 1개의 element씩을 빼서 분배해주는 방식을 사용해야한다.
    - 즉 나머지가 3이므로 처음 반복문을 순회할 때 나머지 중 1개를 더 추가하여 `[1,2,3]`으로 분할한다.
    - 다음 순회 때 나머지 중 1개를 더 추가하여 `[4,5,6]`으로 분할한다.
    - 다음 순회 때 나머지 중 1개를 더 추가하여 `[7,8,9]`로 분할한다.
    - 더 이상 나머지가 남아있지 않으므로 남은 것은 나머지 추가 없이 `[10, 11]`로 분할한다.
    - 즉 나머지를 r이라 할 때, 처음 분할 된 r개의 list에는 몫 + 1개의 element가 들어가게 되고, 더 이상 나머지가 남아있지 않은 r ~ N까지의 list에는 몫 만큼의 element가 들어가게 된다.
  - 구현
    - `+ min(i + 1, r)`는 순전히 나머지 처리를 위한 것으로, 나머지가 0이라면 이 코드는 필요 없다.
    - `min`을 제외하면 code는 `(i + 1) * k + i + 1`가 된다.
    - 여기서 `+1`은 나머지를 1개씩 추가해주기 위함이다.
    - 앞의 순회에서 `+1`을 하여 나머지 1개 만큼을 추가했으므로, 뒤에서는 index가 1씩 밀리게 되어 index를 뒤로 갈 수록 점점 증가시켜줘야한다.
    - 이를 위해서 순회시마다 1씩 증가하는 `i`를 사용하여, `i`를 더해준다. 
    - 따라서 더 이상 추가할 나머지가 남아있지 않으면, 즉 `i+r > r`이면, 더 이상 `+1` 씩 index를 더해주지 않고 앞에서 추가한 index의 개수 만큼만 index를 뒤로 미룬다.
  - 즉 위 code는 더 풀어쓰면 아래와 같다.

  ```python
  def split(a, n):
      k, r = divmod(len(a), n)
  
      result = []
      i = 0
      st = 0
      remaining_r = r
      while i < n:
          # 나머지가 0일 때의 끝 index
          ed = (i + 1) * k
      	# 만약 더 이상 분배할 나머지가 없다면,
          # 앞에서 밀린 index를 만큼을 ed에 추가해준다.
          if remaining_r == 0:
              ed += r
          # 아직 남아 있는 나머지가 있다면,
          else:
              # 나머지 중 1 개를 ed에 추가하고
              ed += 1
              # 나머지에서 1을 뺀다.
              remaining_r -= 1
              # 그 후 나머지로 인해 밀린 index를 반영하기 위해 i를 더한다.
              ed += i
          result.append(a[st:ed])
          st = ed
          i += 1
      return result
  
  
  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
  for i in split(arr, 5):
      print(i)
  ```






# 에라스토테네스의 체

- 에라스토테네스의 체

  - 소수(prime number)를 판별하는데 사용하는 알고리즘이다.
    - 고대 그리스의 수학자 에라스토테네스가 발견하였다.
    - 체 처럼 소수가 아닌 수 들을 걸러낸다.
  - 알고리즘
    - 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다.
    - 나열한 수를 앞에서부터 탐색해 나간다.
    - 첫 수인 2는 소수이므로 소수라는 표시를 한다.
    - 나열 된 숫자들에서 2의 배수인 것들은 모두 소수가 아니라는 표시를 한다.
    - 3은 표시가 되어 있지 않고, 소수이므로 소수라는 표시를 한다.
    - 나열 된 숫자들에서 3의 배수인 것들은 모두 소수가 아니라는 표시를 한다.
    - 4는 소수가 아니라는 표시가 되어 있으므로 넘어간다.
    - 5는 표시가 되어 있지 않고, 소수이므로 소수라는 표시를 한다.
    - 나열 된 숫자들에서 5의 배수인 것들은 모두 소수가 아니라는 표시를 한다.
    - 이를 모든 수에 대해 반복한다.
  - 구현

  ```python
  def prime_list(n):
      # 에라토스테네스의 체 초기화: n개 요소에 True 설정(소수로 간주)
      sieve = [True] * n
  
      # n의 최대 약수가 sqrt(n) 이하이므로 i=sqrt(n)까지 검사
      m = int(n ** 0.5)
      for i in range(2, m + 1):
          if sieve[i] == True:           # i가 소수인 경우
              for j in range(i+i, n, i): # i이후 i의 배수들을 False 판정
                  sieve[j] = False
  
      # 소수 목록 산출
      return [i for i in range(2, n) if sieve[i] == True]
  ```

  - 주의사항

    > [참고](https://nahwasa.com/entry/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4-%ED%98%B9%EC%9D%80-%EC%86%8C%EC%88%98%ED%8C%90%EC%A0%95-%EC%8B%9C-%EC%A0%9C%EA%B3%B1%EA%B7%BC-%EA%B9%8C%EC%A7%80%EB%A7%8C-%ED%99%95%EC%9D%B8%ED%95%98%EB%A9%B4-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)

    - n까지의 소수 판별시에 n의 제곱근까지만 확인하면 된다(위 코드에서도 `n ** 0.5`까지만 확인했다).
    - n은 자연수 a, b에 대해 `n = a * b`라고 표현할 수 있다.
    - 또 n의 제곱근 m에 대해 `n = m * m`라고 표현할 수 있다.
    - 따라서, `a * b = m * m`이라 할 수 있다.
    - 이 때, a, b는 자연수여야하므로, a, b가 자연수임을 만족하는 경우는 아래의 세 가지 경우 뿐이다.
    - `a=m & b=m`, `a<m & b>m`, `a>m & b<m`
    - 즉, `min(a, b)<=m`이라고 할 수 있다.
    - N의 약수에 해당하는 a와 b 중 하나는 무조건 m 이하이므로, m까지만 조사하면 n이 소수인지 알 수 있게 된다.



# 연결 리스트

- Floyd's cycle finding algorithm(Hare-Tortoise algorithm)

  - 단일 연결 리스트에 cycle이 존재하는지를 판별하는 알고리즘이다.

    - 거치는 모든 노드를 저장 할 필요 없이, 포인터 두 개만 있으면 되므로 공간복잡도 O(1)에 해결이 가능하다.
    - 시간 복잡도는 O(n)이다.

  - 방식

    - 한 칸씩 전진하는 포인터(slow pointer, tortoise)와 두 칸씩 전진하는 포인터(fast pointer, hare)를 동일한 시작점에서 출발시킨다.
    - 만일 연결 리스트에 순환이 존재할 경우 두 포인터는 반드시 만나게 된다.
    - 만약 순환이 존재하지 않을 경우 fast pointer가 연결리스트의 끝에 도달하게 된다.

  - 이를 사용하여 cycle의 시작점을 찾을 수도 있다.

    - 한 칸씩 전진하는 포인터(slow pointer, tortoise)와 두 칸씩 전진하는 포인터(fast pointer, hare)를 동일한 시작점에서 출발시킨다.
    - 두 포인터가 만나게 되면 둘 중 한 포인터를 시작점으로 돌려보낸다.
    - 이제 두 포인터 모두 한 칸씩 전진시키면, 두 포인터가 만나는 지점이 순환의 시작점이다.

  - cycle의 시작점을 찾는 원리

    - y는 두 포인터의 시작점부터 순환의 시작점까지의 거리이다.
    - z는 순환의 시작점부터 두 포인터가 만나는 지점까지의 거리이다.
    - l는 순환의 길이이다.
    - f는 fast pointer가 순환을 돈 횟수, s는 slow pointer가 순환을 돈 횟수이다.
    - $x_n$은 연결 리스트의 n번째 노드이다.
    - $x_i$는 두 포인터가 만나는 노드이다.
    - $x_j$는 순환 내부에 있는 노드이며, 순환 내부에 있는 노드 $x_j$에 대해 아래의 공식이 성립한다. 즉, node가 순환 내에 존재한다면 몇 순환을 몇 번 돌아도 같은 지점에 도착하게 된다.

    $$
    x_{j+kl} = x_j\ \ (j \geλ\ and \ k\ge0)
    $$

    

    - 이 때 두 포인터가 만날 때 까지 slow pointer가 이동한 거리 i는 아래와 같다.

    $$
    i = y+(s*l)+z
    $$

    - fast pointer는 slow pointer의 두 배씩 이동하므로, 두 포인터가 만날 때 까지 fast pointer가 이동한 거리 2i는 아래와 같다.

    $$
    2i = y+(f*l)+z
    $$

    - 2i에서 i를 빼면 아래와 같다.

    $$
    i = (f-s)l
    $$

    - 이제 첫 번째 식에서 j에 y를 대입한다.
    - y는 연결 리스트의 시작점부터 순환의 시작점까지의 거리이므로, $x_y$가 가리키는 node는 순환이 시작되는 node이고, 따라서 순환 내부에 있는 node라 할 수 있다.
    - 그 다음 k값에는 fast pointer가 순환을 돈 횟수에서 slow pointer가 순환을 돈 횟수를 뺀 f-s를 대입하면 식은 아래와 같다.

    $$
    x_{y+(f-s)l} = x_y
    $$

    - 여기서 우리는 `(f-s)l`의 값이 i라는 것을 알고 있으므로, 식은 아래와 같이 변경될 수 있다.

    $$
    x_{y+i}=x_y
    $$

    - 즉 두 포인터가 만나는 지점($x_i$)에서 y만큼 이동하면 사이클이 시작되는 지점($x_{y+i}$)로 돌아갈 수 있다.

  - Runner technique
    - 두 개의 pointer를 동일한 시작점에서 서로 다른 속도로 출발시킨다는 아이디어로 다양한 문제 해결이 가능하다.
    - 예를 들어 cycle이 없는 연결 리스트에서 fast pointer가 끝에 도달하면, slow list는 중간 지점에 도달하게 되는데, 이를 사용하여 회문 판별등을 할 수 있다.








# Deque와 우선순위 큐

- Deque(Double-Ended Queue, 데크, 덱)
  - 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료형.
    - 일반적으로 이중 연결 리스트를 사용하여 구현한다.
  - Python의 경우 `collections` 모듈에서 `deque`로 지원한다.
  - 시간복잡도
    - 양쪽 끝에서의 삽입은 O(1).
    - 양쪽 끝에서의 삭제는 O(1).
    - 양쪽 끝의 원소 확인은 O(1).



- 우선순위 큐
  - 추출시 우선순위가 가장 높은 요소를 추출하는 자료형
    - 스택은 가장 나중에 들어간 요소가 먼저 추출되고, 큐는 가장 처음 들어간 요소가 먼저 추출된다.
    - 그러나 우선순위 큐는 특정 조건에따라 우선순위가 가장 높은 요소가 추출된다.
  - 시간복잡도(당연히 구현에 따라 달라지며, 아래는 힙을 사용했을 경우의 시간복잡도이다).
    - 원소의 추가는 O(lg N).
    - 우선순위가 가장 높은 요소의 확인은 O(1).
    - 우선순위가 가장 높은 요소의 추출은 O(lg N)





# 연결리스트

- Array와 list

  > 자료구조로서의 array, list와 프로그래밍 언어에서의 array, list를 분리해서 생각해야한다.
  >
  > 예를 들어 C의 영향으로 array는 길이를 변경할 수 없다고 생각하지만, 자료구조로서의 array는 단순히 메모리상에 원소를 연속하여 배치한 구조로, 길이를 변경하지 못할 이유가 없다.

  - array
    - 일반적으로 배열이라 번역되는 array는 메모리상에 원소를 연속하게 배치한 자료구조이다.
    - 메모리상에 연속적으로 배치하므로, index를 사용하여 k번째 원소를 상수 시간에 찾는 것이 가능하다.
    - 추가적으로 소모되는 메모리의 양(overhead)가 거의 없다.
    - 메모리상에 연속된 구간에 할당해야하므로 할당에 제약이 존재한다(C는 이러한 제약을 극복하기 위해 array의 길이를 변경하지 못하게 설계됐다).
    - Cache hit rate가 높다.
  - array의 시간복잡도
    - index를 알고 있을 경우 해당 index에 해당하는 값에 접근하는 것과 변경하는 것의 시간복잡도는 O(1)이다.
    - 임의의 위치에 자료를 추가하거나 삭제하는 연산의 시간복잡도는 O(n)이다. 추가, 삭제 이후 element들을 한 칸씩 당기거나 밀어야 하기 때문이다.
    - array의 마지막에 원소를 추가, 삭제하는 경우의 시간복잡도는 O(1)이다.

  - list
    - 메모리상에 원소를 불연속적으로 배치한 자료구조이다.
    - 메모리상에 원소를 불연속적으로 배치하므로 index를 통한 접근이 불가능하다.
    - 배열과 유사한 역할을 하지만 차이가 있다면 빈 element를 허용하지 않는다는 것이다.
    - 빈틈없는 데이터의 적재가 가능해 낭비되는 메모리가 거의 없다.
    - 배열과 마찬가지로 원소들 사이의 순서가 존재하며, 또한 배열과 마찬가지로 중복을 허용한다.
    - 연속되어 배치되지 않으므로 Cache hit rate가 낮다.



- 연결리스트
  - 데이터 요소의 선형 집합으로, 데이터의 순서가 물리적인 순서대로 저장되지 않는다.
    - 컴퓨터과학에서 배열과 함께 가장 기본이 되는 대표적인 선형 자료구조 중 하나로 다양한 추상 자료형(Abstract Data Type, ADT) 구현의 기반이 된다.
    - 동적으로 새로운 노드를 삽입하거나 삭제하기가 간편하며, 연결 구조를 통해 물리 메모리를 연속적으로 사용하지 않아도 되기 때문에 관리도 쉽다.
  - 랜드 연구소에서 근무하던 앨런 뉴얼이 동료들과 함께 만든 언어인 IPL의 기본 자료구조로 처음 사용됐다.
  - 연결 리스트의 성질
    - 배열과는 달리 특정 인덱스에 접근하기 위해서는 전체를 순서대로 읽어야하므로 상수 시간에 접근할 수 없다.
    - 메모리상에 연속되어 배치되지 않으므로 cache hit rate가 낮다.
    - 각 원소가 다음 원소, 혹은 이전과 다음 원소의 주소값을 가지고 있어야하므로, 추가적인 메모리 공간(overhead)이 요구된다. 
    - 예를들어 32비트 컴퓨터면 주소값이 32비트(=4바이트) 단위이니 4N 바이트가 추가로 필요하고, 64비트 컴퓨터라면 주소값이 64비트(=8바이트) 단위이니 8N 바이트가 추가로 필요하게 된다. 즉 N에 비례하는 만큼의 메모리를 추가로 쓰게 된다.'
  - 시간 복잡도
    - 탐색과 변경에는 O(n)이 소요된다.
    - 반면, 시작 또는 끝 지점에 아이템을 추가, 삭제, 추출하는 작업은 상수 시간에 가능하다.
    - 시작 또는 끝 지점이 아닌 임의의 공간에 추가와 삭제를 하는 경우 추가 또는 삭제 할 곳의 주소를 알고 있을 때에만 O(1)이다.
    - 예를 들어 1->34->17->22와 같은 연결 리스트가 있을 때, 세 번째 원소 뒤에 61을 추가하려 한다면 이는 상수 시간 내에는 불가능하다.
    - 세 번째 원소가 어디인지를 찾는데 시간이 소요되기 때문이다.
    - 단, 주소를 알고 있을 경우에는 단순히 추가하려는 원소 앞의 원소가 가리키는 주소를 추가한 원소의 주소로 바꾸고, 추가한 원소가 가리키는 주소를 뒤의 원소로 바꿔주기만 하면 된다.



- 연결 리스트의 종류
  - 단일 연결 리스트(Singly linked list)
    - 각 원소가 다음 원소의 주소를 가지고 있는 연결 리스트
  - 이중 연결 리스트(Doubly linked list)
    - 각 원소가 자신의 다음 원소의 주소와 이전 원소의 주소를 가지고 있는 연결 리스트
    - 이전 원소의 정보를 알 수 있다는 장점이 있지만, 단일 연결 리스트에 비해 추가적인 메모리가 필요하다는 단점이 있다.
  - 원형 연결 리스트(Circular linked list)
    - 처음 원소와 마지막 원소가 연결되어 있는 연결 리스트
    - 단일 연결 리스트이면서 원형 연결 리스트일 수도, 이중 연결 리스트이면서 원형 연결 리스트일 수도 있다.
