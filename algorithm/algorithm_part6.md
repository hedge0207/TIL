# Raft Consensus Algorithm

> https://seongjin.me/raft-consensus-algorithm/
>
> [Paxos 보다 쉬운 Raft Consensus](https://medium.com/rate-labs/raft-consensus-%EC%9D%B4%ED%95%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%95%A9%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%97%AC%EC%A0%95-f7ecb9f450ab)
>
> [In Search of an Understandable Consensus Algorithm](https://raft.github.io/raft.pdf?ref=seongjin.me)

- 뗏목 합의 알고리즘

  - 다수 노드로 이루어진 분산 시스템에서 전체 노드의 최신화 및 동기화 그리고 내결함성(False Tolerance)을 동시에 구현하기 위해 만들어진 합의 알고리즘이다.
    - 내결함성이란 시스템의 일부 구성 요소가 작동하지 않더라도 전체 시스템은 계속 작동할 수 있는 기능을 의미한다.
  - Diego Ongaro와 John Ousterhout이 [In Search of an Understandable Consensus](https://raft.github.io/raft.pdf?ref=seongjin.me)라는 논문을 통해 처음 소개했다.
    - 같은 목적을 위해 고안된 다른 알고리즘보다 이해와 구현이 쉬운 알고리즘을 만드는 것을 목표로 하여 만들어졌다.
  - Raft라는 이름을 붙인 이유
    - 통나무들(logs)을 모아서 무엇을 할 수 있을지를 생각하다 뗏목이 떠올랐다.
    - 기존에 널리 쓰이던 합의 알고리즘은 Paxos 알고리즘이라는 섬으로부터 탈출할지를 생각했다.
  - 합의(consensus)
    - 내결함성을 가진 분산 시스템의 기본이 되는 개념이다.
    - 분산 시스템 내에서 특정 데이터에 대한 동일한 값을 유지하기 위해 고안된 개념이다.
    - 분산 시스템 내의 노드들이 특정 데이터에 대한 동일한 값을 유지함으로써 일부 노드에 장애가 생기더라도 전체 시스템은 일관된 값을 제공할 수 있다.

  - 많은 분산 시스템이 채택한 알고리즘이다.
    - Kubernetes의 etcd
    - Docker swarm
    - MongoDB의 replica set



- Node의 종류
  - Leader
    - 클러스터를 대표하는 하나의 노드.
    - 클라이언트가 클러스터로 보낸 명령의 수신 및 전파, 그리고 클라이언트로의 응답을 처리한다.
    - 자신의 상태 메시지(heartbeat)를 주기적으로 모든 팔로워에게 전파한다.
  - Follower
    - 클러스터 내에서 리더가 아닌 모든 노드들.
    - 리더로부터 전파된 명령을 처리하는 역할을 수행한다.
  - Candidate
    - 리더가 없는 상황에서 새 리더를 정하기 위해 전환된 follower.
    - 리더로부터 일정 시간 이상 상태 메시지(heatbeat)를 받지 못한 팔로워는 candidate로 전환된다.



- 메시지 전파 방식
  - 리더는 수신된 명령에 대한 log를 생성하여 로컬에 저장한 뒤 모든 팔로워에게 복제하여 전달한다.
    - 각 팔로워는 전달받은 로그에 대한 응답을 다시 리더에게 보낸다.
  - 리더가 수신한 정상 응답 수가 클러스터 전체 노드의 과반수에 이르면, 리더는 로그를 통해 전파된 명령을 클러스터의 모든 노드가 동일하게 수행하도록 한다.
    - 그리고 그 결과를 클라이언트에게 반환한다.
    - 리더는 해당 로그를 클러스터 전체 노드가 똑같이 보유할 때 까지 로그 재전송을 주기적으로 반복한다.
  - 제 때 명령을 처리하지 못 한 팔로워가 있더라도, 그 팔로워는 정상 상태로 복구된 뒤 클러스터와의 연결이 재개되면 리더로부터 그동안의 명령 처리 기록이 포함된 로그들을 다시 전달받아 순차적으로 진행한다.



- 리더 선출
  - 관련 용어
    - Term: 새로운 선거가 시작된 시점주터 그 선거로 선출된 리더가 리더로서 기능하는 동안까지의 시간을 의미한다.
    - Election Timeout: 팔로워 상태의 노드가 후보자로 변환되기까지 대기하는 시간으로, 150~300ms 사이의 각기 다른 임의의 값이 주어진다.
    - Heartbeat: 리더가 다른 모든 팔로워에게 일정 시간 간격으로 반복 전달하는 메시지이다.
  - 리더 선출 과정
    - Term 번호가 부여되고, 클러스터 내의 각 노드들에 임의의 election timeout이 부여된다.
    - 리더가 없는 상태에서 모든 노드가 팔로워 상태를 유지하며, 각자에게 주어진 election timeout이 될 때까지 대기한다.
    - Election timeout에 가장 먼저 도달한 노드가 후보자로 전환되고, 새로운 term이 시작된다.
    - 후보자 노드는 자신에게 투표한 뒤 다른 노드들에게 투표 요청 메시지를 전송한다.
    - 만약 투표 요청 메시지를 수신한 노드가 해당 term 중에 아직 투표한 적이 없다면, 해당 메시지의 발신한 후보자 노드에게 투표 메시지를 보낸 후 자신의 election timeout을 초기화한다(이를 통해 선거 기간 중에 다른 후보자가 나오지 않게 된다).
    - 전체 노드 수의 과반에 해당하는 응답을 얻은 노드는 해당 term에 대한 새로운 리더로 선정된다.
  - 리더 노드가 리더 역할을 유지하는 방식
    - 리더 노드는 모든 팔로워 노드들에게 주기적으로 heartbeat를 전송한다.
    - 팔로워 노드는 리더 노드로부터 heartbeat를 받을 때 마다 자신의 election timeout을 초기화한다.
    - 이를 통해 리더가 정상적으로 동작하는 동안에는 새로운 후보자 노드가 나오지 않게 된다.
  - 리더에 문제가 생길 경우
    - 리더에 문제가 생겨 heartbeat를 전송하지 못할 경우 election timeout에 도달하는 노드가 생기게 된다.
    - Election timeout에 도달한 node는 후보자 노드로 전환되고, term 번호가 1 증가하게 된다.
    - 이후 위에서 살펴본 과정대로 리더 선출을 진행한다.
  - Term 번호의 역할
    - 클러스터의 모든 노드는 현재의 term 번호를 저장해두고, 서로 메시지를 주고 받을 때 이 번호도 함께 전송한다.
    - 문제가 생겼던 이전 리더 노드가 복구되면, 이 노드는 클라스터가 공유하는 term 번호와 자신의 term 번호를 비교한다.
    - 현재 클러스터 내에서 공유중인 term 번호가 자신의 번호가 낮은 것을 확인하면, 이전 리더 노드는 팔로워 노드로 전환된다.
  - 과반을 얻지 못하는 경우
    - 예를 들어 4개의 노드로 구성된 클러스터에서 매우 낮은 확률로 두 개의 노드가 동시에 후보자 노드가 되고, 이들이 각 2표씩을 얻는 경우가 있을 수 있다.
    - 이럴 경우 그대로 해당 term을 종료하고 새로운 term 번호와 함께 재선거를 시작한다.



- 정족수(Quorum)

  - 합의 알고리즘에서 일정 합의에 이르기 위해 필요한 수를 의미한다.
    - 뗏목 알고리즘에서 새로운 리더를 선출하기 위해서는 과반(`(N+1)/2`)이상의 응답을 얻어야 하므로, 이 때의 정족수는 `(N+1)/2`이다.
  - 클러스터의 관리 및 내결함성을 유지하는데 사용된다.
    - 정족수가 충족되지 않을 경우 클러스터가 제대로 기능할 수 없게 된다.
  - 내결함성을 위한 최적의 노드 수
    - 대부분의 합의 알고리즘을 채택한 분산 시스템에서는 전체 노드 수를 3 이상의 홀수로 두는 것을 권장한다.
    - 아래 표에서 확인할 수 있듯, 전체 노드 수가 3개일 때 부터 일부 노드에 장애가 발생해도 내결함성을 유지할 수 있다.
    - 또한 짝수로 구성하는 것도 가능은 하지만, 정족수의 비율이 홀수인 경우에 비해 높다는 단점이 있다.
    - 예를 들어 전체 노드가 3개인 경우나 4개인 경우 모두 허용 가능 장애 노드의 수는 1로 동일하지만, 정족수는 4개인 경우가 더 높다.
    - 그리고 짝수일 경우 후보자들이 동일한 수의 표를 얻어 재선거를 해야 하는 경우가 생길 수 있으므로 홀수로 설정하는 것이 좋다.

  | 전체 노드 수 | 정족수 | 허용 가능 장애 노드 수 |
  | ------------ | ------ | ---------------------- |
  | 1            | 1      | 0                      |
  | 2            | 2      | 0                      |
  | 3            | 2      | 1                      |
  | 4            | 3      | 1                      |
  | 5            | 3      | 2                      |
  | 6            | 4      | 2                      |
  | 7            | 4      | 3                      |
  | 8            | 5      | 3                      |
  | ...          | ...    | ...                    |
  | 2k           | k+1    | k-1                    |
  | 2k+1         | k+1    | k                      |



- Log
  - Log
    - Log는 index, term 번호, 상태 변경 명령으로 구성된 entry의 집합이다.
    - index와 term 번호가 같다면 같은 명령을 저장하고 있어야하는데, 이를 Log Matching이라한다.
  - Commit entry
    - Log는 leader가 생성하고, 과반수 이상의 서버에 복제되면 commit 된 것으로 간주한다.
    - 커밋할 때는 이전에 생성한 모든 로그까지 한꺼번에 commit한다.
    - 한 번 commit된 entry는 다음 term의 leader들에게 반드시 포함되는데, 이를 Leader Completeness라 부른다.
  - Log 복제 과정
    - Client가 leader node에게 data를 전송한다.
    - Leader node는 해당 data를 저장하고 있다가 다음 heartbeat를 다른 노드들에게 전송할 때 이 data를 log로 만들어서 함께 전송한다.
    - Follower 들 중 과반 이상이 해당 요청을 정상적으로 받을 경우 값이 commit 된다.
    - Leader는 client에게 응답을 보낸다.



- 구현
  - [simpleRaft](https://github.com/streed/simpleRaft) github repository에서 Python으로 raft algorithm을 구현한 코드를 볼 수 있다.
  - 다른 언어로 구현한 ratf alogrithm은 [링크](https://raft.github.io/?ref=seongjin.me)에서 볼 수 있다.