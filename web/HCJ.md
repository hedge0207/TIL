# CSS 문서 표현(상)

- CSS: Cascading Style Sheets의 약자로 HTML이 문서의 구조화하는 역할을 한다면 CSS는 스타일을 정의하는 역할을 한다.



- CSS의 특징
  -  HTML 요소에 스타일 적용하기 위해 사용
  - 스타일 시트 파일이라고도 한다.
  - HTML 요소의 시각적 특성을 변경함



- CSS의 장점
  - 디자인을 정의, 관리, 재활용하는데 용이
  - 하나의 CSS파일은 다수의 HTML에서 사용할 수 있어 체계적이고 경제적
  - HTML과 함께 사용되지만 HTML은 아님, CSS는 스타일언어
  - HTML 외에 다른프로그래밍 언어와 사용 가능



- CSS 작성 방법(HTML과 짝을 이루어 사용) 세 가지
  - HTML요소에 직접 CSS 정의(인라인): HTML 요소에 스타일 속성 이용
  - CSS를 모아서 정의(내부참조): HTML 헤더 부분에 stlye 요소 사용
  - CSS 파일을 만들어 HTML에 연결(외부참조): 세 방법 중 가장 권장되는 방법 방법
    - HTML이 서버에서 웹 브라우저로 로드 될 때 CSS 파일도 같이 로드
    - HTML 내용 화면에 나타낼 때 외형 디스플레이에 CSS파일 참고됨



- CSS의 화면 정의 내용
  - 텍스트의 크기 및 스타일
  - 요소들의 레이아웃
  - 그림, 섹션 요소들의 크기와 테두리, 배경 색 또는 이미지
  - 화면 전환이나 요소들의 움직임



- CSS 기술 방식

  - 기본 기술 방식

    - 형태: 선택자{속성 선언}

      - 선택자: HTML의 어떤 요소들에 속성들이 적용되는지 정의하는 곳, 형태는 단순한 요소명, 클래스, ID 또는 복잡한 논리 형 등으로 다양

      - 속성 선언: 선택자를 통해 선택된 HTML요소에 적용할 스타일 속성 내용, 속성(정의하는 스타일의 내용)과 값으로 구성됨.

        -하나의 선택지는 하나의 속성 선언을 가짐

        -각각의 속성 선언은 ;(세미콜론)으로 분리, 하나의 속성 선언만 쓰더라도 꼭 붙여야 한다.

        -속성 선언은 {}사용

    ```css
    #예시
    h1{font-size:1.5em;}  #h1요소에 {}안과 같은 속성을 적용하겠다.
    font-size는 속성을, 1.5em은 값을 의미한다.
    font-size외에도 width(넓이), height(높이), color(폰트 색), font-weight(폰트 크기) 등의 속성이 있으며 따로 설정하지 않으면 기본값으로 설정된다.
    ```



- HTML 문서에 CSS 적용과 연결

  - HTML 요소 속성으로 CSS 적용(임베딩 스타일)

    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <style>
          h1 { color: red; }
          p  { background: aqua; }
        </style>
      </head>
      <body>
        <h1>Hello World</h1>
        <p>This is a web page.</p>
      </body>
    </html>
    ```

    

      - 선택지를 통하여 직접 요소에 CSS 스타일 추가

      - 방법: 스타일 속성을 통하여 CSS 스타일 적용

      - CSS 속성 선언: ;(세미콜론)으로 분리하여 선언

    - 이와 같은 방법은 편리하다는 장점이 있지만 아래와 같은 단점이 존재하므로 피해야하고 테스트용으로만 사용해야 한다.

      -동일 요소 공통으로 적용 불가

      -수정 및 변경 시 모든 HTML 코드 검토

      -체계적인 관리와 변경 불가능

  - Style 요소를 사용한 CSS적용(인라인 스타일)
  
    - 방법: head 부분에 선택자를 이용하여 style 요소 정의
    - CSS코드가 위치한 HTML 파일에만 적용
    - 전체 수정 시 모든 HTML 파일을 수정해야 한다는 단점이 존재
    - style요소의 속성
      - type:stlye언어가 어떤 MIME 타입인지 지정
      - media: 현재 CSS코드가 어떤 매체일 경우 지정되는지 지정
  
    ```html
    <!DOCTYPE html>
    <html>
      <body>
        <h1 style="color: red">Hello World</h1>
        <p style="background: aqua">This is a web page.</p>
      </body>
    </html>
    ```
  
  - 외부 CSS 파일을 HTML파일에 연결(링크 스타일)
  
    ```html
    <!DOCTYPE html>
    <html>
      <head>
          <link rel="stylesheet" href="css/style.css">
      </head>
      <body>
        <h1>Hello World</h1>
        <p>This is a web page.</p>
      </body>
    </html>
    ```
  
    ```css
      h1 { color: red; }
      p  { background: blue; }
    ```
  
    - 여러 HTML 파일에 공통으로 사용
  
      - 수정 시 HTML 파일을 전체 수정할 필요 없음
  
      - 체계적이고 구조적인 스타일 관리 가능
  
      - 파일 크기를 줄일 수 있어 전체 전송량이 줄어듬
  
      - 외부 스타일 시트 파일: .css를 가지는 파일, 텍스트로 이루어짐
  
      - HTML에서 외부 CSS 파일의 연결 순서
  
        -HTML 코드 작성
  
        -비어있는 파일을 작성하고 확장자 .css로 저장
  
        -CSS파일 경로 지정(HTML 코드 header 부분에 link요소 사용)
  
        -CSS 파일 열어 CSS 스타일 지정
  
      - link 요소: HTML 문서와 외부 리소스 연결을 위해 사용, 대부분 CSS 파일 연결
  
      - link 요소의 속성
  
        - rel: 생략 불가능한 속성, 현재 HTML과 연결할 파일 간의 관계를 나타냄, 다양한 값을 가진다.
        - href: 연결하고자 하는 리소스 파일 경로 지정



- CSS 선택자(selecter)

  - 선택자는 스타일을 적용하고자 하는 HTML 요소를 선택하기 위한 수단이다.

  - 선택자로 HTML 요소를 선택하고 {}내에 속성과 값을 지정하여 다양한 스타일을 설정할 수 있다. 여러 개의 속성을 연속해서 지정할 수 있으며 ;으로 구분한다. 복수개의 셀렉터를 연속하여 지정할 수 있으며 쉼표( , )로 구분한다.

    ```css
    h1{color:red;font-size:12px;}
    선택자: h1
    선언: color:red;, font-size:12px;
    선언 블록: {color:red;font-size:12px;}
    속성(프로퍼티):color, font-size
    값: red, 12px
    
    /*복수의 선택자 지정*/
    h1, p { color: red; }
    ```

  

  - 타입 선택자(기초 선택자)

    - 가장 쉽고 기본이 되는 기초적인 선택자
      
    - HTML요소명, 요소의 클래스 속성 값, ID 값
      - HTML선택자(태그 셀렉터): HTML요소가 선택자인 선택자

        ```html
        <!--형식: 태그명-->
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            /* 모든 p 태그 요소를 선택 */
            p { color: red; }
          </style>
        </head>
        <body>
          <h1>Heading</h1>
          <div>
            <p>paragraph 1</p> p태그 요소 이므로 red로 출력
            <p>paragraph 2</p> p태그 요소 이므로 red로 출력
          </div>
          <p>paragraph 3</p>   p태그 요소 이므로 red로 출력
      </body>
        </html>
        ```

      - 클래스 선택자: HTML 클래스 속성 값, 요소들을 원하는 그룹으로 묶을 수 있음, HTML 문서 내의 동일한 클래스 값을 가지는 모든 요소에 적용, .(온점)으로 표시한다.

        ```html
        <!--형식: .class 어트리뷰트 값-->
        <!DOCTYPE html>
        <html>
        	<head>
                  <style>
                    /* class 어트리뷰트 값이 text-center인 모든 요소를 선택 */
                    .text-center { text-align: center; }
                    /* class 어트리뷰트 값이 text-large인 모든 요소를 선택 */
                    .text-large  { font-size: 200%; }
                    /* class 어트리뷰트 값이 text-red인 모든 요소를 선택 */
                    .text-red    { color: red; }
                    /* class 어트리뷰트 값이 text-blue인 모든 요소를 선택 */
                    .text-blue   { color: blue; }
                  </style>
            </head>
            <body>
                  <!--class 어트리뷰트 값이 text-center이므로 중앙에 표시됨-->
                  <p class="text-center">Center</p>
                  <!--class 어트리뷰트 값이 text-red이므로 빨강으로 표시됨-->
                  <!--class 어트리뷰트 값이 text-large이므로 200% 크기도 표시됨-->
                  <p class="text-large text-red">Large Red</p>
                  <!--class 어트리뷰트 값이 text-center, text-large, text-blue이므로
                	중앙에 빨강색으로 200%크기로 표시됨-->
                  <p class="text-center text-large text-blue">Center Large Blue</p>
            </body>
        </html>
        ```

      - ID 선택자: HTML ID 속성 값에 CSS를 적용, HTML ID 속성은 HTML 문서 내의 유일한 값으로 고유의 요소를 식별한다. 문서 내의 같은 ID를 가진 유일한 요소에 적용한다. #으로 표현한다.

        ```html
        <!--형식: #id 어트리뷰트 값-->
        <!DOCTYPE html>
        <html>
           <head>
             <style>
               /* id 어트리뷰트 값이 p1인 요소를 선택 */
               #p1 { color: red; }
             </style>
           </head>
           <body>
             <h1>Heading</h1>
             <div class="container">
               <p id="p1">paragraph 1</p> <!--id 어트리뷰트 값이 p1이므로 빨강으로 출력-->
               <p id="p2">paragraph 2</p>
             </div>
               <p>paragraph 3</p>
                </body>
        </html>
        ```

      - 그룹 지정: 여러 요소에 동일한 CSS 스타일 적용

      - 전체 셀렉터

        ```html
         <!--형식: * -->
        <!DOCTYPE html>
        <html>
            <head>
              <style>
                /* 모든 요소를 선택 */
                * { color: red; }
              </style>
            </head>
            <body>
              <h1>Heading</h1>
              <div>
                <p>paragraph 1</p>  <!--전체 셀렉터이므로 전부 빨강으로 출력-->
                <p>paragraph 2</p>  <!--전체 셀렉터이므로 전부 빨강으로 출력-->
              </div>
              <p>paragraph 3</p>    <!--전체 셀렉터이므로 전부 빨강으로 출력-->
           </body>
        </html>
        ```

    - 고급 선택자

      - HTML 문서의 요소들의 계층관계를 이용하여 선택하는 선택자

      - CSS는 상속을 통해 부모 요소의 속성을 자식에게 상속한다.

        - 상속 되는 것: Text 관련 요소(font, color 등)
        - 상속 되지 않는 것: Box model 관련 요소(width, height 등)와 position관련 요소(position, left, right 등)

        - MDN에서 상속 여부를 확인 할 수 있다.

      - HTML 요소들의 계층관계: 요소들 간의 포함 관계에 따라 자손요소, 직계 자손 요소, 형제 요소, 인접 형제 요소등으로 나뉜다.

        - 자손 요소: 특정 요소의 내부에 포함된 요소

        - 직계 자손 요소: 특정 요소의 바로 아래 있는 요소

        - 형제 요소: 같은 계층 단계에 있는 요소

        - 인접 형제 요소: 바로 아래 있는 형제 요소

        - 고급 선택자의 종류

          -하위 선택자: 어떤 요소 하위에 있는 특정 자손 요소 선택 시 사용. 대괄호로 표현

          -형제 선택자: 특정 요소 다음에 나오는 형제 관계 요소들 선택. ~(물결무늬)로 표현

          ```html
          <!DOCTYPE html>
          <html>
            <head>
                <style>
                  /* p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택한다.*/
                  p ~ ul { color: red; }
                </style>
            </head>
            <body>
                <div>A div element.</div>
                <ul>
                  <li>Coffee</li>
                  <li>Tea</li>
                  <li>Milk</li>
                </ul>
              
                <p>The first paragraph.</p>
                <ul>
                  <li>Coffee</li>	<!--p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소-->
                  <li>Tea</li>	<!--p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소-->
                  <li>Milk</li>	<!--p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소-->
                </ul>
              
                <h2>Another list</h2>
                <ul>
                  <li>Coffee</li>	<!--p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소-->
                  <li>Tea</li>	<!--p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소-->
                  <li>Milk</li>	<!--p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소-->
              </ul>
            </body>
          </html>
          ```

          

          -직계 자손 선택자: 바로 하위에 있는 요소 선택 시 사용, 여러 단계에 있는 자손을 모두 선택하는 하위 선택자와는 다름. 꺽쇠로 표현

          ```html
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              /* div 요소의 자식요소 중 p 요소 */
              div > p { color: red; }
            </style>
          </head>
          <body>
            <h1>Heading</h1>
            <div>
              <p>paragraph 1</p>	<!--div 요소의 자식요소 중 p 요소-->
              <p>paragraph 2</p>	<!--div 요소의 자식요소 중 p 요소-->
              <span><p>paragraph 3</p></span> <!--div요소의 자식요소지만 p요소가 아님-->
            </div>
          <p>paragraph 4</p>	<!--p요소지만 div 요소의 자식요소가 아님--
          </body>
          </html>
          ```

  				
  			
  				-인접 형제 선택자: 특정 요소 바로 다음에 오는 형제 관계 요소 선택.+로 표현
  				
  				```html
  				<!DOCTYPE html>
  				<html>
  				<head>
  				  <style>
  				    /* p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택한다. */
  				    p + ul { color: red; }
  				  </style>
  				</head>
  				<body>
  				  <div>A div element.</div>
  				  <ul>
  				    <li>Coffee</li>
  				    <li>Tea</li>
  				    <li>Milk</li>
  				  </ul>
  				
  				  <p>The first paragraph.</p>
  				  <ul>
  				  	<!--p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소-->
  				    <li>Coffee</li>
  				    <!--p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소-->
  				    <li>Tea</li>
  				    <!--p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소-->
  				    <li>Milk</li>	
  				  </ul>
  				
  				  <h2>Another list</h2>
  				  <ul>
  				    <li>Coffee</li>
  				    <li>Tea</li>
  				    <li>Milk</li>
  					</ul>
  				  </body>
  				</html>
  				```
  				
  				


- CSS 적용 우선 순위(중요)
  - 중요도: !important가 정의 되면 다른 무엇이 있든 최우선 순위를 가진다.
    - 따라서 굉장히 주의해서 사용해야 한다.
  - 우선 순위: 인라인 > id선택자 > class 선택자 > 요소 선택자
  - 소스 순서(선언 순서, 뒤에 작성된 것이 최종적으로 적용 된다)
  
  ```html
  h3 { color: violet !important}
  p { color: green; }
  .blue { color: blue; }  <!--.blue에서 .은 클래스를 의미한다.-->
  .skyblue { color: skyblue; }
  #red { color: red; }   <!--#red에서 #은 아이디를 의미한다.-->
  
  소스코드가 위와 같을 때 아래의 숫자들은 무슨 색으로 출력 되겠는가?
  
  
  요소선택자 
  <p>1</p> 
  1은 초록 색으로 출력. ∵p { color: green; }
  
  요소선택자 VS class선택자
  <p class="blue">2</p> 
  2는 파란색으로 출력. ∵.blue { color: blue; }
  
  소스 순서
  <p class="blue skyblue">3</p> 
  3은 하늘색으로 출력.
  <p class="skyblue blue">4</p> 
  4는 하늘색으로 출력.
  
  id선택자 VS class 선택자
  <p id="red" class="blue">5</p> 
  5는 빨간색으로 출력.  ∵#red { color: red; }
  
  !important VS id선택자
  <h3 id="red" class="blue">6</h3> 
  6은 바이올렛색으로 출력 ∵h3 { color: violet !important}
  
  id VS 인라인
  <p id="red" class="blue" style="color: yellow;">7</p> 
  7은 노란색으로 출력 ∵style="color: yellow
  
  !important VS 인라인
  <h3 id="red" class="blue" style="color: yellow;">8</h3>
  8은 바이올렛색으로 출력 ∵h3 { color: violet !important}
  ```
  
  



- 의사 클래스(X)
  - 가짜 또는 모조 클래스로 클래스의 특징은 가진다.
  - 형식: :(콜론)의사 클래스 명
  - 링크와 관련된 의사 클래스
    - : link 링크 의사 클래스: 한 번도 방문하지 않은 링크
    - : visited 의사 클래스: 방문한 링크에 CSS 스타일 적용 시 사용
  - 동적 의사 클래스: 마우스와 커서에 관한 상태를 의사 클래스로 나타냄
    - active의사 클래스: 마우스로 클릭 했을 때의 상태 의미
    - hover 의사 클래스: 마우스 커서가 올라간 상태 의미
    - focus 의사 클래스: 서식 폼과 같은 요소에 마우스가 위치하여 입력 또는 선택 상황 의미
  - 구조적 의사 클래스: HTML 구조에 따른 의사 클래스
    - 형재와 자손 그리고 몇 번째 요소인지로 상태 구분
    - root 의사 클래스: 문서 최상위 요소 의미, 단독으로 사용
    - empty 의사 클래스: 비어 있는 요소 의미
    - only-child 의사 클래스: 형제가 없는 요소
    - only-of-type 의사 클래스: 같은 타입의 형제가 없을 때 사용
    - first-child, last-child 의사 클래스: 첫 번째 자손 요소와 마지막 자손 요소를 의미
    - nth-of-type(n), nth-last-of-type(n): 같은 부모 요소의 자손 요소로 특정 요소의 n번째 요소를 의미한다는 점은 같지만 전자는 위에서부터 세어가고 후자는 아래에서부터 세어감.
  - 기타 의사 클래스 
    - :lang() 의사 클래스 : 지정한 언어 속성을 가지는 요소
    - :not() 의사 클래스 : 부정을 의미
  - 의사 엘리먼트: 가짜 요소, 선택자에 따라 기존 요소에 추가로 새로운 요소 정의
    - :first-letter 의사 엘리먼트 : 선택자에서 선택한 요소의 첫 번째 글자를 새 요소로 만듦
    - :first-line 의사 엘리먼트 : 선택자에서 선택한 요소의 첫 번째 줄을 새 요소로 만듦 
    - :after, :before 의사 엘리먼트 : 선택자에 의해 선택된 요소 앞뒤에 요소를 만듦



- 미디어 쿼리: 현재 HTML 문서가 보여지는 화면이 어떤 것인지 파악

  ex.스마트 폰인지 pc인지 테블릿 pc인지를 파악

  

- 상속과 캐스케이딩: HTML 요소에 적용된 CSS 스타일 중 어떤 것들은 하위 자식에게 상속된다.
  - 적용 우선 순위
    - 사용자가 선택자를 통해 직접 정의한 스타일
    - HTML에 스타일 속성으로 적용한 인라인 스타일
    - 미디어 타입에서 지정한 속성
    - !important 구문을 추가한 CSS 속성
    - 구체적인 선택자
    - 뒷 부분에 정의된 스타일
    - 부모로부터 상속된 스타일
    - 웹 브라우저 기본 스타일 





---







# CSS 문서 표현(하)

- 텍스트 표현(있다는 것만 알아 둘것)
  - 폰트 패밀리: 비슷한 모양의 서체를 묶어서 제시, 만일 지정한 서체가 없을 경우 대안 서체를 사용하게 된다.
  
  - 서체의 크기 조절
    - font-size: 서체 크기 조절
    
    - 서체의 크기 단위: px(픽셀), %, em(요소에 지정된 사이즈에 상대적인 사이즈를 지님), rem(최상위 요소(HTML)의 사이즈를 기준으로 배수 단위를 가짐, rootrem이라고 생각하면 된다), Viewport 기준 단위(vw,vh,vmin,vmax)
    
    - 다양한 변형 서체(쓰지 않는 것이 좋다)
      - Iralic: font-style 속성으로 설정한다.
      
        | 속성    | 설명                                                         |
        | ------- | ------------------------------------------------------------ |
        | italic  | italic 타입의 서체로 변환                                    |
        | oblique | 단순히 서체를 기울임, 이텔릭 타입 서체가 존재하지 않을 경우 사용 |
        | normal  | italic 타입의 서체 사용하지 않고 보통 서체로 보여줌          |
      
      - bold: font-weight 속성으로 설정한다.
      
        | 속성    | 설명                                                 |
        | ------- | ---------------------------------------------------- |
        | bold    | 해당 서체 bold타입의 서체로 변환                     |
        | bolder  | 부모 요소의 두께보다 좀 더 두꺼운 타입의 서체로 변환 |
        | ligther | 부모 요소의 두께보다 좀 더 얇은 타입의 서체로 변환   |
        | 100~900 | 100~900사이의 서체의 굵기로 변환                     |
        | normal  | bold 타입의 서체 일반 타입의 서체로 변환             |
    
  - 텍스트 스타일 설정
  
    - 텍스트 간격 설정: 글자와 글자의 간격 또는 단어와 단어의 간격 설정
      - 자간 설정 : letter-spacing 속성 사용
      - 단어 간격 설정 : word-spacing 속성 사용 
      - 행간 설정 : line-height 속성 사용
  
  - 기타 텍스트 꾸미기(X)
  
    - text-decoration 속성 사용
      - undrline: 밑줄 생성
      - overline: 텍스트 위에 줄 긑기
      - line-throught: 텍스트 중간에 줄을 그어줌
      - none: 밑줄 없앰
    - text-transform 속성 사용
      - capitalize: 각 단어의 첫 글자 대문자로 만드는 속성
      - uppercase: 모든 텍스트 대문자 변환
      - lowercase: 모든 텍스트 소문자 변환
      - none: 대소문자 변경 기능 없앰
    - text-shadow 속성 사용
      - x-offset: 그림자가 x축으로 얼마나 비껴 나타나는지 의미
      - y-offset: 그림자가 y축으로 얼마나 비껴 나타나는지 의미
      - blur: 그림자 테두리의 흐림 정도 설정
      - color: 그림자 색
      - none: 그림자 속성 해제
  



- 컬러 
  - 웹 색상 코드: 16진수 표현, 10진수 표현, HSL 표현, 색상 키워드
  - 투명도 표현: 컬러에 투명도 설정이 가능하며 10진수 색상 코드로만 가능하다.
  - 텍스트 색 지정: color 속성 사용



- 배경(있다는 것만 알아 둘 것)
  - 배경 색 설정: background-color 속성 
  - 배경 이미지 설정 : background-image 속성 사용 
  - 배경 이미지 반복 설정 : background-repeat 속성 사용 
  - 배경 이미지 고정 설정 : background-attachment 속성 사용
  - 배경 이미지 위치 설정 : background-position 속성 사용 
  - 배경 이미지 크기 설정 : background-size 속성 사용



- 목록, 표 꾸미기

  - 블릿 꾸미기
    - 블릿: 목록을 정리하여 예쁘게 보이도록 목록 아이템 앞에 붙는 숫자 또는 특수문자
    - 블릿 설정: list-style-type 속성 사용
      - 이미지 블릿 설정: list-style-image 속성 사용
      - 블릿 위치 설정: list-style-position 속성 사용

  

  - Margin과 Padding

    - 모든 블록 레벨 요소들은 박스 형태의 영역을 가지고 있는데 그 바깥쪽 여유 공간을 margin, 안쪽 여유 공간을 padding이라 한다.

    - 마진과 패딩은 상하좌우 개별적으로 설정할 수 있으며 코드 상으로는 시계방향으로 상우하좌 순서로 적게 된다.

      ```html
      margin: 10px, 5px, 12px, 8px;
      위와 같이 적으면 자동으로 상우하좌 순으로 적용된다.
      ```

      

  - border

    - margin과 pading사이의 경계
    - border 생성 속성 : border-width(굵기 지정), border-style(스타일 지정), border-color(색 지정). 이 세 가지가 가장 기본으로 축약하여 작성할 수 있다.

    ```css
    p {border: 1px solid red;} 각기 굵기, 스타일, 색이 들어가게 된다.
    ```
    - 셀 간격 설정: border-spacing: 수치;
    - 셀 간격 삭제: border-collapse:collapse;



- CSS 박스 모델
  - HTML문서 body 부분의 모든 요소가 사각형 영역을 가지고 있는데 박스 모델은 요소를 박스로 나타낼 때 어떻게 구성되며 박스들의 위치와 상관관계를 지정하는 방식을 정의하는 것이다.

  - 박스 모델의 구성은 외부부터 내부순서로 margin-border-padding-content로 구성된다.

    - margin: 테두리(border) 바깥의 외부 여백으로 배경색을 지정할 수 없다
    - border: 테두리 영역
    - padding: 테두리 안쪽의 내부 여백으로, 요소에 적용된 배경의 컬러, 이미지는 패딩까지 적용된다.
    - content: 실제 내용이 위치

  - 아래와 같이 영역을 설정할 수 있다.

    ```css
    .margin{
    margin-top: 수치px;
    margin-right: 수치px;
    margin-bottom: 수치px;
    margin-top: 수치px;
    }
    
    혹은 margin과 padding을 동시에 설정할 수도 있다.
    .margin-padding{
    margin: 수치px;   이 경우 상하좌우가 모두 동일하게 설정된다.
    padding: 수치px;
    }
    
    혹은 아래와 같이 쓸 수도 있다.
    하나만 쓸 경우 4방이 모두 동일한 수치로 설정됨
    .margin-1{      
    margin: 수치px;
    }
    두 개를 쓸 경우 상하는 앞의 수치로, 좌우는 뒤의 수치로 적용됨
    .margin-2{      
    margin: 수치px 수치px;
    }
    세 개를 쓸 경우 첫번째 수치는 상, 두번째는 좌우, 세번째는 하에 적용됨
    .margin-3{      
    margin: 수치px 수치px 수치px;
    }
    네 개를 쓸 경우 시계방향(상우하좌 순)으로 적용됨
    .margin-3{      
    margin: 수치px 수치px 수치px 수치px;
    }
    
    border의 경우 굵기, 스타일, 색이 들어가는데 아래와 같이 쓸 수도 있고
    .border{
    border-width: 수치px;
    border-style: 스타일;
    border-color: 색;
    }
    
    아래와 같이 쓸 수도 있다.
    .border{
    border: 수치 스타일 색;
    }
    ```

  

  - 블록 레벨 요소의 margin과 padding은 상하좌우 사방으로 margin과 padding이 적용되지만 인라인 레벨 요소의 margin과 padding은 좌우만 적용된다(즉 width, height, margin-top, margin-bottom을 지정할 수 없다). 따라서 상하 여백은 line-height로 지정한다.

  - width, height 속성 : 블록 레벨 요소의 크기 설정, 인라인 레벨 요소에는 적용 안됨 
    - width 속성 : 요소의 넓이 설정
    - height 속성 : 요소의 높이 설정

  - 요소의 크기는 width와 height로 설정한 대로 나오지 않는데 그 이유는 이 외에도 요소의 크기에 영향을 미치는 것들이 있기 때문이다. 요소의 크기는 아래의 것들을 모두 합한 값이다.
    - width와 height로 정한 값

    - padding값과 margin값

    - border의 굵기 값

      

  - 기본적으로 모든 요소의 box-sizing은 content-box이다. 즉 padding을 제외한 순수 content영역만 box로 지정한다. 다만 일반적으로 영역을 볼 때는 border까지 포함시킨 너비를 지정하려함. 따라서 이러한 경우 box-sizing을 border-box로 설정한다.

  

  - margin 겹침(상쇄) : 두 개의 margin 연속 적용으로 margin이 겹치는 현상 발생 

  

  - display
    - HTML 4.1까지는 인라인과 블록으로 태그를 구분하였음
    - 블록과 인라인의 차이(HTML 문서 구조(상) 부분에 적어 놓았으니 참고)
    - inline-block은 block과 inline 레벨 요소의 특징을 모두 갖는 것으로 inline처럼 한 줄에 표시 가능하며, block처럼 width, height, margin 속성을 모두 지정할 수 있다.
    - 속성에 따른 수평 정렬

  

  - Position 속성:  특정 요소가 다른 요소들과 어떠한 관계 속에서 위치를 결정하는 지 설정

    - static: 디폴트 값(기준 위치)

      -기본적인 요소의 배치 순서에 따름(좌측상단)

      -부모 요소 내에서 배치될 때는 부모 요소의 위치를 기준으로 배치된다.

    - position 속성의 속성 값 : 상대 위치, 절대 위치, 고정 위치  

    - 아래는 좌표 프로퍼티(top,bottom,left,right)를 사용하여 이동이 가능하다(음수값도 가능)

    - 상대 위치(relative) : static 위치를 기준으로 이동. 

      -position: relative;

    - 절대 위치(absolute) : 가장 가까이 있는 부모/조상 요소중에 static이 아닌  것을 기준으로 이동 

      -position: absolute;

    - z-index 속성 : 어떤 요소가 다른 요소 위에 나타나는지 설정, 속성 값이 높게 설정 될 수록 앞에 배치됨

    - 절대 위치 (fixed) : 부모의 좌표와 관계 없이 브라우저 원점에서 좌표를 정한다. 스크롤 해도 고정되어 있다. (ex. 맨 위로 이동하는 버튼은 스크롤을 내려도 계속 화면을 따라 움직이듯이 우측 하단에 고정되어 있다)

      -position: fixed;





---







# 레이아웃과 고급 CSS 기능

- HTML 요소들은 문서의 위에서부터 아래로 순차적으로 나열되지만 아래의 방법들을 통해 변경될 수 있다.

  - diplay 속성을 통해 요소가 보여지는(표현되는) 방식 변경
    - block,inline,inline-block
    - table, flexible box, grid 등의 레이아웃을 활용
    - position 속성을 통해 위치 자체를 변경
    - float 속성을 통 해 떠 있도록 만듦

- float은 요소를 일반적인 흐름에서 벗어나도록 하는 속성 중 하나

  - 반드시 clear 속성을 통해 초기화가 필요하다.

- float을 사용하는 경우 block사용을 뜻하며, display값이 inline인 경우 block으로 계산한다. 즉 float을 사용한다는 것은 block을 사용한다는 것을 뜻하며 display 값이 inline이라도 block으로 취급한다.

- float 속성을 사용한 2단 레이아웃

  - 한 화면에 많은 정보를 담으면 가독성이 떨어질 수 있으므로 화면을 분할하여 정보를 나눠 담아야 한다.

  - 다단 레이아웃 : 화면을 세로로 여러 개의 단으로 나눠 콘텐츠를 보여주는 형태

  - HTML 문서는 오로지 위에서 아래로 콘텐츠 제시 따라서, 다단 레이아웃을 만들기 위해 floating 또는 positioning 레이아웃 활용

  - float 속성을 사용한 2단 레이아웃 설정 방법

    ① HTML 문서 준비하기 

    ```html
    <!DOCTYPE html>
    <html lang = "ko">
        <head>            		   
        	<meta charset="UTF-8">   
            <title>Title</title>
            <link rel="stylesheet" href="style.css">
        </head>
    <body>
        <div id="wrapper">  <!--HTML 문서의 콘텐츠 영역 속성을 설정하기 위한 요소-->
            <header><h1>Site Title</h1></header>
            <section></section>
    ```

    ② 섹션 요소의 넓이 설정하기 

    	- CSS를 이용하여 HTML 요소의 스타일 지정
    	- 모든 요소의 margin과 padding을 0으로 설정
    	- wrapper: HTML 페이지 고정된 크기 설정
    	- 최종 요소의 넓이: : margin넓이+padding넓이+border의 굵기

    ③ float 속성 설정하기 

    - float 속성에는 left와 right가 있다.
    - 2단 레이아웃 만들기: nav 요소는 왼쪽으로 floating, nav+section요소는 오른쪽으로 floating
    - footer 요소도 설정해줘야 하는데 설정하지 않을 경우 맨 아래에 위치하지 않고 위에 표시되게 된다.
      - nav요소와 nav+section요소의 높이를 같게 설정하거나
      - footer요소에 clear속성을 설정하면 해결된다.

    ④ 2단 레이아웃 완성하기

    - 디자인 스타일을 적용하여 정리하고 꾸밈

  - float 속성 설정보다 position 속성 사용 시 몇 가지 더 신경 써야 함

    - 상대위치와 절대위치
      - 상대위치는 요소 위치 설정 시 초기 위치에 자신의 볼륨을 그대로 유지한다. 따라서 좌표의 원점 파악이 어렵다
      - 절대 위치는 요소들의 원점을 부모요소의 왼쪽 상단으로 통일한다. 그러나 요소의 볼륨에 따른 레이아웃 변화에 적용되지 않는다. 절대위치로 포지션 설정 시 주의사항은 절대 요소로 설정한 요소의 형제와 자식 요소 대부분을 절대요소로 지정하여 수치로 위치를 조정해야 한다는 점이다.

  - display 속성을 이용한 2단 레이아웃 설정하기 
    - 블록 레벨 요소들을 inline-block 형태로 줄바꿈 없이 나란히 놓을 수 있음
    - inline-block으로 디스를레이를 설정하면 블록이 글자와 같이 취급된다.



- CSS네비게이션(X)

  - 인터렉티브 이미지 버튼:  HTML 이용 시 이미지 버튼 만들 수 있음 

  - 텍스트 네비게이션

    - 네비게이션 : 웹 사이트에서 분류된 영역으로 쉽게 갈 수 있는 링크의 모음 
    - 초창기 : 텍스트 네비게이션 → 현재 : 그래픽 네비게이션으로 발전
    - 웹 초창기 : 텍스트 네비게이션 - 제작하기 쉽고 로딩이 빨라 현재도 많이 사용 

  - HTML로 텍스트 네비게이션 구조 작성하기

    - nav 요소 안에서 작성 
    - 네비게이션 HTML 작성 방법 : 목록 형태 → 링크의 목록으로 작성
    - 목록 작성 시 순서는 상관 없음 : \<ol>(순서 있는 목록), \<ul>(순서 없는 목록) 

  - CSS로 텍스트 네비게이션 스타일 적용 하기

    - Key Point! 목록 아이템의 display 속성 : inline 

      ① 링크에 설정되어 있는 기본 스타일 초기화 

      ② 목록 요소에 배경색을 검정으로 설정

      ③ 웹 브라우저 margin, padding 0 으로 설정 

      ④ 마우스 롤 오버 설정하기 : a:hover 선택자



- CSS변형과 트랜지션(X)

  - 요소의 변형

    - 요소 숨기기: 요소가 웹 브라우저에서 보이지 않게 하는 것, 웹 브라우저 내 차지하고 있던 영역사라짐

    - 요소를 숨기는 이유

      ① CSS가 지원되지 않는 웹 브라우저 사용자에게 추가 정보 제공 

      ② 시각 장애를 가진 사용자에게 안내 및 추가 정보 제공 ex) 스크린 리더 

      ③ 웹 문서에서 제공하는 정보가 많을 경우 문서의 가독성을 높이기 위해 ex) 펼쳐지는 콘텐츠 : 사용자 동작으로 콘텐츠가 보였다 가려졌다 하는 기능 

    - CSS에서 요소 숨김 속성

      ① visibility: hidden, 요소를 감출 뿐 사라지게는 하지 않으므로 영역은 계속 차지한다.

      ② display: none , 요소뿐만 아니라 영역도 함께 감춘다.

  - 요소 클리핑
    - clip 속성 : 이미지 또는 요소의 특정 부분 만을 보이게 할 때
      - rect(상, 우, 하, 좌): 요소 내의 상하좌우 좌표를 설정하여 클리핑
    - 요소 클리핑 시, 먼저 요소의 포지션 속성을 절대위치로 설정해야 한다.



- CSS를 어렵게 만드는 요소
  - 일반적인 흐름을 바꿔버리는 경우
  - Normal flow
    - inline, block, relative position
  - Floats
  - Absolute positioning 









---









# CSS 기타

- 프로퍼티

  - 프로퍼티에는 키워드, 크기 단위, 색상 표현 단위 등의 특정 단위를 갖는 값을 지정한다.
  - 각각의 프로퍼티에 따라 사용할 수 있는 키워드가 존재한다.

  ```css
  h1{color:red; font-size:12px; display: block}
  h1: 셀렉터
  color, font-size, display: 프로퍼티
  red,12px: 특정 단위를 갖는 값
  block: 키워드
  ```
  - 크기 단위
    - px: 픽셀 단위, 디바이스 해상도에 따라 상대적인 크기를 갖는다.
    - %: 백분율 단위, 요소에 지정된 사이즈(상속된 사이즈나 디폴트 사이즈)에 상대적인 사이즈를 설정함.
    - em: 배수단위, 요소에 지정된 사이즈(상속사이즈, 디폴트 사이즈)에 상대적인 사이즈를 설정함. 예를 들어 상속받은 사이즈가 14px면 2em은 14*2가 되어 28px가 된다. 중첩된 자식 요소에 em을 지정하면 모든 자식 요소의 사이즈에 영향을 미치기 때문에 주의하여야 한다.
    - rem:  최상위 요소(html)의 사이즈를 기준으로 삼는다. r은 root를 의미한다.
  - 색상 단위
    - RGB: red, green,blue순으로 입력
    - RGBA: red, green,blue, 투명도 순으로 입력(투명도는 0~1까지)
    - HEX코드 단위



- 박스 모델

  - width와 heigth 프로퍼티

    - 각기 요소의 너비와 높이를 지정하기 위해 사용되는 것으로 이때 지정되는 요소의 너비와 높이는 콘텐츠 영역을 대상으로 한다.

      -이는 box-sizing프로퍼티에 기본값인 **content-box**가 적용되었기 때문이다. box-sizing 프로퍼티에 **border-box**를 적용하면 콘텐츠 영역, padding, border가 포함된 영역을 width / height 프로퍼티의 대상으로 지정할 수 있다.

    - width와 height 프로퍼티의 초기값은 auto로써 이것은 브라우저가 상황에 따라 적당한 width와 height 값을 계산할 것을 의미한다.

    - 만일 width와 height로 지정한 콘텐츠 영역보다 실제 콘텐츠가 크면 콘텐츠 영역을 넘치게 된다는 것에 유의하여야 한다.

    -  width와 height 프로퍼티는 **콘텐츠 영역**을 대상으로 요소의 너비와 높이를 지정하므로 박스 전체 크기는 다음과 같이 계산할 수 있다.

      -전체 너비: width + left padding + right padding + left border + right border + left margin + right margin

      -전체 높이: height + top padding + bottom padding + top border + bottom border + top margin + bottom margin

    - width와 height 프로퍼티를 비롯한 모든 박스모델 관련 프로퍼티(margin, padding, border, box-sizing 등)는 상속되지 않는다.

  - margin과 padding 프로퍼티(상기하였으므로 pass)

    - 요소 너비가 브라우저 너비보다 크면 가로 스크롤바가 만들어진다. 이 문제를 해결하기 위해서 max-width 프로퍼티를 사용할 수 있다. max-width 프로퍼티를 사용하면 브라우저 너비가 요소의 너비보다 좁아질 때 자동으로 요소의 너비가 줄어든다.
    - border-style: 테두리의 선의 스타일을 지정. 프로퍼티 값의 갯수에 따라 4개 방향(top, right, left, bottom)에 대하여 지정이 가능하다.
    - border-radius: 테두리 모서리를 둥글게 표현하도록 지정한다. 기본 좌상, 좌하, 우상, 우하 4방향 설정 가능하며 각 방향을 다시 둘로 나눠 총 8방향 설정 가능하다.
    - border: `border` 프로퍼티는 `border-width`, `border-style`, `border-color`를 한번에 설정하기 위한 shorthand 프로퍼티이다(상기함).

  - box-sizing: width와 heigth 프로퍼티 대상 영역을 변경할 수 있다. box-sizing 프로퍼티의 값을 border-box로 지정하면 마진을 제외한 박스 모델 전체를 width, height 프로퍼티의 대상 영역으로 지정할 수 있어서 CSS Layout을 직관적으로 사용할 수 있게 한다.

  







---







# 자바스크립트 기초

-  JavaScript의 역사(브랜던 아이크가 제작)

  - 1990년대 네스케이프사의 Netscape Navigator(NN) 브라우저가 표준

  - 정적인 HTML을 동적으로 표현하기 위한 언어 도입을 결정

  - 1996년 브랜던 아이크 주도로 개발된 'Mocha'를 자체 브라우저에 도입

  - 이후 LiveScript라는 이름을 거쳐 지금의 자바스크립트의 이름으로 변경

  - 브라우저 전쟁과의 연관성

    - 인터넷 익스플로러 3에서 JScript(JavaScript 기반으로 MS가 개발)를 지원, 호환성 문제로 크로스 브라우징등의 이슈 발생
    - Netscape의 후계자들은 이후 모질라 재단 기반의 firefox를 개발
    - 표준화의 시작 : 계속되는 파편화를 방지하고자 Netscape는 ECMA 인터네이셜에 기술 규격을 제출한 이후 발전

  - ES2015(ES6) 버전은 기존 JavaScript의 문제를 많이 해결하고, 코드를 간결하게 작성할 수 있는 새로운 문법들이 추가 되면서 더욱 발전함

  -  Vanilla JS(순수 자바스크립트)

    - 크로스브라우징, 간편한 활용 등을 위해 많은 라이브러리 등장(대표적으로 jQuery)
    - 최근 표준화된 브라우저, ES6 이후의 다양한 도구의 등장으로 순수 자바스크립트 활용의 증대

  - V8엔진은 자바스크립트가 브라우저에서 작동할 수 있도록 돕는 엔진으로 속도가 엄청나게 빠르다.

    - 즉, 프론트 엔드 속도를 향상

  - nodeJS: 기존에 브라우저에서만 실행되던 자바스크립트를 컴퓨터에서도 실행할 수 있게 해주었다.

    - 백 엔드 개발이 가능해짐

      

- JavaScript의 대표적 기능 3가지

  - DOM조작
  - BOM조작
    - navigator, screen, location, frames, history, XHR
  - JavaScript
    - Object, Array, Fuction



- HTML과 CSS 그리고 JavaScript
  - HTML과 CSS는 웹 문서의 구조와 외형을 정의하는 것이며 둘은 문법이 서로 달라 각기 작성하여 연결해서 사용해야한다.
  - JavaScript는 문서의 기능을 정의한다.



- JavaScript의 특징

  - 컴파일 언어와 스크립트 언어

    | 컴파일 언어                    | 스크립트 언어                     |
    | ------------------------------ | --------------------------------- |
    | 컴파일 후 실행                 | 인터프리터를 통해 바로 실행       |
    | 데이터 타입과 형 변환에 엄격함 | 데이터 타입, 형 변환 수월         |
    |                                | 속도가 느리고 실행환경이 제한적임 |

  - 자바스크립트는 스크립트 언어이다.
  - 함수형 언어이다(함수형 프로그래밍을 선언적 프로그래밍이라고도 한다)
    - 함수를 기본으로 프로그래밍 한다.
    - 선언적 프로그래밍이기에 쉽고 효율적으로 HTML요소를 동적으로 처리할 수 있다.
    - 1급 함수이다, 함수 자체를 데이터처럼 사용 가능하다.
    - 변수의 유효 범위 = 함수의 유효 범위
  - Java와는 전혀 다른 프로그래밍 언어이다.
    - 마케팅 목적으로 Java라이센스를 사용할 뿐이다.
    - JavaScript를 의미하는 다른 이름으로는 ECMA-262이다.
  - 초보적인 언어가 아니다.
    - 컴파일 방식에 비해 언어가 엄격하지 않고 고급  프로그래밍 기술을 지원하지 않아 생긴 오해
    - 현재 모바일, 웹 브라우저 등의 기술과 표현이 발전하면서 사용범위 확대
    - 학습 초기에는 쉽지만 복잡한 서비스 구축에 사용될 만큼 강력함
  - 웹 표준이다.
    - HTML, CSS와 더불어 웹 표준이다.
    - HTML5의 JavaScript에 대한 의존도가 높다.
  - 장점
    - 텍스트 에디터와 웹 브라우저만 있으면 프로그래밍이 가능하다.
    - 데이터 타입 및 형 변환이 쉬워 쉡게 학습 가능하다.
    - 컴파일을 거치지 않아 작성한 코드 테스트가 수월하다.



- 데이터 타입과 변수
  - JavaScript의 구문(규칙)
    - 해석순서: 인터프리터(프로그램 언어로 적혀진 프로그램을 기계어로 변환)에 의해 해석되고 실행된다. 위에서부터 아래로 읽어 나간다.
    - 대소문자 구분: HTML과 달리 대소문자를 구분한다. 따라서 둘 사이의 차이로 발생하는 문제를 방지하기 위해 HTML에서도 어느 정도 구분해서 쓰는 것이 좋다.
    - 구문 끝: 세미콜론으로 문장이 끝났다는 것을 표시한다. 특정한 경우에는 생략이 가능하다.
    - 공백과 들여쓰기: JavaScript에서 공백은 키워드와 데이터를 구별해주는 역할을 한다.
      - 변수를 정의하거나 함수를 선언할 때 반드시 공백이 들어간다.
      - 키워드 뒤에 쉼표, 괄호, 연산자가 모두 존재하면 공백을 넣지 않아도 된다.
      - 필요할때가 아니라도 공백과 들여쓰기를 사용하면 코드의 가독성을 높여준다.
    - 주석: 코드에 대한 설명과 노트
      - 여러줄 주석: /\*~~~\*/
      - 한 줄 주석: //
    
  - 원시타입과 객체 타입

    - 원시타입(primitive)

      -변경 불가능한 값(imuutable)

      -불린, 숫자, null undefined, 문자열, symbol이 해당

    - 객체타입(object)

      -원시타입을 제외한 모든 데이터

      -객체란 키와 값으로 구성된 속성(property)의 집합이며, 프로퍼티 값이 함수일 경우 구분을 위해 메소드라고 부른다.

      -일반객체, function,array,data,RegExp

  - 기본 데이터 타입

    cf. 리터럴(literal): 그 자신으로 해석되어야 하는 값

    ```JavaScript
    a = 28라고 하면 a라는 변수에 28이라는 정수혀 리터럴을 할당해준 것이다. 
    ```

    - 숫자(number)

      -정수와 실수 구분 하지 않음, 더 정확히는 정수 타입이 별도로 존재하지 않음.

      -단 정수 리터럴과 실수 리터럴 표현 시 범위가 다르다(단, 크게 문제가 되지는 않는다)

      -실수는 무한대로 생성 가능하다.

      -상수란 미리 정해져 있는 숫자로 원주율이나 중력가속도 등이 이에 속한다.

      -JavaScript에서 상수를 사용할 때는 대소문자 구분이 완벽해야 한다.

      -NaN(Not a Number)와 Infinity, -Infinity도 숫자 타입이다.

      --2\*\*53부터 2\*\*53까지의 수를 가진다. 

      ```JavaScript
      //예를 들어 JavaScript에서 Number.MAX_VALUE는 최대값을 의미하는데
      number.MAX_VALUE
      //위와 같이 쓰면 상수 역할을 하지 못한다.
      ```

    - 문자(string)

      -JavaScript에는 char 데이터 타입이 없음

      -문자열 리터럴은 따옴표로 둘러싸인 문자 집합이다.

      -이스케이프 시퀀스는 파이썬과 마찬가지로 \키를 쓴다.

      -파이썬의 f스트링처럼 템플릿 문자열을 활용하여 문자열 내에 변수를 사용할 수 있다.

      ```javascript
      var a=584 
      console.log(`${a}번 손님`)
      
      out
      584번 손님
      ```

    - boolean

      -문자와 숫자 변환이 자동으로 이루어진다.

  - 단순 데이터 타입

    - null: 어떠한 데이터 타입도 가지고 있지 않음, 변수에 아무 값이 담겨있지 않음, 의도적으로 변수에 값이 없다는 것을 명시하기 위해 사용

    - undefine: 정의되어 있지 않음, 값이 할당된 적 없는 변수, 생성되지 않는 객체에 접근할 때 나옴, 선언 이후 값을 할당하지 않으면 undefine이 디폴트 값으로 할당됨. 즉 null은 의도적으로 변수에 값을 지정하지 않겠다고 표시한 것이라면 undefine은 변수에 값을 아직, 혹은 실수로 할당하지 않은 것이다.

  - 객체 데이터 타입

    - 객체: 다양한 값의 집합, 객체의 값은 property라 하며 이름이 붙여져 있다.

    - 객체의 생성 방법

      -new라는 생성자를 통해 생성할 수 있다. 생성자(new)를 이용한 객체생성은 미리 정의되어 제공하는 객체를 생성한다. 생성자 함수를 만들어 사용하면 마치 클래스처럼 속성이 동일한 객체를 생성할 수 있다.

      -객체 리터럴을 통해서도 생성할 수 있다. 객체 리터럴로 생성할 경우 키가 문자열로 표기될 수 있다면, 암묵적 형변환이 발생한다. 그게 아닌 경우는 반드시 따옴표를 통해서 문자열로 만들어 주어야 함.

    - 객체에 접근은 . 혹은 []로 접근이 가능하지만 []로 접근하는 것이 권장된다.

    

    - 배열: 값의 집합

      -생성자(new)를 이용하여 생성하거나 배열 리터럴을 사용하여 생성할 수 있다.

      -어떠한 데이터 타입이라도 배열의 요소가 될 수 있다.

    - 함수: 미리 정의되어 실행 가능한 코드 덩어리

      -반복하여 호출 가능

      -JavaScript 프로그래밍의 기본 단위

      -하나의 데이터 타입으로 변수에 할당이 가능하다.

      -fuction 키워드로 생성할 수 있다.
      
      -함수는 이름을 설정하지 않아도 사용이 가능하다.

  - 변수

    - 타입 설정하지 않아도 된다.

    - 변수는 어떠한 데이터 타입이라도 담을 수 있다.

      -단 변수는 그 크기가 정해져 있으므로 숫자나 불이언 등의 고정된 크기의 데이터 타입은 그대로 담을 수 있지만 문자열이나 객첵 같은 크기가 정해져 있지 않은 데이터 타입은 변수에 담을 수 없다. 대신 문자열이나 객체의 참조만을 가지고 있다. 이런 종류의 데이터 타입을 참조 타임이라 부른다.

      ```JavaScript
      //기본 타입
      var a=true;
      var b=a;
      a=false;
      document.writeln(b);
      
      out
      true  //a의 값을 바꿔도 b의 값에는 영향이 없음, b는 a를 참조하는 것이 아니라 아예 새로운 변수이기 때문이다.
      
      //참조 타입
      var a=[1,2,3,4];
      var b=a
      a[0]=100
      document.writeln(b);
      
      out
      100,2,3,4   //a의 값을 바꾸면 b의 값도 함께 바뀐다. b는 a를 참조하기 때문이다.
      ```

      

    - 변수 선언은 var를 사용한다.

    - 변수 선언시 키워드(var)를 쓰지 않으면 암묵적 전역으로 설정되므로 반드시 키워드를 설정해야 한다.

    - 선언 되지 않은 변수 사용 시 에러가 발생한다. 따라서 반드시 사용전에 선언되어야 한다.

    - 선언 되지 않은 변수에 변수 값을 할당하면 자동변수가 생성되고 전역변수로 선언된다.

    - 변수의 유효 범위는 함수를 기준으로 결정된다.

      -지역변수: 함수 안에 선언된 변수로 함수 내부로 사용이 제한된다. 함수 내부에서 선언된 변수는 함수 내부의 모든 곳에서 사용이 가능하지만 만약 중첩된 함수 내부에서 부모 함수의 변수와 같은 이름의 변수 선언 시 부모 함수의 변수에 가려진다.

      -전역변수: 모든 함수에서 사용할 수 있는 변수, 전역 변수가 다른 코드에 영향을 주어 오류 발생 위험 존재, 따라서 최소한의 전여 변수만 사용할 것을 권장. 전역변수의 정의는 최상위 위치에서 변수를 선언하여 이루어진다.

    - 자바스크립트에서는 모든 선언을 호이스팅한다.

      ```
      파이썬의 경우
      print(a)
      a = 3
      
      out
      error
      
      자바스크립트의 경우
      console.log(a)
      var a = 3
      
      out
      3
      ```

      -파이썬과 달리 변수를 선언하기 전에 활용할 수 있다.

      -얼핏 편리해 보이지만 많은 오류를 발생시킬 수 있기에 사용해선 안되는 기능이다.

      -let과 const 키워드를 통해 이러한 내용을 방지할 수 있다. 실제로 대부분의 변수 선언은 호이스팅 방지를 위해 let과 const를 통해 이루어진다.

      -var: 변수 재선언, 재할당 가능

      -let: 변수 재선언 불가, 재할당 가능(mutable)

      -const: 변수 재선언 불가, 재할당 불가(immutable)

    



---





# 자바스크립트 문법

- c언어나 java와 유사하나 javascript의 특징인 느슨한 문법으로 인해 자동 형 변환이 일어날 수 있는데 이것만 주의하면 된다. 예를 들어 숫자랑 문자열을 합하면 문자열이 나오게 된다.

- 캐멀 케이스로 네이밍을 주로 한다.

- 파이썬에서 :이 하는 역할을 자바스크립트에서는 중괄호가 한다.

  ```JavaScript
  /*python*/
  if a==b:
  	내용
  
  /*JavaScript*/
  if (a===b) {
  	내용
  }
  ```

  

- 연산자

  - 피연산자의 개수에 따라 분류

    - 단항 연산자: 피 연산자가 1개인 연산자

      - 단 항 산술 연산자: +,-,++,--

        -"+","-":양수, 음수 변경 및 표현, 단, "+"는 음수를 양수로 변경하지 않는다.

        -숫자 형 문자열의 경우 숫자로 자동 형변환된다.

        -"++","--": 증가 연산자와 감소 연산자. 피연산자 앞에 오는지 뒤에 오는지에 따라 효과가 달라진다.
  
        ```javascript
        var x = 5, result;
        // 선대입 후증가 (Postfix increment operator)
        result = x++;
        console.log(result, x); // 5 6
        
        // 선증가 후대입 (Prefix increment operator)
        result = ++x;
        console.log(result, x); // 7 7
        
        // 선대입 후감소 (Postfix decrement operator)
        result = x--;
        console.log(result, x); // 7 6
        
        // 선감소 후대입 (Prefix decrement operator)
        result = --x;
        console.log(result, x); // 5 5 
        ```
      
    
  - 2항 연산자: 피 연산자가 2개인 연산자, +, - * , / , =등
  
  - 3항 연산자:피 연산자가 3개인 연산자. 3항 연산자는 조건부 연산자 단 하나만 존재한다.
  
      -예를 들어 (n%2==0)?은 n,2,0이라는 피연산자가 들어간 3항 연산자다
  
  - 프로그래밍 연산자로 분류
  
    - 산술연산자: 숫자의 사칙연산과 응용연산
  
      - 자동형변환으로 피 연산자에 문자가 포함되어도 연산 가능
  
    - 덧셈 연산자
  
      -피 연산자 모두 숫자면 덧셈 연산을 수행하지만
  
        -피 연산자 중 하나라도 문자열이면 피연산자가 연결된 문자열이 나온다.
  
        ```javascript
      1+1=2
      1+"a"="1a"
      1+"1"="11"
        ```
  
    - 뺄셈과 곱셈 연산자
  
      -숫자 형태의 문자열을 숫자로 자동 형 변환
  
      ```javascript
      456-123=333
      "456"-123=333
      "a"-123=NaN
      123*456=56088
      123*"456"=56088
    123*"a"=NaN
      ```
      
    - 나눗셈 연산자
  
      -피 연산자 모두가 정수라 할지라도 결과는 실수가 나올 수 있음(자바스크립트는 정수 타입이 별도로 존재하지 않음). 
    
      -숫자형 문자열을 숫자로 자동 변환하여 연산
  
      -0으로 나누면 NaN을 반환
  
    - 나머지 연산
  
      -나머지를 결과값으로 취함
  
      -그 외에는 나눗셈과 같다.
  
  - 비교연산자
  
    -true, false로 결과 반환
  
    -피연산자가 숫자일 경우 일반적인 상식대로 대소를 비교한다.
    
    -피연산자가 문자일 경우 문자 코드의 순서대로 크기를 비교한다. 따라서 대문자가 소문자보다 작다고 판단된다.
    
    -피연산자 객체일 경우 객체를 숫자나 문자로 자동 변환하려고 시도하고 변환되지 않으면 false반환
    
  - 논리연산자
    
    -and연산자: &&
    
    -or연산자: \\\\
    
    -not(!): 피 연산자의 불린 값을 반대로 바꿈(단항 연산자)
    
    
    
  - 문자 , 기호 연산자
    
    ex. [1,2,3]에서 대괄호는 배열을 생성하는 기호 연산자이다. new Date에서 new는 객체를 생성하는 문자 연산자이다.
    
  - 할당, 동등, 부등, 일치,불일치 연산자(=,==,!=,===,!==)
    
    -할당 연산자: 값 또는 참조를 변수 등에 전달함
    
    -동등 연산자:  피 연산자의 값이 같은지 판단함. true, false로 결과 반환
    
      -일치 연산자:  데이터 타입과 객체의 참조 등에 사용되어 동등 연산자보다 엄격하게 두 값이 일치하는지 비교한다. true, false로 결과 반환
    
    ```javascript
      var a =123; var b = "123"
      (a==b)는 true지만
      (a===b)는 false이다.
      
      NaN, undefined, null
      NaN: 숫자가 아님을 표시하는 것으로 자신을 포함한 어떤 것과도 같지 않다.
      따라서 어떤 변수가 NaN인지는
      if (a==NaN)으로 확인할 수 없고 isNaN(a)함수를 사용해야 한다.
      반변에 undefined과 null는 동등연산자로 비교시 같다고 나온다.
      NaN은 자신과 일치하지 않는 유일한 값이다.
    ```
    
    - 동등 연산자와 일치 연산자
    
      ```javascript
      0==''  /*true*/
      0=='0' /*true*/
      ''=='0'/*false*/
    삼단 논법에 따르면 마지막도 true여야 하지만 false가 출력된다.
      즉, 논리적으로 모순이 생길 수 있으므로 엄격하게 비교하는 ===를 쓰는 것이 좋다.
      ```
    
    - in 연산자
    
      -문자열이 배열이나 객체에 존재하는지 확인하는 연산자, 불린값을 반환
    
      -구조: (문자열) in (배열/객체)



- 조건문과 반복문

  - 조건문

    - if문: 특정 조건 판단 후 참이면 코드 실행

      -한 줄이라도 {}로 묶어주는 것이 권장된다.

      ```javascript
      if (weight>120) {
      	alert("비만입니다.");
      } else if(weight>100) {
          alert("경도 비만입니다")
      } else{
          alert("비만이 아닙니다")
      }
      ```

    - switch문: 조건에 의해 분기

      -true와 false만 결과로 가지는 if문과 달리 다양한 결과를 가진다.

  - 반복문

    - for문: 반복문을 제어하는 조건과 카운트 변수 정의 가능

      ```javascript
      for문 구조
      for(카운트 변수 초기화;제어 조건;카운트 변수 증가){
      실행코드;
      }
      카운트 변수 초기화: 변수 선언과 함께 꼭 키워드 var붙임
      제어 조건: 카운트 변수에 대한 조건
      변수 증가: ++,-- 사용
      두 번째 실행부터는 변수 초기화 생략하고 실행
      
      ex.1~10의 합
      ver total = 0
      for(var i = 0; i<=10; i++){
          total+=i
      }
      ```

    - while문: ()안의 조건의 결과가 true이면 계속 실행하고 false면 멈춘다.

      ```javascript
      1~10까지 합
      var i = 1
      var total = 0
      while(i<=10){
      	total+=i;
      	i++
      }
      ```

    - do.while문: while문의 변형으로 많이 사용하지는 않음. 조건이 false인 경우라도 한 번은 실행

  - 조건/반복문에서 중단과 이동

    - break문: break문을 감싸고 있는 반복문이나 switch문을 즉시 빠져나옴
    - continue문: 반복문의 시작점으로 돌아가 다음 반복 시작.
    - 레이블: 코드에 이름을 붙인 것, 반복문에서 break, continue 사용 시 어떤 반복문에 사용하는지 명시하는 용도





---





# 내장객체

- 객체 : 여러 값을 모아 놓은 데이터 타입, 배열도 일종의 객체다

- 객체의 값은 이름과 값의 쌍으로 이루어져 있으며 이 쌍을 property라고 부른다.

  - {이름:값}

  - property는 어떠한 데이터 타입이라도 가능하다.
  - 함수로 된 property를 Method라고 부른다.

- 내장객체: 자바스크립트에서 제공하는 객체

- 객체의 생성: class의 instance로 생성, 구체적인 객체를 생성하는 과정을 instance화라고 부른다. 

  - JavaScript에는 class가 존재하지 않지만  객체 생성자 함수와 프로토 타입 정의가 존재하며 이 둘을 모조클래스라 부른다. 

  - JavaScript에서 객체를 생성하는 방법은 다음과 같다.

    - 모조 클래스가 있는 객체는 new(생성자)를 이용하여 객체를 생성한다.
    - 객체를 데이터로 취급하기 때문에 객체 literal을 이용해서도 생성할 수 있다.

  - 객체 literal을 활용한 객체의 생성

    - 객체는 대괄호로 싸여 있다.
    - property들은 쉼표로 분리되고 각 property의 이름과 값은 콜론으로 구분된다.
    - 객체의 property로 객체가 사용될 수도 있다.

    ```javascript
    /*객체 abc를 생성*/
    var abc = {이름1 : 값1, 이름2 : 값2}
    /*비어있는 객체 ooo를 생성*/
    var ooo = {}
    /*비어 있는 객체는 이후에 프로퍼티나 메소드를 추가할 수있다.*/
    ```

  - 생성자(new연산자)를 이용한 객체의 생성

    - 피연산자로 생성자 함수를 필요로 한다.

      ```JavaScript
      /*생성자 함수*/
      fuction abc(a,b){
      		/*함수 내용*/
      }
      /*객체 생성자(new)*/
      var abd = new abc(1,2)  /* new의 피연산자로 생성자 함수abd가 들어갔다*/
      ```

- 객체 프로퍼티

  - 객체 프로퍼티의 접근: 마침표 연산자 사용

  - depth property 사용: depth property는 객체에 존재하지 않는 property를 의미하는데 이 프로퍼티에 할당 연산자를 통해 값을 할당하면 프로퍼티가 생성된다.

    ```JavaScript
    /*abc프로퍼티 뒤에 zxc 프로퍼티를 추가 생성*/
    var a = abc.zxc;  
    /*depth property에 할당 연산자(.)를 사용하여 값을 할당*/
    abc.depth=1;
    ```

  - 프로퍼티의 나열 및 확인: for문 사용

  - 특정 프로퍼티가 객체에 존재하는지 검사: in 연산자 사용, 이때 프로퍼티를 " "로 감싸 문자열로 만들어서 확인해야 한다.

  - delete연산자: delet는 변수를 삭제할 수는 없지만 property는 삭제할 수 있다.

    ```JavaScript
    delete abc.depth;
    ```



- 객체 메소드
  - 메소드: 함수를 값으로 가진 프로퍼티
  - 값이 함수이므로 작동을 위해 사용된다.
  - 생성자 함수의 리터럴로 정의될 수 있다.





---





# 배열과 함수

- 배열: 숫자로 나열된 값의 집합

  - 배열의 값을 원소라고 부른다. 
  - 원소의 이름을 인덱스라 부른다.
  - 배열 생성 후에도 특정 원소를 추가, 수정, 삭제하는 것이 가능하다.
    - 배열의 수정: 배열[수정할 값의 인덱스] = 수정할값;
    - 원소 추가: 배열[배열.length] = 추가할 값;
    - 원소 삭제: delete 배열[삭제할 값의 인덱스];
  - 배열의 원소는 어떤 데이터 타입도 가능하다.

- 객체에 기능을 추가하면 배열이라고 할 수 있다.

- 배열의 생성: 리터럴을 사용한 생성과 생성자를 이용한 생성

  - 배열의 원소를 지정하여 배열을 생성하고자 하는 경우 배열 리터럴을 사용하는 것이 낫다.
  - 배열의 길이를 미리 할당하여 배열을 생성하고자 하는 경우 Array 생성자를 사용한느 것이 낫다.

  ```JavaScript
  /*리터럴을 사용*/
  ver arr = [];
  
  /*생성자를 사용*/
  ver arr = new Array();
  ```

- JavaScript는 배열의 크기를 지정하지 않아도 된다./*

- 파이썬과 마찬가지로 인덱스를 통해 배열의 원소에 접근이 가능하다.

  ```javascript
  var arr = [1,2,3,4,5]
  document.writeln(arr[0]); /*1이 출력된다*/
  
  /*배열의 원소가 객체일 경우*/
  /*ㅏ배열[인덱스].프로퍼티ㅓ로 접근한다.*/
  var arr = [1,2,{a:3},4,5]
  arr[2].a
  
  /*배열의 원소가 함수일 경우*/
  /*뒤에 괄호를 붙이면 함수가 실행된다.*/
  [1,2,3,fuction(){return "aa"},5]
  arr[3]()
  ```

- 배열의 순회
  
  - for, for...of, for...in, forEach등의 방법이 있다.
  - for in은  배열의 요소만 접근 하는 것이 아니라 속성까지도출력될 수 있다.
  
- 배열의 메소드 

  - 배열을 문자로 반환 
    - toSri ng( ) 
    - join( )
  - 배열의 원소 정렬
    - sort ( )

      -sort메소드에 비교함수가(인자) 없으면 문자열을 기준으로 정렬한다.

      -비교함수가 있다면, 해당 함수의 리턴값이 0보다 크거나 작음으로 정렬한다.

    - reverse( )
  - 배열의 원소 조작 메소드
    - concat ( ):배열을 합쳐준다.
    - slice( ): 원본 배열 자체를 자른다. 자르는 것 뿐 아니라 원소의 수정, 삭제도 가능하다.
    - splice( ): 원본 배열 자체를 바꾸지는 않고 배열을 자른 값을 리턴해준다.
  - 배열의 원소 추가/제거 
    - 배열의 마지막에 추가/ 제거 : pop( ) / push( ) 
    - 배열의 첫 번째에 추가/ 제거 : unshift ( ) / shift( )



- 함수: 미리 정의 되어 프로그래밍 여러 부분에서 복수로 호출되어 실행

  - 전달인자, 매개변수(지역변수)를 함수에 전달 가능, 변수에는 지역변수와 전역변수가 있으며 변수의 유효 범위는 변수가 속해있는 함수 안에서만 유효하다.

  - JavaScript는 함수형 언어이고 JavaScript의 함수는 객체이다.

    - JavaScript의 객체는 생성자함수+프로토타입(메소드의 집합)이다.

    - JavaScript의 함수는 데이터 타입으로 변수에 할당할 수 있고 값으로 전달할 수 있다.



- 함수의 정의

  - 선언적 함수: 함수 정의 방법의 하나.

    - 함수 이름이 필요하지만 함수 이름이 필요 없는 함수도 존재한다.
    - 다수의 전달인자가 있을 경우 전달인자는 쉼표로 분리한다.
    - 리턴문(반환값): 함수 호출자에게 전달하는 값, 함수 실행 결과로 발생한다. 리턴문이 없을 시에는 undefined를 반환한다.

  - 함수의 선언 방법

    - 함수 선언문

      ```JavaScript
      fuction sum(a,b){
      	return a+b
      }
      sum(1,2)
      
      out
      3
      ```

    - 함수 표현식

      ```JavaScript
      var sum = fuction(a,b){
      	return a+b
      }
      sum(1,2)
      
      out
      3
      ```

    - 즉시 실행 함수

      ```JavaScript
      (fuction(a,b){return a+b})(1,2)
      
      out
      3
      ```

      

- 함수의 인자

  - 전달인자(매개변수)

    - 데이터 타입이 자유롭다. 다양한 데이터 타입을 전달인자로 사용 가능하다.

    - 개수에 대한 제한이 없다.

    - 전달인자를 덜 써도 에러가 발생하지 않으며 모자란 전달인자는 undefined처리 된다.

      ```JavaScript
      fuction a(전달인자1, 전달인자2){
          내용
      }
      a(A)
      /*위처럼 전달인자를 A만 써도 전달인자2는 undefined처리 된다.*/
      ```

    - argument 객체: 전달인자가 전달 되었는지와 데이터타입을 검사할 수 있다.

    - typeof 연산: 전달인자의 데이터 타입을 검사할 수 있다.

      -typeof 연산자로 null 값을 연산해 보면 null이 아닌 “object”를 반환한다.

      -따라서 null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하도록한다.

      -선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환한다.

  

- 화살표 함수(ES6)

  ```JavaScript
  var sum = fuction(a,b){
  	return a+b
  }
  sum(1,2)
  
  
  var sum = (a,b)(이 부분은 위에서 (a,b)에 해당)==>(화살표 부분은 fuction에 대해당)a+b(이 부분은 return a+b에 해당)
  sum(1,2)
  ```

  

   

---







# 문서객체모델(DOM)

- 자바스크립트가 가장 많이 사용되는부분은 웹개발이다.

  - 코어 자바스크립트: 웹 브라우저에서 자바스크립트가 작동하기위한 자바스크립트 부분을 제외하고 자바스크립트의 기본이 되는 부분만 정의한 자바스크립트

  - 클라이언트측 자바스크립트(DOM스크립트): 웹 브라우저에 관련된 자바스크립트

- DOM

  - 클라이언트 측 자바스크립트의 핵심
  - 문서 구조, 스타일, 내용 등을 변경할 수 있도록 돕고 구조화된 노드와 오브젝트로 문서를 표현한다.
  - 웹 브라우저와 웹 문서의 기능과 내용에 접근하여 정보를 얻을 수 있도록 모든 기능과 내용을 객체화하고 구조화하여 계층으로 구성된다.
  - 각각의 객체는 프로퍼티로 정보를 읽거나 설정 가능
  - 과거 웹 부라우적들은 비호환적인 DOM개발
    - 각각의 DOM버전을 레벨로 분류하고 대부분의 자바스크립트 프로그래머들은 자신의 프로그래밍 코드에 DOM레벨을 섞어서 사용하는데 이는 자바스크립트의 가장 큰 단점 중 하나이다.
    - 호환상의 문제로 자바스크립트 개발을 어지럽힘
    - 최근에 DOM은 정리되고 표준화됨

- 현재 웹 브라우저 윈도우: 웹 브라우저는 웹 문서를 보여주는 창이 DOM의 기준이다. 아래의 객체들에서 Window객체 이외의 객체는 Window객체의 프로퍼티로 접근한다.

  - Window 객체(전역객체): 최상위 객체, DOM문서를 표현하는 창

    - 다른 DOM객체에 접근할 수 있게 함

    - 현재 웹 브라우저 창에 대한 여러 가 지 정보 제공

    - 다양한 함수, 이름공간, 객체 등이 포함

    - 프로퍼티(Window객체의 프로퍼티는 일기 전용으로 변경은 불가능하다)

      -웹 브라우저 창의 크기(브라우저 창의 UI 포함): outerWidth와 outerHeight 프로퍼티

      -웹 브라우저 창의 크기(브라우저 창의 UI 미포함): innerWidth와 innerHeight 프로퍼티

      -창의 위치 정보:screenX,screenY

      -웹 브라우저 창 내부에서 스크롤 등의 조작이 얼마나 이동했는지 파악: pageXoffset, pageYoffset

  - window 프레임 객체 배열
  - Document객체 : 페이지 콘텐츠의 진입점 역할, \<body>등 다른 요소들을 포함

  - Navigator객체 
  - Location 객체
  - History 객체
  - Screen 객체 



- 팝업 윈도우의 생성
  - 광고 등으로 부정적인 인식이 강함, 팝업 윈도우를 차단하는 기능은 웹 브라우저의 기본 기능이 됨.
  - 그러나 필요한 경우가 존재한다.
  - 윈도우 생성 방법: Window 객체의 open 메소드 사용, 생성된 창을 닫는 것은 close를 사용



- alert: 윈도우 객체의 메소드로 경고상자를 생성, 경고 상자가 처리되기 전까지 웹 브라우저 내부에서 실행되던 모든 스크립트가 멈춤



- 웹 문서 접근(querySelector()와 querySelectorAll()만 기억하면 되며 나머지는 있다는 것만 알면 된다)

  - 특정한 기능을 추가하거나 움직임을 적용하기 위해서는 CSS와 같이 해당 요소에 접근하여야 한다. 셀렉터를 사용하는 CSS와 달리 자바스크립트 DOM은 웹 브라우저와 HTML 문서의 모든 기능과 요소에 접근함.

  - DOM 레벨0: 넷스케이프사의 네비게이터 웹 브라우저에서 사용,  Document 객체의 프로퍼티들로 문서 요소에 접근할 수 있게 해준다.

  - 문서 객체 배열로 접근(오래된 방법)

    - 프로퍼티들은 배열 값을 가지며 프로퍼티들은 다음과 같다.

      -document.anc hors[ ] :문서 내 앵커 객체 

      -document.applets[ ] :Java애플릿 

      -document.forms[ ]:폼 객체 

      -document.images[ ] :이미지 객체 

      -document.links [ ] :링크 객체

  - 이름 속성으로 접근(오래된 방법)

    - 서식의 입력 폼을 포함한 대부분의 요소들은 대부분 name 속성을 가질 수 있음
    - 이 name 속성을 통해 접근하느 방식

  - DOM 문서 트리(새로운 방법)

    - HTML 문서의 모든 요소에 접근할 수 있게 하기 위해 문서를 트리로 표현

    - 중첩된 요소들은 부자관계로 계층화됨

    - 각 노드에 접근하는 방법

      -getElementsByTagName(): Document 객체의 프로퍼티로 HTML 요소명(태그명)으로 노드에 접근, 프로퍼티가 반환하는 노드 객체가 하나 이상일 수 있기 때문에 배열로 반환함. 완전한 배열은 아니고 유사 배열을 반환

      -getElementByid(): 요쇼의 id속성 값으로 노드를 선택, HTML 문서에서 id 속성은 유일한 값을 가지므로 하나의 노드만 반환함.

      -getElementsByClassname(): 클레스 속성 값을 이용하여 노드 객체를 선택, 같은 값을 가지는 요소가 여럿 있을 수 있으므로 배열로 결과를 반환함, 완전한 배열은 아니고 유사 배열을 반환

      -getElementByTagName():name 속성 값으로 노드 객체에 접근할 수 있음, class 속성 대신 name 속성 값을 이용한다는 것을 제외하면 getElementByClassname()과 동일

      -querySelectorAll(): CSS셀렉터를 이용하여 노드를 선택함, querySelector()는 일치되는 첫 번째 노드만을 반환하지만 querySelectorAll()는 일치하는 모든 노드를 배열로 반환함

    - HTML Collection: 모두 live collection이며, 활용시 주의를 요함

      -변경이 일어날때 마다 값이 실시간으로 바뀐다.

      -getElementsByTagName(), getElementsByClassname()가 이에 해당

      -NodeList는 경우에 따라 live collection일 수 있다.

      

    - 주변 노드에 대한 탐색(있다는 것만 알면 된다)

      -childNodes[]: 노드 객체의 자식 노드 목록을 배열로 반환

      -firstChild,lastChild: 노드 객체의 첫 번째 자식 노드와 마지막 자식 노드를 반환

      -parentNode: 노드 객체의 부모 노드에 접근

      -nextSibling: 형제 계층 또는 이웃 계층으로 불리는 같은 계층의 바로 다음 노드에 접근

      -previousSiblin: 바로 앞 노드에 접근



- 웹 문서의 조작(innerHTML,insertAdjacnetHTML만 기억하면 된다.)

  - write: 문서 내에 콘텐츠를 추가하는 방법, 노드에 적용할 수 없음, 콘텐츠를 추가하고자 하는 HTML 문서의 특정 위치에 사용, 함수 내부에 사용하여 이벤트로 호출 시 기존 문서 전체를 지워버리고 콘텐츠를 출력한다는 점에 주의해야함

  - writeln: 줄바꿈을 표시한다는 것 외에는 write와 동일, 단 HTML에서는 줄바꿈을 무시하기 때문에 콘텐츠를 출력하기 전에는 write와 동일한 결과를 보인다.

  - 노드의 생성과 삽입

    - createElement(), createTextNode(): 요소와 텍스트노드의 생성

    - appendChild(): 특정 노드의 자식으로 노드를 삽입하기 위해 사용

    - appendChild(): 해당 요소를 제거

    - insertBefore(): 특정 요소 앞에 삽입하기 위해 사용

    - replaceChild(): 자식 노드 중 특정 노드를 새로운 노드로 치환하는 방법

    - innerHTML: HTMl5부터 표준으로 인정됨

      -createElement(), createTextNode(), appendChild()를 한꺼번에 처리하는 효과를 발휘한다.

      -XSS 공격에 취약점이 있으므로 사용시 주의

    - insertAdjacnetHTML

      -XSS 공격에 취약점이 있으므로 사용시 주의

  - 노드 속성 조작(스타일 조작): 생성한 노드의 class 또는 id 속성을 적용

    - getAtrribute(): 노드의 속성 값을 가져온다.
    - setAttribute(): 노드의 속성을 속성값으로 설장한다.

  - CSS의 변경: CSS 정의가 되어 있는 style 프로퍼티를 사용하면 접근한 노드의 CSS 속성을 직접 적용하거나 변경 가능

    - 주의사항: CSS속성을 표시할 때 하이픈은 모두 대문자 표기로 바꿔줘야 함.

      ex. font-size => fontSize







---







# 이벤트 

- 웹 브라우저에서 웹 문서이 특별한 일이 있을 때 발생하는 신호

  - 예를 들어 load, copy, mouseover,click,submit 등이 있다.

- 이벤트 핸들러: DOM 객체에 할당되어 해당 객체의 이벤트 반응에 호출되어 처리되는 프로퍼티

  - 이벤트 발생을 감시하고 이벤트를 감지하고 이벤트가 감지될 경우  지정된 자바스크립트 코드 또는 함수를 호출한다.

- 이벤트 모델: 이벤트 핸들러와 이벤트 API를 정의한 것

  - 웹브라우저와 시기별로 3가지 다른 이벤트 모델 존재
  - 기본 이벤트 모델
    - 기술적으로 부족함
    - DOM Level 0 이벤트 모델
    - 인터넷 익스플로러 버전 8이하와 호환 안됨
  - 표준 이벤트 모델
    - 기본 이벤트 모델을 개선하고 표준화함
    - DOM Level 2 이벤트 모델
    - 익스플로러 버전 9이상과 다른 웹브라우저에서 지원
    - 표준 이벤트 모델 사용을 강력히 권장
  - 익스플로러 이벤트 모델(현재 사용X)
    - 익스플로러 버전 8까지의 독자적인 이벤트 모델
    - 다른 웹 브라우저에서 지원X

  

- 기본 이벤트 모델

  - HTML5에서는 수십개의 이벤트 핸들러가 추가로 정의됨

  - 마우스 관련 이벤트 핸들러

    - onclick: 마우스 클릭을 감지
    - onmousedown: 마우스 단추가 눌렸는지 감지 
    - onmuseup: 눌려졌던 마우스 단추가 올려졌는지 감지 
    - onmuseover: 마우스 커서가 특정 객체 위에 올라갔는지 감지 
    - onmuseout:마우스 커서가 특정 객체에서 벗어났는지 감지 
    - onmusemove: 마우스 커서의 이동을 감지

  - 로딩 관련 이벤트 헨들러

    - onload: 이미지 또는 화면 로딩이 완료되었는지를 감지
    - onunload: 현재 화면에서 벗어날 때를 감지

  - 서식 관련 이벤트 헨들러

    - onsubmit/onreset: 서식이 전송/재전송 될 때를 감지
    - infocus/onblur: 특정 서식 요소에 마우스 커서나 텍스트 커서가 접근함/벗어남 감지

  - 키보드 관련 이벤트 헨들러

    - onkeydown: 키보드가 눌렸는지 감지
    - onkeypress: 키보드가 눌려지고 있는지 감지
    - onkeyup: 눌려진 키보드가 올려졌는지 감지

  - 이벤트 기본 기능 막기

    - 기본 기능: 링크를 클릭하면 페이지가 이동, 이미지 클릭시 이미지 선택 등의 기본 기능들

    - return문을 통해 막을 수 있다. return 값을 참으로 주면 기본 기능이 수행되고 거짓을 주면 수행되지 않는다. 쓰지 않을 경우 기본값으로 참을 가진다.

  - 이벤트 핸들러 사용 방법

    - 특정 객체에 이벤트 핸들러 지정 -> 객체에 이벤트 발생 -> 이벤트 핸들러 감지 -> 정의한 작동 실행

    - 이벤트 핸들러 지정 방법

    - HTML 요소에 직접 지정(권장X): DOM 객체에 직접 속성 형태로 이벤트 핸들러 적용

    - JavaScript에 이벤트 핸들러 적용(권장)

      - 문서 구조는 HTML, 디자인은 CSS, 작성은 Javascript에서 하는 것이 권장된다.

    - 자바스크립트를 통한 이벤트 할당

      - 이벤트 적용 방법

        -이벤트 핸들러 DOM 객체의 프로퍼티로 입력

        -자바스크립트 이벤트 할당

    - 이벤트 인터페이스(이벤트 API)

      -호출함수는 이벤트 객체를 인자로 받음

      -전달받은 이벤트 객체는 이벤트 API를 이용하여 각종 이벤트 정보를 구함



- 표준 이벤트 모델

  - addEventListener: DOM 객체에 이벤트 핸들러 함수를 적용하게 해줌, 3개의 전달 인자를 받는다.

    ```javascript
    addEventListener(type, listener,useCapture);
    type: 이벤트 유형
    listener: 이벤트가 발생했을 때 실행할 콜백 함수(핸들러)
    useCapture: 어떤 노드로 전파할지 결정
    ```

    

  - removeEventListsner: 이벤트 핸들러 제거

  - this와 target: target 사용이 권장된다.

  - 기본 이벤트 기능을 막는 방법

    - preventDefault(): 이벤트 API를 이용하여 이벤트 기본 기능 작동을 막는다.

  - 이벤트 인터페이스

    - 이벤트 핸들러가 함수를 호출하면 이벤트 객체가 인자로 전달된다. 
    - Type: 발생한 이벤트의 타입을 알아냄
    - Target: 이벤트가 발생한 DOM 객체를 의미
    - timestamp: 이벤트 발생 시간을 밀리초로 알려줌
    - 이벤트 전파에 관련된 이벤트 API
    - 이벤트가 발생한 좌표를 알려주는 이벤트 API
    - 특정 키가 눌렸는지 알려주는 이벤트 API
    - Button 이벤트 API: 어떤 마우스 단추가 눌렸는지 알려줌



- 이벤트 전파: 발생한 이벤트는 상위 노드로 전파된다.

  - - 이벤트 전파의 3단계
      - 1단계: document에서 이벤트 발생 노드까지 내려가면서 이벤트 전파(캡처링)
      - 2단계: 이벤트 발생 노드 그 자체
      - 3단계: 이벤트 발생 노드에서 document 노드까지 올라가면서 이벤트 전파(버블링)
      - 최종적으로 등록된 이벤트 핸들러 작동
  - addEventListener의 3번째 전달 인자가 이벤트 전파 관련 인자이며 false또는 true값을 갖는다.
    - 기본값은 false다.
    - true일 경우(하위 노드로 전파): 이벤트 전파 전 과정에서 이벤트 호출 감지(이와 같은 이벤트 호출을 감지하는 것을 이벤트 캡쳐링 혹은 캐스케이드 다운이라 부른다)
    - false일 경우(상위 노드로 전파): 두 번째와 세 번째 과정 이벤트 대상 객체부터 document까지 가는 과정에서 이벤트 호출 감지(이러한 이벤트 호출을 감지하는 것을 이벤트 버블링 또는 버블 업이라고 부른다).
    - 기본 구조는 항상 캡처링부터 시작하여 버블링으로 종료되는 것이다. 이를 useCapture를 통해 변경시킬 수 있다.
  - 이벤트 전파 방지
    - stopPropagation: 이벤트 전파를 막는 이벤트 API 
  - 이벤트 전파와 관련된 이벤트 API
    - curntTarget: 전파된 이벤트가 도착한 객체
    - eventPhase: 세 단계의 이벤트 전파 과정 중 현 단계가 몇 단계인지 알려줌
    - timeStamp: 이벤트 발생 시간을 밀리초 단위로 알려줌

  

- 이벤트 객체: 이벤트에 지정된 함수(핸들러)는 이벤트 객체를 매개변수로 받을 수 있음

  - 이벤트 객체에는 대표적으로 아래와 같은 속성과 메소드들이 있다(이정도만 기억하면 된다).
    - Event.target: 이벤트가 원래 발생하였던 대상 
    - Event.currentTarget: 이벤트가 발생하였던 대상
    - Event.preventDefault():이벤트를 취소
    - Event.stopPropagation(): 이벤트 전파 중단

  

  



---









# 함수의 고급 기능

- 자바스크립트 함수의 특징(일급 객체의 조건)

  - 함수를 인자로 전달 가능하다

  - 함수를 반환할 수 있다
  
  - 변수에 함수를 할당 가능하다.

    

- 자바스크립트 함수는 객체이면서 데이터이다.

  - 객체이기 때문에 생성자를 이용하여 함수 정의 가능

    - 생성자를 이용한 함수 정의는 함수를 동적으로 생성한다.
    - 함수호출 될 때마다 함수가 생성되고 처리된 후 사라진다.
    - 따라서 반복문에서 사용될 경우 매번 함수를 동적으로 생성하기에 반복문에서는 사용을 피해야 한다.

  - 함수의 생성자는 fuction

  - new fuction으로 선언하면 안된다.

    ```
    var 변수 = new fuction()
    ```

- 익명 함수(함수 표현식)

  - 생성자를 이용하여 함수를 정의하면 함수가 이름 없이 생성되는데 이 때문에 익명 함수라 부른다.
  - 익명함수는 생성되어 변수에 할당되는데 이 변수가 함수의 이름의 역할을 한다.
  - 함수를 변수에 할당하는 방식은 익명함수인 생성자를 이용한 함수정의와 동일하다
  - 자바스크립트의 함수 이름은 함수 객체를 가리키는 참조일 뿐이기에 자바스크립트의 익명함수 사용은 자연스러운 것이다.
  - 익명함수 정의는 일반적으로 생성자를 이용한 함수 정의와 함수 리터럴에서 사용됨



- 함수 호이스팅
  - 자바스크립트에서는 모든 선언이 호이스팅 되므로 함수도 호이스팅이 된다.
    - 익명함수(함수 표현식)는 변수 호이스팅이 발생하여 실행 불가
    - 함수 선언문은 선언, 초기화, 할당이 모두 이루어져 실행 가능
  - 따라서 호이스팅을 방지하기 위해서는 익명함수에 이름을 붙이는 방식으로 함수를 생성하는 것이 권장됨



- 함수 리터럴
  - 리터럴 형태로 함수 정의 가능하다.  즉, 함수도 리터럴 표현이 가능하다. 따라서 생성자 없이 함수를 생성하여 변수에 할당 가능하다.
  - 함수 객체는 메소드와 프로퍼티를 적용할 수 있다.



- 배열 테스트 함수(call-back함수)
  - 콜 백 함수: 메소드 실행 시 자동으로 호출되는 함수
  - 배열을 검사하는 메소드의 콜 백 함수 혹은 Array helper methods
    - filter: 원하는 요소 정리(콜 백 함수 사용)하여 새로운 배열 반환
    - forEach: 배열의 엘리먼트 하나하나 조작 시 사용, 엘리먼트 하나하나 콜 백 함수에 전달하여 처리
    - every: 모든 배열 요소 콜 백 함수에서 제시하는 요소 통과 시 true, 실패시 false 반환
    - map: 배열 요소 하나 하나에 콜 백 함수 처리 후 새로운 배열 반환
    - some: every와 논리적으로 반대되는 경우, 콜 백 함수 요구하는 엘리먼트 한 개라도 존재하면 true, 아니면 false

  

- 재귀함수
  
  - 함수 내부에서 자신을 다시 호출하는 함수



- 함수의 유효 범위
  - 자바스크립트는 함수형 언어이기 때문에 함수를 기준으로 유효범위가 결정된다.
  - 함수 내부에서 선언된 변수는 함수 내부에서만 유효하다.
  - 함수를 포함하는 부모함수에서 선언된 변수는 자식 함수에서 사용 가능하며 전역변수는 함수 외부에서 사용 가능하다.
  - 어휘적 유효범위: 함수가 실행될 때 환경을 유효 범위에 포함하지만 함수가 정의 될 당시의 환경도 유효 범위에 포함된다는 의미. 함수가 정의 될 때 유효 범위도 생성됨



- 클로저(Closure): 코드와 유효범위를 포함하여 클로저라 부른다. 또는 함수와 함수가 선언된 어휘적 환경의 조합이라고 정의할 수 있다.
  - 모든 자바스크립트 함수는 클로저이지만 함수가 클로저로 인식되는 경우는 중첩함수에서 내부 함수가 외부로 전달되고 실행될때이다. 따라서 외부로 전달되고 실행 되는 함수를 클로저라고 부르기도 한다.
  - 종료된 함수 내부 변수를 참조할 수 있게 한다.
  - 호출함수의 지역변수에 접근 가능, 변수값을 복사해 가져오는 것이 아니라 변수참조하여 접근함



- 함수의 메소드
  - 함수에 전달인자 적용하는 메소드 : apply, call
    - apply: 전달인자를 적용하여 함수 실행
    - call: 전달인자를 나열, 전달인자 한 개일 때 사용



- 커링(curring) - 당장은 몰라도 된다.
  - 두 개 이상의 미지수 있는 수식: 미지수 하나씩 적용하며 결과 도출
  - 위와 같은 처리를 커링이라 부르며 커링은 함수가 객체이면서 데이터이고 동적이어야 가능한데 자바스크립트 함수가 이 조건에 부합하므로 자바스크립트에서 사용된다.
  - 가장 중요한 원리는 클로저이다.







---





# 객체의 이해와 생성

- 객체 : 이름이 지정된 property의 모음

  - 따라서 객체 리터럴은 객체의 프로퍼트를 나열하여 객체를 생성한다.

  - 객체의 프로퍼티의 추가와 수정이 가능하다.

  - 프로퍼티의 추가가 쉽기 때문에 빈 객체를 만들어 사용하기도 한다.

  - Namespace:  자신이 작성할 코드에 사용되는 변수, 함수, 객체 등을 하나의 객체 프로퍼티로 설정하는 방법이다.

    - 자바스크립트는 함수 내부에서 변수를 선언하지 않으면 모두 전역변수로 취급하므로 프로그램 오류가 잦다. 전역 변수 사용을 최소화하여 오류를 줄여주는 방법이 Namespace이다.
    - 일반적으로 Namespace로 정의할 때에는 객체 이름을 대문자로 명명한다.

  - 객체의 프로퍼티가 함수인 프로퍼티를 메소드라 부른다. 

  - 메소드도 프로퍼티의 일종이므로 프로퍼티와 동일한 방법으로 추가와 수정이 가능하다.

  - 객체 리터럴 방식으로 메소드를 정의할 수 있다.

    

- 

- 함수도 객체에 포함된다.

  

- 일급객체

  - 자바스크립트의 함수는 일급객체이다
  - 일급 객체는 아래와 같은 의미를 지니고 있다.
    - 변수나 데이터 구조안에 담을 수 있고
    - 인자로 전달하거나 반환 값으로 사용할 수 있으며
    - 동적으로 생성 가능한 객체

- 자바스크립트객체는 class가 존재하지 않는다. 생성자 함수, 프로토타입 객체를 사용하여 객체를 생성한다.



- 생성자 함수와 prototype

  - 생성자 함수: 생성할 객체에 있는 프로퍼티와 그 프로퍼티는 어떻게 초기화 될 것인지 정의해 놓은 함수
    - 객체지향 프로그래밍 언어의 class와 유사하여 class또는 모조class라고 부른다.
  - 모든 함수에는 prototype이라는 property가 있다.
    - 함수를 정의할 때 자동으로 생성되는 프로퍼티이며 하나의 constructor property를 가진다.
  - 일반적인 함수에서 함수 내부에 있는 변수나 함수는 객체의 프로퍼티나 메소드가 아니다.
    - 따라서 호출 객체는 window 객체가 유일하다. 따라서 함수의 결과는 global이다.

  - 함수 내부에 변수와 메소드를 정의 할 때 this를 사용한 함수가 new 연산자와 함께 사용되면 함수를 통해 객체를 생성할 수 있음
  - property 가리기
    - 생성된 객체의 프로퍼티를 읽으려 할 때 자바스크립트는 먼저 객체 자신의 프로퍼티를 검사한다.
    - 객체 자신의 프로퍼티에 읽으려고 하는 프로퍼티가 없을 시 프로퍼티 객체에 읽으려는 프로퍼티가 있는지 검사한다.
    - 객체 프로퍼티가 프로토타입 객체의 프로퍼티를 가리는 상황이 생긴다.
    - 

- 생성자 함수를 이용한 객체 생성
  - 객체 생성 방법: new 연산자, 생성자를 이용
  - new연산자를 이용한 객체 생성(사용하지 않는다)
    - 새로운 빈 객체 생성 -> 생성자 함수 호출
  - 생성자를 이용한 객체 생성
    - 객체지향 프로그래밍 언어의 class를 이용한 객체 설정과 유사
    - new연산자를 통해 새로운 객체를 만들고 생성자 함수를 호출해 초기화한다.



- instance property
  - class로 생성된 객체들은 class의 instance 객체로 부르며 그 객체의 property들은 instance property가 된다.
  - instance 객체는 class라는 객체 명세서로 작성된 객체로 각각의 객체는 독립된 property들을 가진다.



- instance method: 생성사 함수의 프로토타입 객체 프로퍼티에 할당된 함수 리터럴을 instance매소드라 할 수 있다.
  - instance class와 비슷하다. instance 객체의 method를 의미한다.
  - instance property와 다른 점은 객체 생성시 사본이 아니라 참조가 전달된다는 것이다.



- class property와 class method
  - 자바스크립트에는 class가 존재하지 않는다. 따라서 class property를 자바스크립트에 구현하기 위해 class property와 비슷하게 사용하는 프로퍼티가 존재한다.
  - 같은 이유로 class method도 필요하다.



- 비공개 property: 객체 내부의 메서드만 접근이 가능하고 외부 코드에서는 조작할 수 없는 property를 의미함
  - 자바스크립트는 이에 대한 별도의 문법이 없다. 즉, 모든 프로퍼티와 메소드가 공개되고 수정이 가능하다.
    - 이는 자바스크립트로 개발할 때 큰 문제가 될 수 있다.
  - 그러나 자바스크립트에는 비공개 멤버가 존재한다.
    - 지역변수와 클로저를 통해 이를 구현 가능하다.
    - setPrivate 특권 method를 작성하여 비공개 property를 수정할 수 있게 만들 수 있다.
    - 이 순간 프로퍼티는 더 이상 비공개 프로퍼티가 아니게 된다.



- 모든 객체가 공통으로 가지는 메소드가 존재한다.
  - toString(),valueOf()등이 그것이다.
  - 공통객체 메서드가 존재하는 이유는 모든 객체가 생성될 때 Object Class의 method를 상속 받기 때문임
  - 공통객체 메서드는 기대하는 결과를 반환하지 못 할 수도 있는데 공통 객체 메서드를 재 작성하면 된다.





---





# 상속

- 상속: 특정 객체의 프로퍼티와 메소드를 가져와 새로운 객체에 사용
- 상속 사용의 특징
  - 코드 양 축소
  - 구조적인 코드 작성 가능
  - 객체지향 언어에서 제공

- class가 존재하는 언어는 class를 상속하여 상속을 구현한다.

- 자바스크립트에는 class가 존재하지 않으므로 상속에 관한 문법을 제공하지는 않지만 구현이 가능하다. 



- class 상속

  - class가 존재하지 않는 대신 생성자 함수,  프로토타입 객체를 사용하여 class와 같은 객체 생성

    - superclass: 상속해 주는 부모 클래스
    - subclass: 상속을 받는 자식 클래스

  - 프로토 타입 지정으로 상속 구현하기

    - superclass는 프로퍼티와 메소드를 상속, subclass는 상속 받은 프로퍼티와 메소드를 프로토 타입으로 설정

      

  - apply와 call 메소드

    - 함수에 적용하는 메소드로 자바스크립트의 함수는 객체이기 때문에 메소드 적용이 가능하고 apply와 call 메소드 이용이 가능하다.
    - 첫 번째 인자를 null로 받으며 함수를 특정 객체의 메소드로 실행하기 위해 사용한다.

  - superclass의 생성자 이용하기

    - superclass의 생성자 함수를 subclass의 메소드로 실행
    - 이 경우 superclass의 생성자에 정의되어 있는 프로퍼티와 메소드만 상속 가능하고 프로토타입을 상속받지 못한다.

  - 프로토 타입 지정과 superclass의 생성자 이용 하는 방식을 함께 사용하여 상속을 구현하면 각 방식의 단점을 보완할 수 있다.

    - 이 방식에도 단점이 존재하는데 superclass의 생성자 함수에 정의된 프로퍼티와 메소드가 프로토타입 지정 시 한번 더 생성된다.

    - 생성자 함수와 프로토타입에 같은 프로퍼티가 들어있는 것 해결 방법

      -프로토타입에 들어 있는 생성자 함수의 프로퍼티 삭제(효율적인 방법은 아님)

      -subclass의 프로토타입을 superclass의 인스턴스 객체가 아닌 superclass의 프로토타입으로 지정(권장되는 방법)

  - subclass의 프로토타입을 superclass의 프로토타입으로 지정하는 방식의 문제

    - 프로토타입은 객체이기에 subclass의 프로토타입과 superclass의 프로토타입은 참조로 연결되고 sub의 프로토타입 변경시 supper의 프로토타입도 변경 된다.

    - 이를 방지하기 위해서는 객체를 복사해 할당해야 한다.

    - 객체 복사 방법

      -빈 생성자 함수 생성

      -빈 생성자 함수의 프로퍼티 복사하고자 하는 객체에 할당

      -변수에 new연산자와 생성자를 사용하여 새로운 객체 생성

  - constructor 프로퍼티 설정

    - constructor : 객체의 생성자
    - constructor 프로퍼티: 생성자 함수로 객체 생성 시, 생성자 함수의 프로토타입에 생성
    - 자바스크립트의 상속은 sub의 생성자 함수 프로토타입을 sup의 프로토타입으로 만든다. 따라서 프로토타입의 constructor 프로퍼티도 sup의 프로퍼티로 바뀐다.

    

- 객체 리터럴 상속하기

  - 자바스크립트의 객체는 이름이 있는 값들의 집합이고 class는 객체 생성을 위한 명세서일 뿐이다. 따라서 자바스크립트는 객체 리터럴 방식으로도 객체를 생성 가능

  - 필요한 메소드만 가져올 수도 있고 여러 객체의 모든 프로퍼티를 한 객체로 가져와야 하는 경우도 있다.

    - mixin: 다수의 부모 객체를 순환하여 모든 프로퍼티나 메소드를 빌려와 하나의 객체로 만들어 반환.

      -메소드를 가져와야 한다면 생성자 함수의 프로토타입에서 가져와야 하고

      -프로퍼티를 가져와야 한다면 객체에서 프로퍼티를 가져와야 한다.





---







# 자바스크립트 library

- 자바스크립트의 단순함과 유연함은 다양한 기능을 구현하게 해주지만 호환성에 문제가 생길 수 있고 그 활용에 대한 이해가 어려울 수 있다.

  - 이는 자바스크립트 라이브러리를 활용함으로써 해결할 수 있다.

- 자바스크립트 라이브러리: 자바스크립트 코드 덩어리, 사용자가 자신의 코드에 추가하여 지원하는 다양한 기능 사용 가능

  - 웹 브라우저 호환을 걱정할 필요 없는 다양한 기능을 제공

- 자바스크립트로 작성하는 웹 어플리케이션의 장점

  - plug-in 필요 없음

  - 웹 표준에 맞추어 작성 가능

    

- 다양한 기능을 제공하는 자바스크립트 라이브러리

  - 기능

    - 자바스크립트 프로그래밍 쉽고 빠르게 작성할 수 있게 해준다
    - 프레임워크로서의 기능

  - 종류

    - prototype.js: 다양한 유틸리티 함수 제공, 코드 작성의 부담 덜어줌, 기존 객체의 기능 확장, Ajax 객체 추가로 호환성 증가, 객체 class와 상속을 객체지향 프로그래밍과 비슷하게 구현

    - YUI: 야후에서 배포, js에서 추가되어야 할 대부분의 기능을 구현

    - dojo: js의 부족한 부분을 채워주는 라이브러리, 그래픽과 애니메이션 쉽게 구현 가능, UI작성시  주로 사용된다.

    - jQuery: 코딩을 쉽고 편하게 하기 위한 메소드 제공

      

- 특화된 기능을 제공하는 자바스크립트 라이브러리

  - HTML5의 비디오 기능 쉽게 접근
  - 그래픽과 애니메이션 기능 향상
  - 오디오 컨트롤 가능
  - 게임 제작 시 필요한 기능을 제공
  - MVC 프로그래밍 가능하도록 제공
  - 종류
    - video.js: 다양한 비디오 플레이어 UI제공, 모든 동영상 컨트롤 가능
    - sound Manager 2: 오디오 컨트롤
    - paper.js: Canvas 위에 작동하는 백터 그래픽 스크립느 라이브러리
    - 라파헬: 웹에서 벡터 그래픽을 쉽게 스크립팅 가는 Canvas가 아닌 SVG사용 
    - D3: 데이터를 시각적으로 표현 SVG 사용하여 벡터 그레픽 구현
    - Box2D.js: 물리엔진, 게임 등에 사용하는 중력과 충돌 구현
    - Collie: 게임과 에니메이션을 위한 라이브러리



- jQuery:
  - DOM객체에 빠르게 접근하고 조작이 가능하다.
    - CSS 선택자를 포함하는 강력한 선택자와 요소 속성 조작 방법
    - 브라우저를 고려하지 않아도 되는 쉽고 강력한 이벤트 모델
    - 쉽게 구현할 수 있는 에니메이션 효과
  - 메소드 체이닝: 메소드를 연속해서 붙여 코드를 작성하여 한 줄로 코딩
  - Ajax를 간단하게 구현 가능
  - jQuery Plug-in: Plug-in 방식을 도입하여 jQuery의 사용 방법을 유지하며 기능 확장



- 기본 CSS선택자를 이용한 요소 선택
  -  jQuery 선택자
    -  jQuery는 HTML요스를 빠르고 쉽게 선택할 수 있는 기능을 제공한다.
  -  jQuery함수는 DOM요소를 선택하는 다양한 방법이 있는데 그 중 CSS 선택자를 그대로 사용하는 방법이 가장 효율적이다. 
  - jQuery 함수의 기본 사용 법
    - 요소 태그명,  id속성, class속성, CSS 선택자의 혼합 등



- CSS3 선택자를 이용한 요소 선택
  - CSS3는 더욱 다양한 선택자를 제공



- jQuery 선택된 요소의 정보 얻기
  - 선택된 요소: 배열과 비슷한 객체다.



- jQuery 속성의 조작
  - attr()메소드
    - 선택된 요소의 속성 읽어 옴
    - 선택된 요소의 속성 설정
  - addClass()/removeClass(): 요소들의 특정 Class 속성 적용/삭제
  - css()메소드: CSS스타일 설정
  - hmtl()메소드: 특정 요소의 HTML 코드 읽음, 특정 요소의 HTML 코드 대치



- 콘텐츠 조작
  - text()메소드: 텍스트 콘텐츠 읽거나 대치
  - append(): 기존 코드 뒤에 추가
  - appendTo(): 선택된 타겟 요소의 끝으로 이동



- jQuery이벤트
  - bind()메소드: jQuery의 이벤트 적용 메소드
  - unbind()메소드: 이벤트 핸들러 제거
  - 체인 연결: 두 개의 bind메소드, 하나의 선택그룹에 체인으로 연결





