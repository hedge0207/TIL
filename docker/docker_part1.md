# 컨테이너와 Docker

## 개요

- 컨테이너
  - 호스트 OS상에 논리적인 구획(컨테이너)을 만들고, 애플리케이션을 작동시키기 위해 필요한 라이브러리나 애플리케이션 등을 하나로 모아, 별도의 서버인 것처럼 사용할 수 있께 만든 것.
  - 호스트 OS의 리소스를 논리적으로 분리시키고, 여러 개의 컨테이너가 공유하여 사용한다.
    - 보통 물리 서버 상에 설치한 호스트 OS의 경우 하나의 OS 상에서 움직이는 여러 애플리케이션은 똑같은 시스템 리소스를 사용한다.
    - 이때 작동하는 여러 애플리케이션은 데이터를 저장하는 디렉토리를 공유하고, 서버에 설정된 동일한 IP 주소로 통신을 한다.
    - 따라서 여러 애플리케이션에서 사용하고 있는 미들웨어나 라이브러리의 버전이 다른 경우에는 각 애플리케이션이 서로 영향을 받지 않도록 주의해야 한다.
    - 이에 반해 컨테이너 기술을 사용하면 OS나 디렉토리, IP 주소 등과 같은 시스템 자원을 마치 각 애플리케이션이 점유하고 있는 것처럼 보이게 할 수 있다.
  - 컨테이너는 오버헤드가 적기 때문에 가볍고 고속으로 작동하는 것이 특징이다.



- Docker 개요
  - 애플리케이션의 실행에 필요한 환경을 하나의 이미지로 모아두고, 그 이미지를 사용하여 다양한 환경에서 애플리케이션 실행 환경을 구축 및 운용하기 위한 플랫폼이다.
    - 내부에서 컨테이너 기술을 사용한다.
    - 오픈 소스다.
  - Docker를 사용하는 이유
    - 개발을 하다 보면 개발 환경, 테스트 환경에서는 정상적으로 동작하는데, 스테이징 환경(제품 환경에 배포하기 직전에 확인하는 테스트 환경), 제품 환경에서는 동작하지 않는 경우가 존재한다.
    - 위와 같은 현상의 원인에는 여러 가지가 있지만, 그 중 대표적인 것이 각 환경별로 인프라가 다르기 때문이다.
    - 도커는 애플리케이션 실행에 필요한 모든 인프라를 컨테이너로 모아 각 환경에서 해당 컨테이너를 사용함으로써 인프라가 달라서 발생하는 문제를 방지하는 데 목적이 있다.



- Docker의 기능
  - Docker 이미지
    - 애플리케이션의 실행에 필요한 파일들이 저장된 디렉토리.
    - 실행 환경에서 움직이는 컨테이너의 바탕이 된다.
    - Docker에서는 하나의 이미지에는 하나의 애플리케이션만 넣어 두고, 여러 개의 컨테이너를 조합하여 서비스를 구축하는 방법을 권장하고 있다.
    - Docker 이미지는 겹쳐서 사용이 가능하다. 예를 들어 OS용 이미지에 웹 애플리케이션용 이미지를 겹쳐서 다른 새로운 이미지를 만들 수 있다.
  - 이미지를 만드는 기능(Build)
    - 애플리케이션의 실행에 필요한 라이브러리, 미들웨어, OS나 네트워크 설정 등을 하나로 모아서 Docker 이미지를 만든다.
    - Docker 이미지는 실행 환경에서 움직이는 컨테이너의 바탕이 된다.
    - Docker의 이미지는 Docker의 명령을 사용하여 수동으로 만들 수도 있으며, Dockerfile이라는 설정 파일을 만들어 그것을 바탕으로 자동으로 이미지를 만들 수도 있다.
    - 지속적인 인티그레이션과 지속적 딜리버리의 관점에서 코드에 의한 인프라의 구성 관리를 생가갛면 Dockerfile을 사용하여 관리하는 것이 바람직하다.
  - Docker 이미지를 공유하는 기능(Ship)
    - Docker 이미지는 Docker 레지스트리에서 공유가 가능하다.
    - Docker의 공식 레지시트리인 Docker Hub에서는 다양한 베이스 이미지들이 존재한다.
    - Docker Hub는 github이나 bitbucket과 연계하여 사용하는 것이 가능하다.
    - 예를 들어 깃헙 상에서 Dockerfile을 관리하고, 거기서 Docker 이미지를 자동으로 생성하여 Docker Hub에서 공개하는 것도 가능(Automated Build)하다.
  - Docker 컨테이너를 작동시키는 기능
    - Docker는 Linux 상에서 컨테이너 단위로 서버 기능을 작동시킨다.
    - 이 컨테이너의 바탕이 되는 것이 Docker 이미지로, Docker 이미지만 있으면 Docker가 설치된 환경이라면 어디서든 컨테이너를 작동시킬 수 있다.
    - Docker 이미지를 가지고 여러 개의 컨테이너를 가동시킬 수도 있다.



- Docker 컴포넌트
  - Docker는 아래와 같은 컴포넌트로 구성되어 있다.
    - 핵심 기능이 되는 Docker engine을 중심으로 컴포넌트를 조합하여 애플리케이션 실행 환경을 구축한다.
  - Docker Engine(Docker의 핵심 기능)
    - Docker 이미지를 생성하고 컨테이너를 기동시키기 위한 Docker의 핵심 기능.
    - Docker 명령의 실행이나 Dockerfile에 의한 이미지도 생성한다.
  - Docker Registry(이미지 공개 및 공유)
    - 컨테이너의 바탕이 되는 Docker 이미지를 공개 및 공유하기 위한 레지스트리 기능.
    - Docker의 공식 레지스트리 서비스인 Docker Hub도 이 Docker Registry를 사용하고 있다.
  - Docker Compose(컨테이너 일원 관리)
    - 여러 개의 컨테이너 구성 정보를 코드로 정의하고, 명령을 실행함으로써 애플리케이션의 실행 환경을 구성하는 컨테이너들을 일원 관리하기 위한 툴.
  - Docker Machine(Docker 실행 환경 구축)
    - 로컬 호스트용인 VirtualBox를 비롯하여 AWS EC2나 Azure와 같은 클라우드 환경에 Docker의 실행 환경을 명령으로 자동 생성하기 위한 툴이다.
  - Docker Swarm(클러스터 관리)
    - 여러 Docker 호스트를 클러스터화하기 위한 툴이다.
    - Docker Swarm에서는 클러스터를 관리하거나 API를 제공하는 역할은 Manager가, Docker 컨테이너를 실행하는 역할은 Node가 담당한다.
    - 오픈소스인 Kubernetes도 사용 가능하다.



## Docker의 작동 구조

- Docker는 리눅스 커널의 기술이 베이스로 되어 있다.



- 컨테이너를 구획화하는 장치(namespace)
  - 컨테이너라는 독립된 환경을 만들고, 그 컨테이너를 구획화하여 애플리케이션의 실행 환경을 만든다.
  - 컨테이너를 구획화하는 기술은 리눅스 커널의 namespace라는 기능을 사용한다.
    - namespace란 한 덩어리의 데이터에 이름을 붙여 분할함으로써 충돌 가능성을 줄이고, 쉽게 참조할 수 있게 하는 개념이다.
    - 이름과 연결된 실체는 그 이름이 어떤 namespace에 속해 있는지 고유하게 정해진다.
    - 따라서 namespace가 다르면 동일한 이름이라도 다른 실체로 처리된다.
  - 리눅스 커널의 namespace 기능은 리눅스의 오브젝트에 이름을 붙임으로써 다음과 같은 6개의 독립된 환경을 구축할 수 있다.
    - PID namespace: PID란 리눅스에서 각 프로세스에 할당된 고유한 ID를 말한다. PID namespace는 PID와 프로세스를 격리시키며, namespace가 다른 프로세스끼리는 서로 엑세스 할 수 없다.
    - Network namespace: 네트워크 디바이스, IP 주소, 포트 번호, 라우팅 테이블, 필터링 테이블 등과 같은 네트워크 리소스를 격리된 namespace마다 독립적으로 가질 수 있다. 이 기능을 사용하면 호스트 OS 상에서 사용 중인 포트가 있더라도 컨테이너 안에서 동일한 번호의 포트를 사용할 수 있다.
    - UID namespace: UID(사용자 ID), GID(그룹 ID)를 namespace별로 독립적으로 가질 수 있다. namespace 안과 호스트 OS 상의 UID,GID가 서로 연결되어 namespace 안과 밖에서 서로 다른 UID,GID를 가질 수 있다.
    - MOUNT namespace: 리눅스에서 파일 시스템을 사용하기 위해서는 마운트가 필요하다. 마운트란 컴퓨터에 연결 된 기기나 기억 장치를 OS에 인식시켜 이용 가능한 상태로 만드는 것을 말한다. MOUNT namespace는 마운트 조작을 하면 namespace 안에 격리된 파일 시스템 트리를 만든다.
    - UTS namespace: namespace별로 호스트명이나 도메인명을 독자적으로 가질 수 있다.
    - IPC namespace:  프로세스 간의 통신(IPC) 오브젝트를 namespace별로 독립적으로 가질 수 있다.



- 릴리스 관리 장치(cgroups)

  - Docker에서는 물리 머신 상의 자원을 여러 컨테이너가 공유하여 작동한다.

    - 이 때 리눅스 커널의 기능인 control groups 기능을 사용하여 자원의 할당 등을 관리한다.

  - 리눅스에서는 프로그램을 프로세스로서 실행한다.

    - 프로세스는 하나 이상의 스레드 모음으로 움직인다.
    - cgroups는 프로세스와 스레드를 그룹화하여, 그 그룹 안에 존재하는 프로세스와 스레드에 대한 관리를 수행하기 위한 기능이다.
    - 컨테이너 안의 프로세스에 대해 자원을 제한함으로써 특정 컨테이너가 호스트 OS의 자원을 모두 사용해 버려서 동일한 호스트 OS 상에서 가동되는 다른 컨테이너에 영향을 주는 일을 막을 수 있다.

  - cgroups으로 관리할 수 있는 사항들

    | 항목    | 설명                             |
    | ------- | -------------------------------- |
    | cpu     | CPU 사용량 제한                  |
    | cpuacct | CPU 사용량 통계 정보 제공        |
    | cpuset  | CPU나 메모리 배치 제어           |
    | memory  | 메모리나 스왑 사용량 제한        |
    | devices | 디바이스에 대한 액세스 허가/거부 |
    | freezer | 그룹에 속한 프로세스 정지/재개   |
    | net_cls | 네트워크 제어 태그를 부가        |
    | blkio   | 블록 디바이스 입출력량 제어      |

  - cgroups는 계층 구조를 사용하여 프로세스를 그룹화형 관리할 수 있다.



- 네트워크 구성(가상 브리지/가상 NIC)
  - 리눅스는 도커를 설치하면 서버의 물리 NIC가 docker0라는 가상 브리지 네트워크로 연결된다.
    - docker0는 Docker를 실행시킨 후에 디폴트로 만들어진다.
    - Docker 컨테이너가 실행되면 컨테이너에 172.17.0.0/16이라는 서브넷 마스크를 가진 프라이빗 IP 주소가 eth0으로 자동으로 할당된다.
    - 이 가상 NIC는 OSI 참조 모델의 레이어 2인 가상 네트워크 인터페이스로, 페어인 NIC와 터널링 통신을 한다.
  - NAPT(Network Address Port Translation)
    - Docker 컨테이너와 외부 네트워크가 통신을 할 때는 가상 브리지 docker0와 호스트 OS의 물리 NIC에서 패킷을 전송하려는 장치가 필요하다.
    - Docker에서는 NAPT 기능을 사용하여 연결한다.
    - NAPT란 하나의 IP 주소를 여러 컴퓨터가 공유하는 기술로, IP 주소와 포트 번호를 변환하는 기능이다.
    - 프라이빗 IP 주소와 글로벌 IP 주소를 투과적으로 상호 변환하는 기술로, TCP/IP의 포트 번호까지 동적으로 변환하기 때문에 하나의 글로벌 IP 주소로 여러 대의 머신이 동시에 연결할 수 있다.
    - Docker에서는 NAPT에 리눅스의 iptables를 사용하고 있다.



- Docker 이미지의 데이터 관리 장치
  - Copy on Write
    - 어떤 데이터를 복사할 필요가 생겼을 때는 새로운 빈 영역을 확보하고 거기에 복사를 한다.
    - 만일 복사한 데이터에 변경이 없었다면 그 복사는 불필요한 것이 된다.
    - 복사한 데이터의 용량이 크면 클수록 쓸데없는 낭비가 발생한다.
    - 만일 바로 복사하지 않고 원래의 데이터를 그대로 참조시켜, 원본 또는 복사 중 한 쪽에 수정이 발생한 시점에 새로운 빈 영역을 확보하고 데이터를 복사한다면 이러한 낭비를 막을 수 있다.
    - 위와 같은 방식을 Copy on Write라고 부른다.
    - Docker는 Copy on Write 방식으로 컨테이너의 이미지를 관리한다.
  - AUFS
    - 다른 시스템의 파일이나 디렉토리를 투과적으로 겹쳐서 하나의 파일 트리를 구성할 수 있는 파일 시스템이다.
  - Btrfs
    - 리눅스용 Copy on Write 파일 시스템.
    - 과거의 상태로 돌아갈 수 있는 롤백 기능이나 어떤 시점에서의 상태를 저장할 수 있는 스냅샷 기능을 갖고 있다.
  - Device Mapper
    - 리눅스의 블록 디바이스 드라이버와 그것을 지원하는 라이브러리들이다.
    - 파일 시스템의 I/O와 디바이스의 매핑 관계를 관리한다.
  - OverlayFS
    - UnionFS 중 하나로, 파일 시스템에 다른 파일 시스템을 투과적으로 머징하는 장치이다.
  - ZFS
    - 볼륨 관리, 스냅샷, 체크섬 처리, 리플리케이션 등을 지원하는 파일 시스템. 



- Docker는 컨테이너를 독립된 공간으로 관리한다.
  - Docker는 하나의 Linux 커널을 여러 개의 컨테이너에서 공유하고 있다.
  - 컨테이너 안에서 작동하는 프로세스를 하나의 그룹으로 관리하고, 그룹마다 각각 파일 시스템이나 호스트명, 네트워크 등을 할당하고 있다.
  - 그룹이 다르면 프로세스나 파일에 대한 엑세스를 할 수 없다.
  - 이러한 구조를 활용하여 컨테이너를 독립된 공간으로 관리한다.



- Docker Content Trust(DCT)

  - 도커 이미지의 위장이나 변조 방지

    - 도커에는 인프라 구성이 포함되기 때문에 제삼자가 악의적으로 이미지를 위장하거나 변조하지 못하도록 이미지를 보호해야 한다.

    - DCT를 활용하여 보호가 가능하다.

  - 서명

    - 이미지 작성자가 Docker 레지스트리에 이미지를 업로드하기 전에 로컬 환경에서 이미지 작성자의 비밀키를 사용하여 이미지에 서명한다.
    - 이 비밀 키를 Offline Key라고 한다.
    - 이 키는 보안상 매우 중요한 키이므로 엄중하게 관리할 필요가 있다.

  - 검증

    - 서명이 된 이미지를 다운로드 할 때 이미지 작성자의 공개키를 사용하여 이미지가 진짜인지 아닌지를 확인한다.
    - 만일 변조된 경우에는 그 이미지를 무효로 만든다.
    - 이 공개키를 Tagging Key라고 한다.

  - DCT 기능 유효화하기

    - 아래와 같이 작성한 후 이미지를 받아보면, 다운 받은 이미지에 대한 검증이 발생하는 것을 확인 가능하다.
    - 서명이 되어있지 않은 이미지를 사용하면 오류가 발생한다.

  ```bash
  # 아래 명령어에서 1만 0으로 변경하면 무효화하는 명령어이다.
  $ export DOCKER_CONTENT_TRUST=1
  ```



# docker 설치하기

> ubuntu 기준

- HTTP 패키지 설치

  - update apt

  ```bash
  $ sudo apt update
  ```

  - HTTP 패키지 설치

  ```bash
  $ sudo apt-get install -y ca-certificates curl gnupg lsb-release
  ```



- GPG key 추가 및 repository setup

  - GPG key 추가

  ```bash
  $ sudo mkdir -p /etc/apt/keyrings
  $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
  ```

  - repository setup

  ```bash
  $ echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
  ```



- docker 설치

  - apt-get update

  ```bash
  $ sudo apt-get update
  ```

  - docker 설치

  ```bash
  $ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
  ```

  - test
    - test image를 다운 받아, 해당 이미지로 container를 실행한다.
    - 실행이 완료되면 메시지를 출력하고 종료된다.

  ```bash
  $ sudo docker run hello-world
  ```



- 권한 관리

  - docker group에 사용자 추가

  ```bash
  $ sudo usermod -a -G docker <사용자명>
  ```

  











# 도커 명령어

## Docker

- Docker 버전 확인

  ```bash
  $ docker version
  ```



- Docker 실행 환경 확인

  ```bash
  $ docker system info
  ```



- Docker 디스크 이용 상황 확인

  - 이미지, 컨테이너 등에 대한 요약된 정보를 확인 가능하다.

  ```bash
  $ docker system df
  ```





## Docker Hub

- Docker Hub에 공개된 이미지 검색

  - `--no-trunc`: 결과를 모두 표시
  - `--limit n`: n건의 검색 결과를 표시
  - `--filter=stars=n`: 즐겨찾기의 수가 n 이상인 이미지만 검색

  ```bash
  $ docker search [옵션] 키워드
  ```



- Docker Hub에 로그인

  - `-p(--password), -u(--username)`을 옵션으로 줄 수 있다.
    - 따로 지정해 주지 않고 입력하면 CLI로 물어본다.
  - 다른 환경에 Docker 리포지토리가 있는 경우에는 서버명을 지정해 줘야 한다.
    - 서버명을 지정하지 않았을 경우 Docker Hub에 엑세스한다.

  ```bash
  $ docker login [옵션] [서버]
  ```



- Docker Hub에서 로그아웃

  - 서버명을 지정하지 않았을 경우 Docker Hub에 엑세스한다.

  ```bash
  $ docker logout [서버명]
  ```



- Docker Hub에 이미지 업로드하기

  - `docker login` 명령으로 로그인 해야 가능하다.
  - Docker Hub에 업로드할 이미지는 `<Docker Hub 사용자명>/이미지명:태그명`의 형태로 지정해야 한다.

  ```bash
  $ docker image push 이미지명[:태그명]
  ```





## Docker image

- Docker 이미지 다운로드 하기

  - 태그에는 일반적으로 버전 정보가 들어간다.
    - 태그를 생략할 경우 자동으로 latest가 태그로 들어가 최신버전이 다운로드 된다.
    - 그렇다고 태그가 무조건 버전을 뜻하는 것은 아니다.
    - 태그는 본래 이미지에 붙이는 표시 같은 것인데 버전이 주로 사용될 뿐이다.
  - `-a` 옵션을 주면 모든 태그의 Docker 이미지를 다운 받으며, 이 때는 태그명을 입력할 수 없다.
  - 이미지명 대신 이미지를 다운 받을 URL을 지정할 수도 있다.

  ```bash
  $ docker pull [옵션] 이미지명[:태그명]
  ```



- Docker 이미지 리스트 보기

  - `-a`(`--all`): 모든 이미지를 표시한다.
  - `--digests`: 다이제스트를 표시할지 여부, 다이제스트는 Docker 레지스트리(Docker Hub 등)에 업로드된 이미지를 식별하기 위한 값이다.
  - `--no-trunc`: 결과를 모두 표시한다.
  - `--quiet,-q`:  이미지 ID만 표시한다.

  ```bash
  $ docker images [옵션] [리포지토리명]
  $ docker image ls [옵션] [리포지토리명]
  ```



- 특정 이미지 정보 상세 보기

  - 이미지 ID, 작성일, docker 버전, CPU 아키텍처 등의 정보를 JSON 형태로 확인 가능하다.
  - `--format="{{필드명}}"` 옵션을 통해 JSON의 특정 필드만 확인이 가능하다.

  ```bash
  $ docker inspect [--format="{{필드명}}"] 이미지명
  ```



- 이미지 이름 변경하기

  - 아래 명령어를 입력 후 이미지 리스트를 보면 기존 이미지가 변경된 것이 아니라 새로운 이미지가 하나 더 생긴 것을 볼 수 있다.
    - 정확히 말하면 새로운 이미지가 생기거나 복제된 것이 아니다. 동일한 이미지에 다른 태그가 붙은 것 뿐이다.
    - 두 이미지의 ID를 확인해보면 동일한 것을 볼 수 있다.

  ```bash
  $ docker tag <기존 이미지명>:<기존 태그명> <태그를 붙일 이미지명>:<변경할 태그명>
  ```



- 이미지 삭제

  - `-f(--force)`: 이미지를 강제로 삭제
  - `--no-prune`: 중간 이미지를 삭제하지 않음
  - 이미지명 대신 이미지 ID를 입력해도 된다.
  - 여러 개의 이미지를 한 번에 삭제하려면 이미지명 사이에 공백을 두고 입력하면 된다.

  ```bash
  $ docker rmi [옵션] 이미지명 [이미지명2]
  ```



- 사용하지 않는 도커 이미지 삭제

  - `-a(--all)`: 사용하지 않는 Docker 이미지 전부 삭제
    - 기본적으로 아래 명령어는 dangling image만을 삭제한다.
    - 동일한 태그를 가진 Docker 이미지가 빌드될 경우, 기존에 있던 이미지는 삭제되지는 않고, tag가 none으로 변경된 상태로 남아 있게 되는데 이를 dangling image라 한다.
    - `-a`를 줄 경우 dangling image와 함께 현재 컨테이너에서 사용하지 않는 이미지들도 함께 삭제한다.
  - `-f(--force)`: 이미지를 강제로 삭제
  - `--filter 조건`: 조건에 부합하는 dangling image들을 삭제한다.

  ```bash
  $ docker image prune [옵션]
  ```





## Docker Container

- Docker Container
  - 이미지를 통해 컨테이너를 생성한다.
    - 이미지의 실체는 Docker에서 서버 기능을 작동시키기 위해 필요한 디렉토리 및 파일들이다.
    - 구체적으로는 리눅스의 작동에 필요한 /etc나 /bin 등과 같은 디렉토리 및 파일들이다.
  - 컨테이너를 생성하면 이미지에 포함된 리눅스의 디렉토리와 파일들의 스냅샷이 컨테이너로 들어가게 된다.
    - 스냅샷이란 스토리지 안에 존재하는 파일과 디렉토리를 특정 시점에서 추출한 것을 말한다.
  - 컨테이너는 아래와 같은 라이프 사이클을 지닌다.
    - 생성: 컨테이너가 생성되어 실행되고 있지 않은 상태
    - 실행: 컨테이너가 실행 중인 상태
    - 정지: 컨테이너가 실행 되었다 정지된 상태
    - 삭제: 컨테이너가 삭제 된 상태



- 컨테이너 생성하기

  - `--name`: 컨테이너의 이름을 지정할 수 있다.

  ```bash
  $ docker create [옵션] 이미지명[:태그]
  ```



- 컨테이너 리스트 보기

  ```bash
  $ docker ps [옵션]
  ```

  - `-a(--all)`: 현재 동작중이 아닌 컨테이너도 모두 보여준다.
  - `-f(--filter)`: 표시할 컨테이너의 필터링
  - `--format`: 표시 포맷을 지정
    - 이미지 ID, 실행 명령, 컨테이너 가동 시간, 컨테이너 디스크 크기, 볼륨 마운트, 네트워크명 등의 추가적인 정보를 볼 수 있다.
  - `-n(--last)`: 마지막으로 실행된 n건의 컨테이너만 표시
  - `-l(--latest)`: 마지막으로 실행된 컨테이너만 표시
  - `--no-trunc`: 정보를 생략하지 않고 표시
  - `-q(--quiet)`: 컨테이너 ID만 표시
  - `-s(--size)`: 파일 크기 표시



- 컨테이너 정보 보기

  - 옵션
    - `--all`, `-a`: 모든 컨데이터 보기(실행 중이 아닌 컨테이터 포함)
    - `--format`: 포맷을 설정해서 볼 수 있다.
    - `--no-stream`: stream 형태가 아닌 명령어를 입력한 순간의 결과만 본다.
    - `--no-trunc`: 정보를 생략하지 않고 표시
  
  ```bash
  $ docker stats
  ```
  
  - 특정 컨테이너 정보 보기
  
  ```bash
  $ docker stats 컨테이너명/컨테이너ID
  ```



- 컨테이너 시작하기

  - 공백으로 구분하여 복수의 컨테이너를 실행시킬 수 있다.
  - run 명령어와 일부 옵션을 공유한다.

  ```bash
  $ docker start [옵션] <컨테이너명 또는 ID> [컨테이너명 또는 ID]
  ```



- 컨테이너 생성 및 시작하기

  - create와 start를 동시에 수행하는 명령어
  - 컨테이너에서 실행할 명령의 예시로 `/bin/bash`를 입력할 경우 콘솔의 프롬프트가 $에서 #로 바뀌는 것을 확인 가능하다.

  ```bash
  $ docker run [옵션] 이미지명[:태그명] [컨테이너에서 실행할 명령]
  ```

  - 기본 옵션
    - `--cidfile`: 컨테이너 ID를 파일로 출력한다.
    - `-i(--interactive)`: 컨테이너의 표준 입력을 연다.
    - `-t(--tty)`: 단말기 디바이스를 사용한다.
    - `--name`: 컨테이너의 이름을 지정할 수 있다.
  - 컨테이너 실행 옵션
    - `-a(--attach)`: 표준 입력(STDIN), 표준 출력(STDOUT), 표준 오류 출력(STRERR)에 attach한다.
    - `-d(--detach)`: 백그라운드에서 실행한다.
    - `-u(--user)`: 사용자명을 지정한다.
    - `--restart=[no | on-failure | onfailure:횟수 | always | unless-stopped]`: 명령의 실행 결과에 따라 컨테이너를 재시작 한다.
    - `--rm`: 명령 실행 완료 후 컨테이너를 자동으로 삭제한다.
  - 네트워크 설정 옵션
    - `--add--host=[호스트명:IP 주소]`: 컨테이너의 /etc/hosts에 호스트명과 IP 주소를 정의.
    - `--dns=[IP 주소]`: 컨테이너용 DNS 서버의 IP 주소 지정
    - `--expose`: 지정한 범위의 포트 번호를 할당
    - `--mac-address=[MAC 주소]`: 컨테이너의 MAC 주소를 지정
    - `--net=[bridge(기본값) | none | container:<name | id> | host | NETWORK]`: 컨테이너의 네트워크를 지정
    - `-h(--hostname)`: 컨테이너 자신의 호스트명을 지정
    - `-p(--publish)[호스트의 포트 번호]:[컨테이너의 포트 번호]`: 호스트와 컨테이너의 포트 매핑, 호스트의 포트 번호로 접근할 경우 컨테이너의 포트 번호에 접속된다.
    - `-P(--publish--all)`: 호스트의 임의의 포트를 컨테이너에 할당
  - 자원 설정 옵션
    - `-c(--cpu-shares)`: CPU의 메모리 사용 배분(비율)
    - `-m(--memory)`: 사용할 메모리를 제한하여 실행(단위는 b,k,m,g 중 하나)
    - `-v(--volume)=[호스트의 디렉토리]:[컨테이너의 디렉토리]`: 호스트와 컨테이너의 디렉토리를 공유, 상대경로는 입력이 불가능하다.
  - 컨테이너 환경설정 옵션
    - `-e(--env)=환경변수`: 환경변수를 설정한다.
    - `--env-file=파일명`: 환경변수를 파일을 통해 설정한다.
    - `--read-only=[true|false]`: 컨테이너의 파일 시스템을 읽기 전용으로 만든다.
    - `-w(--workdir)=경로`: 컨테이너의 작업 디렉토리를 지정한다.
    - `-u(--user)=사용자명`: 사용자명 또는 UID를 지정한다.
  - 주의점
    - restart 옵션은 되도록 지정해주는 것이 좋다.
    - 만일 Docker client자체가 내려갈 경우 Docker client를 재실행했을 때, restart 옵션을 주지 않은 컨테이너들을 자동으로 재생성되지 않기 때문이다.
    - 물론 수동으로 띄워도 되지만 만일 A, B, C 컨테이너가 하나의 서비스를 구성하고 있고, B, C 컨테이너가 A 컨테이너에 의존적이라 A 컨테이너가 정상적으로 떠있어야 B, C도 동작하는 경우에 문제가 생길 수 있다.
    - A에 restart 옵션이 없다면 Docker client가 재실행되면서 B, C는 자동으로 다시 생성되지만 A는 재생성되지 않아 B, C도 Error가 발생하는 경우가 있을 수 있기 때문이다.
    - 정확히는 위와 같이 복수의 컨테이너가 하나의 서비스를 구성하고 있을 경우 "restart 옵션을 설정해주는 것이 좋다"기 보다 하나의 서비스를 구성하고 있는 컨테이너들은 restart 설정을 맞춰주는 것이 좋다.
  - `port` 옵션
    - `-p(--publish)[호스트의 포트 번호]:[컨테이너의 포트 번호]`는 컨테이너 외부의 `host:port`를 컨테이너 내부의 `host:port`와 연결하겠다는 의미이다.



- 컨테이너 정지

  - 공백으로 구분하여 복수의 컨테이너를 정지시킬 수 있다.
  - `-t(--time)`: 컨테이너를 몇 초 후에 정지시킬지 지정한다.

  ```bash
  $ docker stop [옵션] <컨테이너명 또는 ID> [컨텡너명 또는 ID]
  ```



- 컨테이너 재시작

  - 공백으로 구분하여 복수의 컨테이너를 재시작할 수 있다.
  - `-t(--time)`: 컨테이너를 몇 초 후에 재시작할지 지정한다.

  ```bash
  $ docker restart [옵션] <컨테이너명 또는 ID> [컨텡너명 또는 ID]
  ```



- 컨테이너 삭제

  - 공백으로 구분하여 복수의 컨테이너를 삭제할 수 있다.
  - `-f(--force)`: 실행 중인 컨테이너를 강제로 삭제
  - `-v(--volumes)`: 할당한 볼륨을 삭제

  ```bash
  $ docker rm [옵션] <컨테이너명 또는 ID> [컨텡너명 또는 ID]
  ```



- 컨테이너 중단/재개

  - 실행중인 컨테이너에서 작동 중인 프로세스를 중단시킬 때 사용한다.

  ```bash
  $ docker pause <컨테이너명 또는 ID>
  
  $ docker unpause <컨테이너명 또는 ID>
  ```



## 가동 중인 Docker Container 연결

- 컨테이너에 연결하기

  ```bash
  $ docker attach 컨테이너명
  ```



- 가동 컨테이너에서 프로세스 실행

  - 가동 중인 컨테이너에서 새로운 프로세스를 실행
    - 백그라운드에서 실행되고 있는 컨테이너에 액세스하소자 할 때는  attach  명령으로 연결해도 쉘이 작동하지 않는 경우 명령을 접수할 수 없다.
    - 따라서 아래 명령어를 입력하여 임의의 명령을 실행한다.

  - `-d(--detach)`: 명령을 백그라운드에서 실행한다.
  - `-i(--interactive)`: 컨테이너의 표준 입력을 연다.
  - `-t(--tty)`: tty 디바이스를 사용한다.
  - `-u(--user)`: 사용자명을 지정한다.

  ```bash
  $ docker exec [옵션] <컨테이너 식별자> <실행할 명령> [인수]
  ```



- 가동 컨테이너의 프로세스 확인

  ```bash
  $ docker top 컨테이너
  ```



-  가동 컨테이너의 포트 전송 확인

  ```bash
  $ docker port 컨테이너
  ```



- 컨테이너 이름 변경

  ```bash
  $ docker rename <기존 이름> <변경할 이름>
  ```



- 컨테이너 안의 파일을 복사

  ```bash
  # 컨테이너에서 호스트로 복사
  $ docker cp <컨테이너 식별자>:<컨테이너 안의 파일 경로> <호스트 디렉토리 경로>
  
  # 호스트에서 컨테이너로 복사
  $ docker cp <호스트 파일> <컨테이너 식별자>:<컨테이너 안의 파일 경로>
  ```



- 컨테이너의 변경 사항 확인

  - 컨테이너가 최초로 생성되었을 때와 달라진 점을 확인.
  - A는 파일의 추가, D는 파일의 삭제, C는 파일의 수정을 나타낸다.

  ```bash
  $ docker diff <컨테이너 식별자>
  ```





##  Docker Container Network

- Docker Container Network
  - Docker container 간의 통신을 수행한다.
  -  Docker는 기본값으로 bridge, host. none 세 개의 네트워크를 만든다.
    - 네트워크를 명시적으로 지정하지 않고 Docker 컨테이너를 시작하면 기본값인 bridge 네트워크로 Docker 컨테이너를 시작한다. 



- Docker 네트워크 목록 확인

  - `-f(--filter) key=value`: 출력을 필터링한다.
  - `--no-trunc`: 상세 정보를 출력한다.
  - `-q(--quiet)`: 네트워크  ID만 출력한다.

  ```bash
  $ docker network ls [옵션]
  ```



- 네트워크 상세 정보 확인

  - 아래 명령어를 통해 현재 해당 네트워크에 연결되어 있는 컨테이너를 확인 가능하다.
    - 반대의 경우도 마찬가지로 컨테이너에서도 inspect 명령어를 통해 컨테이너에 연결된 network를 확인 가능하다.
  
  ```bash
  $ docker network inspect [옵션] <네트워크명 혹은 id>
  ```



- 네트워크 작성

  - `-d(--driver)`: 네트워크 브리지 또는 오버레이(기본값은 bridge)
  - `--ip-range`: 컨테이너에 할당하는 IP 주소의 범위를 지정
  - `--subnet`: 서브넷을 CIDR 형식으로 지정
  - `--ipv6`: IPv6 네트워크를 유효화할지 말지(bool)
  - `-label`: 네트워크에 설정하는 라벨 

  ```bash
  $ docker network create [옵션] <네트워크명 혹은 id>
  ```



- 네트워크 연결

  - `--ip`: IPv4 주소
  - `--ip6`: IPv6 주소
  - `--alias`: 앨리어스명
  - `--link`: 다른 컨테이너에 대한 링크

  ```bash
  $ docker network connect [옵션] <네트워크명 혹은 id> <컨테이너명 혹은 id>
  ```



- 네트워크 연결 해제

  ```bash
  $ docker network disconnect <네트워크명 혹은 id> <컨테이너명 혹은 id>
  ```



- 연결 확인

  - `ping` 명령어를 container 내에서 실행한다.

  ```bash
  $ docker exec <컨테이너1 식별자> ping <컨테이너2 식별자>
  ```



- 네트워크 삭제

  ```bash
  $ docker network rm [옵션] <네트워크명 혹은 id>
  ```



- 일괄삭제

  - 아무 컨테이너에도 연결되지 않은 network를 모두 삭제한다.

  ```bash
  $ docker network prune
  ```



- 주의점

  - docker network에 container가 연결되는 순간 각 컨테이너에 IPAddress가 할당된다.
    - 예를 들어 network의 IP가 127.24.0.1일 때, 컨테이너 A, B를 순서대로 연결하면 A에는 127.24.0.2,  B에는  127.24.0.3이라는 IPAddress가 할당된다.
    - 만일 도중에 컨테이너 A가 내려가게 되면 B에 127.24.0.2가 할당되게 된다.

  - 주의할 점은 **순서대로** 할당된다는 점이다.
    - 예를 들어 기존 코드에서 B 컨테이너가 A 컨테이너로 요청을 보내기 위해서는 127.24.0.2로 요청을 보내야 했다.
    - 그런데 도중에 A 컨테이너가 내려가게 되면 기존에 B가 A 컨테이너에 요청을 보내기 위해 사용하던 127.24.0.2가 B 컨테이너 자신의 IP가 된다.
    - 또한 A 컨테이너 입장에서도 기존에 127.24.0.2로 바인드를 걸어 놨는데 A 컨테이너를 다시 띄울 경우 바인드를 걸어 놓은 127.24.0.2는 이제 B 컨테이너의 IP가 되었으므로 docker network와 연결이 되지 않는다.
    - 따라서 이 경우 B를 내리고 A를 먼저 띄운 후  B를 띄워야 한다.





## Docker 이미지 생성

- 컨테이너를 바탕으로 이미지 작성

  - `-a(--author)`: 작성자를 지정한다.
  - `-m(--message)`: 메시지를 지정한다.
  - `-c(--change)`:  커밋 할 때 Dockerfile 명령을 지정한다.
  - `-p(--pause)`: 컨테이너를 일시 정지하고 커밋한다.

  ```bash
  $ docker commit [옵션] <컨테이너 식별자> [이미지명[:태그명]]
  ```



- 컨테이너를 tar 파일로 출력

  - 다른 이름으로 출력하고 자 할 경우에는 `>` 를 사용한다.

  ```bash
  $ docker export <컨테이너 식별자> [> 다른 이름.tar]
  ```

  - 생성된 tar 파일의 상세 정보를 확인하면 컨테이너를 작동시키기 위해 필요한 파일을 확인할 수 있다.

  ```bash
  $ tar -tf <tar 파일명>
  ```



- tar 파일로 이미지 작성

  ```bash
  $ docker import <파일 또는 URL> [이미지명[:태그명]]
  ```



- 이미지 저장

  - Docker 이미지를 tar 파일로 저장
  - `-o`: 생성할 압축 파일의 이름
  
  ```bash
  $ docker save [옵션] [저장 파일명] <이미지명>
  ```



- 이미지 읽어 들이기

  - `-i`로 읽어 들일 파일명을 지정
  
  ```bash
  $ docker load [옵션]
  ```



- export와 save의 차이
  -  export
    - 컨테이너를 작동시키는 데 필요한 파일을 모두 압축 아카이브로 모을 수 있다.
    - 따라서 export를 통해 나온  tar 파일을 실행하면 컨테이너의 루트 파일 시스템을 그대로 추출할 수 있다.
  -  save
    - 이미지의 레이어 구조도 포함된 형태로 압축 아카이브로 모을 수 있다.
  - export 명령으로 작성한 것은 import로,   save 명령으로 작성한 것은 load로 읽어 들여야 한다.



















